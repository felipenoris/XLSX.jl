<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Cells and data · XLSX.jl</title><meta name="title" content="Cells and data · XLSX.jl"/><meta property="og:title" content="Cells and data · XLSX.jl"/><meta property="twitter:title" content="Cells and data · XLSX.jl"/><meta name="description" content="Documentation for XLSX.jl."/><meta property="og:description" content="Documentation for XLSX.jl."/><meta property="twitter:description" content="Documentation for XLSX.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">XLSX.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Formatting Guide</span><ul><li><a class="tocitem" href="../../formatting/cellFormatting/">Cell formats</a></li><li><a class="tocitem" href="../../formatting/conditionalFormatting/">Conditional formats</a></li><li><a class="tocitem" href="../../formatting/mergedCells/">Working with merged cells</a></li><li><a class="tocitem" href="../../formatting/examples/">Examples</a></li></ul></li><li><a class="tocitem" href="../../migration/">Migration Guide</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../files/">Files and worksheets</a></li><li class="is-active"><a class="tocitem" href>Cells and data</a><ul class="internal"><li><a class="tocitem" href="#Cell-referencing"><span>Cell referencing</span></a></li><li><a class="tocitem" href="#Cell-data"><span>Cell data</span></a></li><li><a class="tocitem" href="#Defined-names"><span>Defined names</span></a></li></ul></li><li><a class="tocitem" href="../formats/">Formats</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Cells and data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Cells and data</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/felipenoris/XLSX.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/felipenoris/XLSX.jl/blob/master/docs/src/api/data.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Cells-and-data"><a class="docs-heading-anchor" href="#Cells-and-data">Cells and data</a><a id="Cells-and-data-1"></a><a class="docs-heading-anchor-permalink" href="#Cells-and-data" title="Permalink"></a></h1><h2 id="Cell-referencing"><a class="docs-heading-anchor" href="#Cell-referencing">Cell referencing</a><a id="Cell-referencing-1"></a><a class="docs-heading-anchor-permalink" href="#Cell-referencing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.CellRef" href="#XLSX.CellRef"><code>XLSX.CellRef</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CellRef(n::AbstractString)
CellRef(row::Int, col::Int)</code></pre><p>A <code>CellRef</code> represents a cell location given by row and column identifiers.</p><p><code>CellRef(&quot;B6&quot;)</code> indicates a cell located at column <code>2</code> and row <code>6</code>.</p><p>These row and column integers can also be passed directly to the <code>CellRef</code> constructor: <code>CellRef(6,2) == CellRef(&quot;B6&quot;)</code>.</p><p>Finally, a convenience macro <code>@ref_str</code> is provided: <code>ref&quot;B6&quot; == CellRef(&quot;B6&quot;)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">cn = XLSX.CellRef(&quot;AB1&quot;)
println( XLSX.row_number(cn) ) # will print 1
println( XLSX.column_number(cn) ) # will print 28
println( string(cn) ) # will print out AB1

cn = XLSX.CellRef(1, 28)
println( XLSX.row_number(cn) ) # will print 1
println( XLSX.column_number(cn) ) # will print 28
println( string(cn) ) # will print out AB1

cn = XLSX.ref&quot;AB1&quot;
println( XLSX.row_number(cn) ) # will print 1
println( XLSX.column_number(cn) ) # will print 28
println( string(cn) ) # will print out AB1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/types.jl#L7-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.row_number" href="#XLSX.row_number"><code>XLSX.row_number</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">row_number(c::CellRef) :: Int</code></pre><p>Returns the row number of a given cell reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/cellref.jl#L286-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.column_number" href="#XLSX.column_number"><code>XLSX.column_number</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">column_number(c::CellRef) :: Int</code></pre><p>Returns the column number of a given cell reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/cellref.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.eachrow" href="#Base.eachrow"><code>Base.eachrow</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachrow(sheet)</code></pre><p>Creates a row iterator for a worksheet.</p><p>Example: Query all cells from columns 1 to 4.</p><pre><code class="language-julia hljs">left = 1  # 1st column
right = 4 # 4th column
for sheetrow in eachrow(sheet)
    for column in left:right
        cell = XLSX.getcell(sheetrow, column)

        # do something with cell
    end
end</code></pre><p>Note: The <code>eachrow</code> row iterator will not return any row that  consists entirely of <code>EmptyCell</code>s. These are simply not seen  by the iterator. The <code>length(eachrow(sheet))</code> function therefore  defines the number of rows that are not entirely empty and will,  in any case, only succeed if the worksheet cache is in use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/stream.jl#L328-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.eachtablerow" href="#XLSX.eachtablerow"><code>XLSX.eachtablerow</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">eachtablerow(sheet, [columns]; [first_row], [column_labels], [header], [stop_in_empty_row], [stop_in_row_function], [keep_empty_rows], [normalizenames]) -&gt; TableRowIterator</code></pre><p>Constructs an iterator of table rows. Each element of the iterator is of type <code>TableRow</code>.</p><p><code>header</code> is a boolean indicating whether the first row of the table is a table header.</p><p>If <code>header == false</code> and no <code>column_labels</code> were supplied, column names will be generated following the column names found in the Excel file.</p><p>The <code>columns</code> argument is a column range, as in <code>&quot;B:E&quot;</code>. If <code>columns</code> is not supplied, the column range will be inferred by the non-empty contiguous cells in the first row of the table.</p><p>The user can replace column names by assigning the optional <code>column_labels</code> input variable with a <code>Vector{Symbol}</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating whether an empty row marks the end of the table. If <code>stop_in_empty_row=false</code>, the iterator will continue to fetch rows until there&#39;s no more rows in the Worksheet. The default behavior is <code>stop_in_empty_row=true</code>. Empty rows may be returned by the iterator when <code>stop_in_empty_row=false</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns a <code>Bool</code> indicating if the end of the table was reached.</p><p>Example for <code>stop_in_row_function</code>:</p><pre><code class="nohighlight hljs">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p><code>keep_empty_rows</code> determines whether rows where all column values are equal to <code>missing</code> are kept (<code>true</code>) or skipped (<code>false</code>) by the row iterator. <code>keep_empty_rows</code> never affects the <em>bounds</em> of the iterator; the number of rows read from a sheet is only affected by <code>first_row</code>, <code>stop_in_empty_row</code> and <code>stop_in_row_function</code> (if specified). <code>keep_empty_rows</code> is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.</p><p><code>normalizenames</code> controls whether column names will be &quot;normalized&quot; to valid Julia identifiers. By default, this is false. If normalizenames=true, then column names with spaces, or that start with numbers, will be adjusted with underscores to become  valid Julia identifiers. This is useful when you want to access columns via dot-access or getproperty, like file.col1. The  identifier that comes after the . must be valid, so spaces or identifiers starting with numbers aren&#39;t allowed. (Based ib CSV.jl&#39;s <code>CSV.normalizename</code>.)</p><p>Example code:</p><pre><code class="nohighlight hljs">for r in XLSX.eachtablerow(sheet)
    # r is a `TableRow`. Values are read using column labels or numbers.
    rn = XLSX.row_number(r) # `TableRow` row number.
    v1 = r[1] # will read value at table column 1.
    v2 = r[:COL_LABEL2] # will read value at column labeled `:COL_LABEL2`.
end</code></pre><p>See also <a href="#XLSX.gettable"><code>XLSX.gettable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/table.jl#L97-L147">source</a></section></article><h2 id="Cell-data"><a class="docs-heading-anchor" href="#Cell-data">Cell data</a><a id="Cell-data-1"></a><a class="docs-heading-anchor-permalink" href="#Cell-data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.readdata" href="#XLSX.readdata"><code>XLSX.readdata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readdata(source, sheet, ref)
readdata(source, sheetref)</code></pre><p>Return a scalar, vector or matrix with values from a spreadsheet file. &#39;ref&#39; can be a defined name, a cell reference or a cell, column, row  or non-contiguous range.</p><p>See also <a href="#XLSX.getdata"><code>XLSX.getdata</code></a>.</p><p><strong>Examples</strong></p><p>These function calls are equivalent.</p><pre><code class="language-julia hljs">julia&gt; XLSX.readdata(&quot;myfile.xlsx&quot;, &quot;mysheet&quot;, &quot;A2:B4&quot;)
3×2 Array{Any,2}:
 1  &quot;first&quot;
 2  &quot;second&quot;
 3  &quot;third&quot;

julia&gt; XLSX.readdata(&quot;myfile.xlsx&quot;, 1, &quot;A2:B4&quot;)
3×2 Array{Any,2}:
 1  &quot;first&quot;
 2  &quot;second&quot;
 3  &quot;third&quot;

julia&gt; XLSX.readdata(&quot;myfile.xlsx&quot;, &quot;mysheet!A2:B4&quot;)
3×2 Array{Any,2}:
 1  &quot;first&quot;
 2  &quot;second&quot;
 3  &quot;third&quot;</code></pre><p>Non-contiguous ranges return vectors of Array{Any, 2} with an entry for every non-contiguous (comma-separated)  element in the range.</p><pre><code class="language-julia hljs">julia&gt; XLSX.readdata(&quot;customXml.xlsx&quot;, &quot;Mock-up&quot;, &quot;Location&quot;) # `Location` is a `definedName` for a non-contiguous range
4-element Vector{Matrix{Any}}:
 [&quot;Here&quot;;;]
 [missing;;]
 [missing;;]
 [missing;;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/read.jl#L720-L766">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.getdata" href="#XLSX.getdata"><code>XLSX.getdata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getdata(sheet, ref)
getdata(sheet, row, column)</code></pre><p>Returns a scalar, matrix or a vector of matrices with values from  a spreadsheet.</p><p><code>ref</code> can be a cell reference or a range or a valid defined name.</p><p>If <code>ref</code> is a single cell, a scalar is returned.</p><p>Most ranges are rectangular and will return a 2-D matrix  (<code>Array{AbstractCell, 2}</code>). For row and column ranges, the  extent of the range in the other dimension is determined by  the worksheet&#39;s dimension.</p><p>A non-contiguous range (which may not be rectangular) will return  a vector of <code>Array{AbstractCell, 2}</code> matrices with one element for  each non-contiguous (comma separated) element in the range.</p><p>Indexing in a <code>Worksheet</code> will dispatch to <code>getdata</code> method.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; f = XLSX.readxlsx(&quot;myfile.xlsx&quot;)

julia&gt; sheet = f[&quot;mysheet&quot;] # Worksheet

julia&gt; matrix = sheet[&quot;A1:B4&quot;] # CellRange

julia&gt; matrix = sheet[&quot;A:B&quot;] # Column range

julia&gt; matrix = sheet[&quot;1:4&quot;] # Row range

julia&gt; matrix = sheet[&quot;Contiguous&quot;] # Named range

julia&gt; matrix = sheet[1:30, 1] # use unit ranges to define rows and/or columns

julia&gt; matrix = sheet[[1, 2, 3], 1] # vectors of integers to define rows and/or columns

julia&gt; vector = sheet[&quot;A1:A4,C1:C4,G5&quot;] # Non-contiguous range

julia&gt; vector = sheet[&quot;Location&quot;] # Non-contiguous named range

julia&gt; scalar = sheet[2, 2] # Cell &quot;B2&quot;
</code></pre><p>See also <a href="#XLSX.readdata"><code>XLSX.readdata</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/worksheet.jl#L94-L144">source</a></section><section><div><pre><code class="language-julia hljs">getdata(ws::Worksheet, cell::Cell) :: CellValue</code></pre><p>Returns a Julia representation of a given cell value. The result data type is chosen based on the value of the cell as well as its style.</p><p>For example, date is stored as integers inside the spreadsheet, and the style is the information that is taken into account to chose <code>Date</code> as the result type.</p><p>For numbers, if the style implies that the number is visualized with decimals, the method will return a float, even if the underlying number is stored as an integer inside the spreadsheet XML.</p><p>If <code>cell</code> has empty value or empty <code>String</code>, this function will return <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/cell.jl#L166-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.getcell" href="#XLSX.getcell"><code>XLSX.getcell</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getcell(xlsxfile, cell_reference_name) :: AbstractCell
getcell(worksheet, cell_reference_name) :: AbstractCell
getcell(sheetrow, column_name) :: AbstractCell
getcell(sheetrow, column_number) :: AbstractCell</code></pre><p>Returns the internal representation of a worksheet cell.</p><p>Returns <code>XLSX.EmptyCell</code> if the cell has no data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/stream.jl#L301-L310">source</a></section><section><div><pre><code class="language-julia hljs">getcell(sheet, ref)
getcell(sheet, row, col)</code></pre><p>Return an <code>AbstractCell</code> that represents a cell in the spreadsheet. Return a 2-D matrix as <code>Array{AbstractCell, 2}</code> if <code>ref</code> is a  rectangular range. For row and column ranges, the extent of the range in the other  dimension is determined by the worksheet&#39;s dimension. A non-contiguous range (which may not be rectangular) will return  a vector of <code>Array{AbstractCell, 2}</code> with one element for each  non-contiguous (comma separated) element in the range.</p><p>If <code>ref</code> is a range, <code>getcell</code> dispatches to <a href="#XLSX.getcellrange"><code>getcellrange</code></a>.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; xf = XLSX.readxlsx(&quot;myfile.xlsx&quot;)

julia&gt; sheet = xf[&quot;mysheet&quot;]

julia&gt; cell = XLSX.getcell(sheet, &quot;A1&quot;)

julia&gt; cell = XLSX.getcell(sheet, 1:3, [2,4,6])
</code></pre><p>Other examples are as <a href="#XLSX.getdata"><code>getdata()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/worksheet.jl#L299-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.getcellrange" href="#XLSX.getcellrange"><code>XLSX.getcellrange</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">getcellrange(sheet, rng)</code></pre><p>Return a matrix with cells as <code>Array{AbstractCell, 2}</code>. <code>rng</code> must be a valid cell range, column range or row range, as in <code>&quot;A1:B2&quot;</code>, <code>&quot;A:B&quot;</code> or <code>&quot;1:2&quot;</code>, or a non-contiguous range. For row and column ranges, the extent of the range in the other  dimension is determined by the worksheet&#39;s dimension. A non-contiguous range (which may not be rectangular) will return  a vector of <code>Array{AbstractCell, 2}</code> with one element for each  non-contiguous (comma separated) element in the range.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; ncr = &quot;B3,A1,C2&quot; # non-contiguous range, &quot;out of order&quot;.
&quot;B3,A1,C2&quot;

julia&gt;  XLSX.getcellrange(f[1], ncr)
3-element Vector{Matrix{XLSX.AbstractCell}}:
 [XLSX.Cell(B3, &quot;&quot;, &quot;&quot;, &quot;5&quot;, XLSX.Formula(&quot;&quot;, nothing));;]
 [XLSX.Cell(A1, &quot;&quot;, &quot;&quot;, &quot;2&quot;, XLSX.Formula(&quot;&quot;, nothing));;]
 [XLSX.Cell(C2, &quot;&quot;, &quot;&quot;, &quot;5&quot;, XLSX.Formula(&quot;&quot;, nothing));;]
</code></pre><p>For other examples, see <a href="#XLSX.getcell"><code>getcell()</code></a> and <a href="#XLSX.getdata"><code>getdata()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/worksheet.jl#L425-L453">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.gettable" href="#XLSX.gettable"><code>XLSX.gettable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gettable(
    sheet,
    [columns];
    [first_row],
    [column_labels],
    [header],
    [infer_eltypes],
    [stop_in_empty_row],
    [stop_in_row_function],
    [keep_empty_rows],
    [normalizenames]
) -&gt; DataTable</code></pre><p>Returns tabular data from a spreadsheet as a struct <code>XLSX.DataTable</code>. Use this function to create a <code>DataFrame</code> from package <code>DataFrames.jl</code>.</p><p>Use <code>columns</code> argument to specify which columns to get. For example, <code>&quot;B:D&quot;</code> will select columns <code>B</code>, <code>C</code> and <code>D</code>. If <code>columns</code> is not given, the algorithm will find the first sequence of consecutive non-empty cells.</p><p>Use <code>first_row</code> to indicate the first row from the table. <code>first_row=5</code> will look for a table starting at sheet row <code>5</code>. If <code>first_row</code> is not given, the algorithm will look for the first non-empty row in the spreadsheet.</p><p><code>header</code> is a <code>Bool</code> indicating if the first row is a header. If <code>header=true</code> and <code>column_labels</code> is not specified, the column labels for the table will be read from the first row of the table. If <code>header=false</code> and <code>column_labels</code> is not specified, the algorithm will generate column labels. The default value is <code>header=true</code>.</p><p>Use <code>column_labels</code> as a vector of symbols to specify names for the header of the table.</p><p>Use <code>normalizenames=true</code> to normalize column names to valid Julia identifiers.</p><p>Use <code>infer_eltypes=true</code> to get <code>data</code> as a <code>Vector{Any}</code> of typed vectors. The default value is <code>infer_eltypes=true</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating whether an empty row marks the end of the table. If <code>stop_in_empty_row=false</code>, the <code>TableRowIterator</code> will continue to fetch rows until there&#39;s no more rows in the Worksheet. The default behavior is <code>stop_in_empty_row=true</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns a <code>Bool</code> indicating if the end of the table was reached.</p><p><strong>Example for <code>stop_in_row_function</code></strong></p><pre><code class="language-julia hljs">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p><code>keep_empty_rows</code> determines whether rows where all column values are equal to <code>missing</code> are kept (<code>true</code>) or dropped (<code>false</code>) from the resulting table. <code>keep_empty_rows</code> never affects the <em>bounds</em> of the table; the number of rows read from a sheet is only affected by <code>first_row</code>, <code>stop_in_empty_row</code> and <code>stop_in_row_function</code> (if specified). <code>keep_empty_rows</code> is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFrames, XLSX

julia&gt; df = XLSX.openxlsx(&quot;myfile.xlsx&quot;) do xf
        DataFrame(XLSX.gettable(xf[&quot;mysheet&quot;]))
    end</code></pre><p>See also: <a href="#XLSX.readtable"><code>XLSX.readtable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/table.jl#L579-L649">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.readtable" href="#XLSX.readtable"><code>XLSX.readtable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readtable(
    source,
    [sheet,
    [columns]];
    [first_row],
    [column_labels],
    [header],
    [infer_eltypes],
    [stop_in_empty_row],
    [stop_in_row_function],
    [enable_cache],
    [keep_empty_rows],
    [normalizenames]
) -&gt; DataTable</code></pre><p>Returns tabular data from a spreadsheet as a struct <code>XLSX.DataTable</code>. Use this function to create a <code>DataFrame</code> from package <code>DataFrames.jl</code>  (or other <code>Tables.jl</code>` compatible object).</p><p>If <code>sheet</code> is not given, the first sheet in the <code>XLSXFile</code> will be used.</p><p>Use <code>columns</code> argument to specify which columns to get. For example, <code>&quot;B:D&quot;</code> will select columns <code>B</code>, <code>C</code> and <code>D</code>. If <code>columns</code> is not given, the algorithm will find the first sequence of consecutive non-empty cells. A valid <code>sheet</code> must be specified  when specifying <code>columns</code>.</p><p>Use <code>first_row</code> to indicate the first row of the table. <code>first_row=5</code> will look for a table starting at sheet row <code>5</code>. If <code>first_row</code> is not given, the algorithm will look for the first non-empty row in the spreadsheet.</p><p><code>header</code> is a <code>Bool</code> indicating if the first row is a header. If <code>header=true</code> and <code>column_labels</code> is not specified, the column labels for the table will be read from the first row of the table. If <code>header=false</code> and <code>column_labels</code> is not specified, the algorithm will generate column labels. The default value is <code>header=true</code>.</p><p>Use <code>column_labels</code> to specify names for the header of the table.</p><p>Use <code>normalizenames=true</code> to normalize column names to valid Julia identifiers.</p><p>Use <code>infer_eltypes=true</code> to get <code>data</code> as a <code>Vector{Any}</code> of typed vectors. The default value is <code>infer_eltypes=true</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating whether an empty row marks the  end of the table. If <code>stop_in_empty_row=false</code>, the <code>TableRowIterator</code> will  continue to fetch rows until there&#39;s no more rows in the Worksheet or range. The default behavior is <code>stop_in_empty_row=true</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns  a <code>Bool</code> indicating if the end of the table was reached.</p><p>Example for <code>stop_in_row_function</code>:</p><pre><code class="language-julia hljs">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p><code>enable_cache</code> is a boolean that determines whether cell data are loaded  into the worksheet cache on reading. The default behavior is <code>enable_cache=true</code>.</p><p><code>keep_empty_rows</code> determines whether rows where all column values are equal  to <code>missing</code> are kept (<code>true</code>) or dropped (<code>false</code>) from the resulting table.  <code>keep_empty_rows</code> never affects the <em>bounds</em> of the table; the number of  rows read from a sheet is only affected by <code>first_row</code>, <code>stop_in_empty_row</code>  and <code>stop_in_row_function</code> (if specified). <code>keep_empty_rows</code> is only checked once the first and last row of the table  have been determined, to see whether to keep or drop empty rows between the  first and the last row. The default behavior is `<code>keep_empty_rows=false</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFrames, XLSX

julia&gt; df = DataFrame(XLSX.readtable(&quot;myfile.xlsx&quot;, &quot;mysheet&quot;))</code></pre><p>See also: <a href="#XLSX.gettable"><code>XLSX.gettable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/read.jl#L781-L867">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.readto" href="#XLSX.readto"><code>XLSX.readto</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">readto(
    source,
    [sheet,
    [columns]],
    sink;
    [first_row],
    [column_labels],
    [header],
    [infer_eltypes],
    [stop_in_empty_row],
    [stop_in_row_function],
    [enable_cache],
    [keep_empty_rows],
    [normalizenames]
) -&gt; sink</code></pre><p>Read and parse an Excel worksheet, materializing directly using  the <code>sink</code> function (e.g. <code>DataFrame</code> or <code>StructArray</code>).</p><p>Takes the same keyword arguments as <a href="#XLSX.readtable"><code>XLSX.readtable</code></a> </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFrames, StructArrays, XLSX

julia&gt; df = XLSX.readto(&quot;myfile.xlsx&quot;, DataFrame)

julia&gt; df = XLSX.readto(&quot;myfile.xlsx&quot;, StructArray)

julia&gt; df = XLSX.readto(&quot;myfile.xlsx&quot;, &quot;mysheet&quot;, DataFrame)

julia&gt; df = XLSX.readto(&quot;myfile.xlsx&quot;, &quot;mysheet&quot;, &quot;A:C&quot;, DataFrame)</code></pre><p>See also: <a href="#XLSX.gettable"><code>XLSX.gettable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/read.jl#L897-L934">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.writetable" href="#XLSX.writetable"><code>XLSX.writetable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writetable(filename, table; [overwrite], [sheetname])</code></pre><p>Write a Tables.jl compatible <code>table</code> as an Excel file with the specified file name (and sheet name, if specified).</p><p>If a file with the given name already exists, writing will fail unless <code>overwrite=true</code> is specified, in which  case the existing file will be overwritten.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/tables_interface.jl#L25-L32">source</a></section><section><div><pre><code class="language-julia hljs">writetable(filename::Union{AbstractString, IO}, tables::Vector{Pair{String, T}}; overwrite::Bool=false)
writetable(filename::Union{AbstractString, IO}, tables::Pair{String, Any}...; overwrite::Bool=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/tables_interface.jl#L35-L38">source</a></section><section><div><pre><code class="language-julia hljs">writetable(filename, data, columnnames; [overwrite], [sheetname])</code></pre><ul><li><code>data</code> is a vector of columns.</li><li><code>columnames</code> is a vector of column labels.</li><li><code>overwrite</code> is a <code>Bool</code> to control if <code>filename</code> should be overwritten if already exists.</li><li><code>sheetname</code> is the name for the worksheet.</li></ul><p>Returns the filepath of the written file if a filename is supplied, or <code>nothing</code> if writing to an <code>IO</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import XLSX
columns = [ [1, 2, 3, 4], [&quot;Hey&quot;, &quot;You&quot;, &quot;Out&quot;, &quot;There&quot;], [10.2, 20.3, 30.4, 40.5] ]
colnames = [ &quot;integers&quot;, &quot;strings&quot;, &quot;floats&quot; ]
XLSX.writetable(&quot;table.xlsx&quot;, columns, colnames)</code></pre><p>See also: <a href="#XLSX.writetable!"><code>XLSX.writetable!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/write.jl#L1456-L1476">source</a></section><section><div><pre><code class="language-julia hljs">writetable(filename::Union{AbstractString, IO}; overwrite::Bool=false, kw...)
writetable(filename::Union{AbstractString, IO}, tables::Vector{Tuple{String, Vector{Any}, Vector{String}}}; overwrite::Bool=false)</code></pre><p>Write multiple tables.</p><p><code>kw</code> is a variable keyword argument list. Each element should be in this format: <code>sheetname=( data, column_names )</code>, where <code>data</code> is a vector of columns and <code>column_names</code> is a vector of column labels.</p><p>Returns the filepath of the written file if a filename is supplied, or <code>nothing</code> if writing to an <code>IO</code>.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; import DataFrames, XLSX

julia&gt; df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[&quot;Fist&quot;, &quot;Sec&quot;, &quot;Third&quot;])

julia&gt; df2 = DataFrames.DataFrame(AA=[&quot;aa&quot;, &quot;bb&quot;], AB=[10.1, 10.2])

julia&gt; XLSX.writetable(&quot;report.xlsx&quot;, &quot;REPORT_A&quot; =&gt; df1, &quot;REPORT_B&quot; =&gt; df2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/write.jl#L1496-L1518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.writetable!" href="#XLSX.writetable!"><code>XLSX.writetable!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">writetable!(sheet::Worksheet, table; anchor_cell::CellRef=CellRef(&quot;A1&quot;)))</code></pre><p>Write a Tables.jl compatible <code>table</code> to the specified sheet starting with the  anchor cell (if given) in the top left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/tables_interface.jl#L46-L51">source</a></section><section><div><pre><code class="language-julia hljs">writetable!(
    sheet::Worksheet,
    data,
    columnnames;
    anchor_cell::CellRef=CellRef(&quot;A1&quot;),
    write_columnnames::Bool=true,
)</code></pre><p>Write tabular data <code>data</code> with labels given by <code>columnnames</code> to <code>sheet</code>, starting at <code>anchor_cell</code>.</p><p><code>data</code> must be a vector of columns. <code>columnnames</code> must be a vector of column labels.</p><p>Column labels that are not of type <code>String</code> will be converted  to strings before writing. Any data columns that are not of  type <code>String</code>, <code>Float64</code>, <code>Int64</code>, <code>Bool</code>, <code>Date</code>, <code>Time</code>,  <code>DateTime</code>, <code>Missing</code>, or <code>Nothing</code> will be converted to strings  before writing.</p><p>See also: <a href="#XLSX.writetable"><code>XLSX.writetable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/write.jl#L882-L905">source</a></section></article><h2 id="Defined-names"><a class="docs-heading-anchor" href="#Defined-names">Defined names</a><a id="Defined-names-1"></a><a class="docs-heading-anchor-permalink" href="#Defined-names" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="XLSX.addDefinedName" href="#XLSX.addDefinedName"><code>XLSX.addDefinedName</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">addDefinedName(xf::XLSXFile,  name::AbstractString, value::Union{Int, Float64, String}; absolute=true)
addDefinedName(xf::XLSXFile,  name::AbstractString, value::AbstractString; absolute=true)
addDefinedName(sh::Worksheet, name::AbstractString, value::Union{Int, Float64, String}; absolute=true)
addDefinedName(sh::Worksheet, name::AbstractString, value::AbstractString; absolute=true)</code></pre><p>Add a defined name to the Workbook or Worksheet. If an <code>XLSXFile</code> is passed, the defined name  is added to the Workbook. If a <code>Worksheet</code> is passed, the defined name is added to the Worksheet.</p><p>When adding defined name referring to a cell or range to a workbook, <code>value</code> must include the sheet  name (e.g. <code>Sheet1!A1:B2</code>). </p><p>If the new <code>definedName</code> is a cell reference or range, by default, it will be an absolute  reference (e.g. <code>$A$1:$C$6</code>). If <code>absolute=false</code> is specified, the new <code>definedName</code> will be  a relative reference (e.g. <code>A1:C6</code>). Any <code>absolute</code> argument specified is ignored if the  <code>definedName</code> is not a cell reference or range.</p><p>In the context of <code>XLSX.jl</code> there is no difference between an absolute reference and a relative  reference. However, Excel treats them differently. When <code>definedNames</code> are read in as part of  an XLSXFile, we keep track of whether they are absolute or not. If the XLSXFile is subsequently  written out again, the status of the <code>definedNames</code> is preserved.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; XLSX.addDefinedName(sh, &quot;ID&quot;, &quot;C21&quot;)

julia&gt; XLSX.addDefinedName(sh, &quot;NEW&quot;, &quot;A1:B2&quot;)

julia&gt; XLSX.addDefinedName(sh, &quot;my_name&quot;, &quot;A1,B2,C3&quot;)

julia&gt; XLSX.addDefinedName(xf, &quot;New&quot;, &quot;&#39;Mock-up&#39;!A1:B2&quot;)

julia&gt; XLSX.addDefinedName(xf, &quot;Life_the_universe_and_everything&quot;, 42)

julia&gt; XLSX.addDefinedName(xf, &quot;first_name&quot;, &quot;Hello World&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/1fd6ca8c5046d7e6d1ec0fc04507dbed6c0d5a9d/src/workbook.jl#L317-L354">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../files/">« Files and worksheets</a><a class="docs-footer-nextpage" href="../formats/">Formats »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 12 September 2025 01:15">Friday 12 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
