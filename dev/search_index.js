var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"XLSX.XLSXFile\nXLSX.readxlsx\nXLSX.openxlsx\nXLSX.writexlsx\nXLSX.sheetnames\nXLSX.sheetcount\nXLSX.hassheet\nXLSX.Worksheet\nXLSX.readdata\nXLSX.getdata\nXLSX.getcell\nXLSX.getcellrange\nXLSX.row_number\nXLSX.column_number\nXLSX.eachrow\nXLSX.readtable\nXLSX.gettable\nXLSX.eachtablerow\nXLSX.writetable\nXLSX.writetable!\nXLSX.rename!\nXLSX.addsheet!\nXLSX.setFormat\nXLSX.setUniformFormat\nXLSX.setFont\nXLSX.setUniformFont\nXLSX.setBorder\nXLSX.setUniformBorder\nXLSX.setOutsideBorder\nXLSX.setFill\nXLSX.setUniformFill\nXLSX.setAlignment\nXLSX.setUniformAlignment\nXLSX.setUniformStyle\nXLSX.setColumnWidth\nXLSX.setRowHeight","category":"page"},{"location":"api/#XLSX.XLSXFile","page":"API Reference","title":"XLSX.XLSXFile","text":"XLSXFile represents a reference to an Excel file.\n\nIt is created by using XLSX.readxlsx or XLSX.openxlsx.\n\nFrom a XLSXFile you can navigate to a XLSX.Worksheet reference as shown in the example below.\n\nExample\n\nxf = XLSX.readxlsx(\"myfile.xlsx\")\nsh = xf[\"mysheet\"] # get a reference to a Worksheet\n\n\n\n\n\n","category":"type"},{"location":"api/#XLSX.readxlsx","page":"API Reference","title":"XLSX.readxlsx","text":"readxlsx(source::Union{AbstractString, IO}) :: XLSXFile\n\nMain function for reading an Excel file. This function will read the whole Excel file into memory and return a closed XLSXFile.\n\nConsider using XLSX.openxlsx for lazy loading of Excel file contents.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.openxlsx","page":"API Reference","title":"XLSX.openxlsx","text":"openxlsx(f::F, source::Union{AbstractString, IO}; mode::AbstractString=\"r\", enable_cache::Bool=true) where {F<:Function}\n\nOpen XLSX file for reading and/or writing. It returns an opened XLSXFile that will be automatically closed after applying f to the file.\n\nDo syntax\n\nThis function should be used with do syntax, like in:\n\nXLSX.openxlsx(\"myfile.xlsx\") do xf\n    # read data from `xf`\nend\n\nFilemodes\n\nThe mode argument controls how the file is opened. The following modes are allowed:\n\nr : read mode. The existing data in source will be accessible for reading. This is the default mode.\nw : write mode. Opens an empty file that will be written to source.\nrw : edit mode. Opens source for editing. The file will be saved to disk when the function ends.\n\nwarning: Warning\nThe rw mode is known to produce some data loss. See #159.Simple data should work fine. Users are advised to use this feature with caution when working with formulas and charts.\n\nArguments\n\nsource is IO or the complete path to the file.\nmode is the file mode, as explained in the last section.\nenable_cache:\n\nIf enable_cache=true, all read worksheet cells will be cached. If you read a worksheet cell twice it will use the cached value instead of reading from disk the second time.\n\nIf enable_cache=false, worksheet cells will always be read from disk. This is useful when you want to read a spreadsheet that doesn't fit into memory.\n\nThe default value is enable_cache=true.\n\nExamples\n\nRead from file\n\nThe following example shows how you would read worksheet cells, one row at a time, where myfile.xlsx is a spreadsheet that doesn't fit into memory.\n\njulia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do xf\n          for r in XLSX.eachrow(xf[\"mysheet\"])\n              # read something from row `r`\n          end\n       end\n\nWrite a new file\n\nXLSX.openxlsx(\"new.xlsx\", mode=\"w\") do xf\n    sheet = xf[1]\n    sheet[1, :] = [1, Date(2018, 1, 1), \"test\"]\nend\n\nEdit an existing file\n\nXLSX.openxlsx(\"edit.xlsx\", mode=\"rw\") do xf\n    sheet = xf[1]\n    sheet[2, :] = [2, Date(2019, 1, 1), \"add new line\"]\nend\n\nSee also XLSX.readxlsx.\n\n\n\n\n\nopenxlsx(source::Union{AbstractString, IO}; mode=\"r\", enable_cache=true) :: XLSXFile\n\nSupports opening a XLSX file without using do-syntax. In this case, the user is responsible for closing the XLSXFile using close or writing it to file using XLSX.writexlsx.\n\nSee also XLSX.writexlsx.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.writexlsx","page":"API Reference","title":"XLSX.writexlsx","text":"writexlsx(output_source, xlsx_file; [overwrite=false])\n\nWrites an Excel file given by xlsx_file::XLSXFile to IO or filepath output_source.\n\nIf overwrite=true, output_source (when a filepath) will be overwritten if it exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.sheetnames","page":"API Reference","title":"XLSX.sheetnames","text":"sheetnames(xl::XLSXFile)\nsheetnames(wb::Workbook)\n\nReturns a vector with Worksheet names for this Workbook.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.sheetcount","page":"API Reference","title":"XLSX.sheetcount","text":"sheetcount(xlsfile) :: Int\n\nCounts the number of sheets in the Workbook.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.hassheet","page":"API Reference","title":"XLSX.hassheet","text":"hassheet(wb::Workbook, sheetname::AbstractString)\nhassheet(xl::XLSXFile, sheetname::AbstractString)\n\nReturns true if wb contains a sheet named sheetname.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.Worksheet","page":"API Reference","title":"XLSX.Worksheet","text":"A Worksheet represents a reference to an Excel Worksheet.\n\nFrom a Worksheet you can query for Cells, cell values and ranges.\n\nExample\n\nxf = XLSX.readxlsx(\"myfile.xlsx\")\nsh = xf[\"mysheet\"] # get a reference to a Worksheet\nprintln( sh[2, 2] ) # access element \"B2\" (2nd row, 2nd column)\nprintln( sh[\"B2\"] ) # you can also use the cell name\nprintln( sh[\"A2:B4\"] ) # or a cell range\nprintln( sh[:] ) # all data inside worksheet's dimension\n\n\n\n\n\n","category":"type"},{"location":"api/#XLSX.readdata","page":"API Reference","title":"XLSX.readdata","text":"readdata(source, sheet, ref)\nreaddata(source, sheetref)\n\nReturns a scalar or matrix with values from a spreadsheet.\n\nSee also XLSX.getdata.\n\nExamples\n\nThese function calls are equivalent.\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet\", \"A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", 1, \"A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet!A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.getdata","page":"API Reference","title":"XLSX.getdata","text":"getdata(sheet, ref)\ngetdata(sheet, row, column)\n\nReturns a scalar or a matrix with values from a spreadsheet. ref can be a cell reference or a range.\n\nIndexing in a Worksheet will dispatch to getdata method.\n\nExample\n\njulia> f = XLSX.readxlsx(\"myfile.xlsx\")\n\njulia> sheet = f[\"mysheet\"]\n\njulia> matrix = sheet[\"A1:B4\"]\n\njulia> single_value = sheet[2, 2] # B2\n\nSee also XLSX.readdata.\n\n\n\n\n\ngetdata(ws::Worksheet, cell::Cell) :: CellValue\n\nReturns a Julia representation of a given cell value. The result data type is chosen based on the value of the cell as well as its style.\n\nFor example, date is stored as integers inside the spreadsheet, and the style is the information that is taken into account to chose Date as the result type.\n\nFor numbers, if the style implies that the number is visualized with decimals, the method will return a float, even if the underlying number is stored as an integer inside the spreadsheet XML.\n\nIf cell has empty value or empty String, this function will return missing.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.getcell","page":"API Reference","title":"XLSX.getcell","text":"getcell(xlsxfile, cell_reference_name) :: AbstractCell\ngetcell(worksheet, cell_reference_name) :: AbstractCell\ngetcell(sheetrow, column_name) :: AbstractCell\ngetcell(sheetrow, column_number) :: AbstractCell\n\nReturns the internal representation of a worksheet cell.\n\nReturns XLSX.EmptyCell if the cell has no data.\n\n\n\n\n\ngetcell(sheet, ref)\n\nReturns an AbstractCell that represents a cell in the spreadsheet.\n\nExample:\n\njulia> xf = XLSX.readxlsx(\"myfile.xlsx\")\n\njulia> sheet = xf[\"mysheet\"]\n\njulia> cell = XLSX.getcell(sheet, \"A1\")\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.getcellrange","page":"API Reference","title":"XLSX.getcellrange","text":"getcellrange(sheet, rng)\n\nReturns a matrix with cells as Array{AbstractCell, 2}. rng must be a valid cell range, as in \"A1:B2\".\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.row_number","page":"API Reference","title":"XLSX.row_number","text":"row_number(c::CellRef) :: Int\n\nReturns the row number of a given cell reference.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.column_number","page":"API Reference","title":"XLSX.column_number","text":"column_number(c::CellRef) :: Int\n\nReturns the column number of a given cell reference.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.eachrow","page":"API Reference","title":"XLSX.eachrow","text":"eachrow(sheet)\n\nCreates a row iterator for a worksheet.\n\nExample: Query all cells from columns 1 to 4.\n\nleft = 1  # 1st column\nright = 4 # 4th column\nfor sheetrow in XLSX.eachrow(sheet)\n    for column in left:right\n        cell = XLSX.getcell(sheetrow, column)\n\n        # do something with cell\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.readtable","page":"API Reference","title":"XLSX.readtable","text":"readtable(\n    source,\n    sheet,\n    [columns];\n    [first_row],\n    [column_labels],\n    [header],\n    [infer_eltypes],\n    [stop_in_empty_row],\n    [stop_in_row_function],\n    [keep_empty_rows]\n) -> DataTable\n\nReturns tabular data from a spreadsheet as a struct XLSX.DataTable. Use this function to create a DataFrame from package DataFrames.jl.\n\nUse columns argument to specify which columns to get. For example, \"B:D\" will select columns B, C and D. If columns is not given, the algorithm will find the first sequence of consecutive non-empty cells.\n\nUse first_row to indicate the first row from the table. first_row=5 will look for a table starting at sheet row 5. If first_row is not given, the algorithm will look for the first non-empty row in the spreadsheet.\n\nheader is a Bool indicating if the first row is a header. If header=true and column_labels is not specified, the column labels for the table will be read from the first row of the table. If header=false and column_labels is not specified, the algorithm will generate column labels. The default value is header=true.\n\nUse column_labels to specify names for the header of the table.\n\nUse infer_eltypes=true to get data as a Vector{Any} of typed vectors. The default value is infer_eltypes=false.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the end of the table. If stop_in_empty_row=false, the TableRowIterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is stop_in_empty_row=true.\n\nstop_in_row_function is a Function that receives a TableRow and returns a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function:\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nkeep_empty_rows determines whether rows where all column values are equal to missing are kept (true) or dropped (false) from the resulting table.  keep_empty_rows never affects the bounds of the table; the number of rows read from a sheet is only affected by, first_row, stop_in_empty_row and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.\n\nExample\n\njulia> using DataFrames, XLSX\n\njulia> df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\"))\n\nSee also: XLSX.gettable.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.gettable","page":"API Reference","title":"XLSX.gettable","text":"gettable(\n    sheet,\n    [columns];\n    [first_row],\n    [column_labels],\n    [header],\n    [infer_eltypes],\n    [stop_in_empty_row],\n    [stop_in_row_function],\n    [keep_empty_rows]\n) -> DataTable\n\nReturns tabular data from a spreadsheet as a struct XLSX.DataTable. Use this function to create a DataFrame from package DataFrames.jl.\n\nUse columns argument to specify which columns to get. For example, \"B:D\" will select columns B, C and D. If columns is not given, the algorithm will find the first sequence of consecutive non-empty cells.\n\nUse first_row to indicate the first row from the table. first_row=5 will look for a table starting at sheet row 5. If first_row is not given, the algorithm will look for the first non-empty row in the spreadsheet.\n\nheader is a Bool indicating if the first row is a header. If header=true and column_labels is not specified, the column labels for the table will be read from the first row of the table. If header=false and column_labels is not specified, the algorithm will generate column labels. The default value is header=true.\n\nUse column_labels as a vector of symbols to specify names for the header of the table.\n\nUse infer_eltypes=true to get data as a Vector{Any} of typed vectors. The default value is infer_eltypes=false.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the end of the table. If stop_in_empty_row=false, the TableRowIterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is stop_in_empty_row=true.\n\nstop_in_row_function is a Function that receives a TableRow and returns a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nkeep_empty_rows determines whether rows where all column values are equal to missing are kept (true) or dropped (false) from the resulting table. keep_empty_rows never affects the bounds of the table; the number of rows read from a sheet is only affected by first_row, stop_in_empty_row and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.\n\nExample\n\njulia> using DataFrames, XLSX\n\njulia> df = XLSX.openxlsx(\"myfile.xlsx\") do xf\n        DataFrame(XLSX.gettable(xf[\"mysheet\"]))\n    end\n\nSee also: XLSX.readtable.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.eachtablerow","page":"API Reference","title":"XLSX.eachtablerow","text":"eachtablerow(sheet, [columns]; [first_row], [column_labels], [header], [stop_in_empty_row], [stop_in_row_function], [keep_empty_rows])\n\nConstructs an iterator of table rows. Each element of the iterator is of type TableRow.\n\nheader is a boolean indicating whether the first row of the table is a table header.\n\nIf header == false and no column_labels were supplied, column names will be generated following the column names found in the Excel file.\n\nThe columns argument is a column range, as in \"B:E\". If columns is not supplied, the column range will be inferred by the non-empty contiguous cells in the first row of the table.\n\nThe user can replace column names by assigning the optional column_labels input variable with a Vector{Symbol}.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the end of the table. If stop_in_empty_row=false, the iterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is stop_in_empty_row=true. Empty rows may be returned by the iterator when stop_in_empty_row=false.\n\nstop_in_row_function is a Function that receives a TableRow and returns a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function:\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nkeep_empty_rows determines whether rows where all column values are equal to missing are kept (true) or skipped (false) by the row iterator. keep_empty_rows never affects the bounds of the iterator; the number of rows read from a sheet is only affected by first_row, stop_in_empty_row and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.\n\nExample code:\n\nfor r in XLSX.eachtablerow(sheet)\n    # r is a `TableRow`. Values are read using column labels or numbers.\n    rn = XLSX.row_number(r) # `TableRow` row number.\n    v1 = r[1] # will read value at table column 1.\n    v2 = r[:COL_LABEL2] # will read value at column labeled `:COL_LABEL2`.\nend\n\nSee also XLSX.gettable.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.writetable","page":"API Reference","title":"XLSX.writetable","text":"writetable(filename, table; [overwrite], [sheetname])\n\nWrite Tables.jl table to the specified filename.\n\n\n\n\n\nwritetable(filename::Union{AbstractString, IO}, tables::Vector{Pair{String, T}}; overwrite::Bool=false)\nwritetable(filename::Union{AbstractString, IO}, tables::Pair{String, Any}...; overwrite::Bool=false)\n\n\n\n\n\nwritetable(filename, data, columnnames; [overwrite], [sheetname])\n\ndata is a vector of columns.\ncolumnames is a vector of column labels.\noverwrite is a Bool to control if filename should be overwritten if already exists.\nsheetname is the name for the worksheet.\n\nExample\n\nimport XLSX\ncolumns = [ [1, 2, 3, 4], [\"Hey\", \"You\", \"Out\", \"There\"], [10.2, 20.3, 30.4, 40.5] ]\ncolnames = [ \"integers\", \"strings\", \"floats\" ]\nXLSX.writetable(\"table.xlsx\", columns, colnames)\n\nSee also: XLSX.writetable!.\n\n\n\n\n\nwritetable(filename::Union{AbstractString, IO}; overwrite::Bool=false, kw...)\nwritetable(filename::Union{AbstractString, IO}, tables::Vector{Tuple{String, Vector{Any}, Vector{String}}}; overwrite::Bool=false)\n\nWrite multiple tables.\n\nkw is a variable keyword argument list. Each element should be in this format: sheetname=( data, column_names ), where data is a vector of columns and column_names is a vector of column labels.\n\nExample:\n\njulia> import DataFrames, XLSX\n\njulia> df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[\"Fist\", \"Sec\", \"Third\"])\n\njulia> df2 = DataFrames.DataFrame(AA=[\"aa\", \"bb\"], AB=[10.1, 10.2])\n\njulia> XLSX.writetable(\"report.xlsx\", \"REPORT_A\" => df1, \"REPORT_B\" => df2)\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.writetable!","page":"API Reference","title":"XLSX.writetable!","text":"writetable!(sheet::Worksheet, table; anchor_cell::CellRef=CellRef(\"A1\")))\n\nWrite Tables.jl table to the specified sheet.\n\n\n\n\n\nwritetable!(\n    sheet::Worksheet,\n    data,\n    columnnames;\n    anchor_cell::CellRef=CellRef(\"A1\"),\n    write_columnnames::Bool=true,\n)\n\nWrite tabular data data with labels given by columnnames to sheet, starting at anchor_cell.\n\ndata must be a vector of columns. columnnames must be a vector of column labels.\n\nSee also: XLSX.writetable.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.rename!","page":"API Reference","title":"XLSX.rename!","text":"rename!(ws::Worksheet, name::AbstractString)\n\nRenames a Worksheet.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.addsheet!","page":"API Reference","title":"XLSX.addsheet!","text":"addsheet!(workbook, [name]) :: Worksheet\n\nCreate a new worksheet with named name. If name is not provided, a unique name is created.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setFormat","page":"API Reference","title":"XLSX.setFormat","text":"setFormat(sh::Worksheet, cr::String; kw...) -> ::Int\nsetFormat(xf::XLSXFile,  cr::String; kw...) -> ::Int\n\nSet the format used used by a single cell, a cell range, a column range or  a named cell or named range in a worksheet or XLSXfile.\n\nThe function uses one keyword used to define a format:\n\nformat::String = nothing : Defines a built-in or custom number format\n\nThe format keyword can define some built-in formats by name:\n\nGeneral    : specifies internal format ID  0 (General)\nNumber     : specifies internal format ID  2 (0.00)\nCurrency   : specifies internal format ID  7 ($#,##0.00_);($#,##0.00))\nPercentage : specifies internal format ID  9 (0%)\nShortDate  : specifies internal format ID 14 (m/d/yyyy)\nLongDate   : specifies internal format ID 15 (d-mmm-yy)\nTime       : specifies internal format ID 21 (h:mm:ss)\nScientific : specifies internal format ID 48 (##0.0E+0)\n\nIf Currency is specified, Excel will use the appropriate local currency symbol.\n\nAlternatively, format can be used to specify any custom format directly.  Only weak checks are made of custom formats specified - they are otherwise added  to the XLSXfile verbatim.\n\nFormats may need characters that must to be escaped when specified.\n\nExamples:\n\njulia> XLSX.setFormat(sh, \"D2\"; format = \"h:mm AM/PM\")\n\njulia> XLSX.setFormat(xf, \"Sheet1!A2\"; format = \"# ??/??\")\n\njulia> XLSX.setFormat(sh, \"F1:F5\"; format = \"Currency\")\n\njulia> XLSX.setFormat(sh, \"A2\"; format = \"_-£* #,##0.00_-;-£* #,##0.00_-;_-£* \\\"-\\\"??_-;_-@_-\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setUniformFormat","page":"API Reference","title":"XLSX.setUniformFormat","text":"setUniformFormat(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformFormat(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the number format used by a cell range, a column range or a named range in a  worksheet or XLSXfile to be  to be uniformly the same format.\n\nFirst, the number format of the first cell in the range (the top-left cell) is updated according to the given kw... (using setFormat()). The resultant format is  then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform number format.\n\nThis is functionally equivalent to applying setFormat() to each cell in the range  but may be very marginally more efficient.\n\nThe value returned is the numfmtId of the format uniformly applied to the cells. If all cells in the range are EmptyCells, the returned value is -1.\n\nFor keyword definitions see setFormat().\n\nExamples:\n\njulia> XLSX.setUniformFormat(xf, \"Sheet1!A2:L6\"; format = \"# ??/??\")\n\njulia> XLSX.setUniformFormat(sh, \"F1:F5\"; format = \"Currency\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setFont","page":"API Reference","title":"XLSX.setFont","text":"setFont(sh::Worksheet, cr::String; kw...) -> ::Int\nsetFont(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the font used by a single cell, a cell range, a column range or  a named cell or named range in a worksheet or XLSXfile.\n\nFont attributes are specified using keyword arguments:\n\nbold::Bool = nothing    : set to true to make the font bold.\nitalic::Bool = nothing  : set to true to make the font italic.\nunder::String = nothing : set to single, double or none.\nstrike::Bool = nothing  : set to true to strike through the font.\nsize::Int = nothing     : set the font size (0 < size < 410).\ncolor::String = nothing : set the font color using an 8-digit hexadecimal RGB value.\nname::String = nothing  : set the font name.\n\nOnly the attributes specified will be changed. If an attribute is not specified, the current value will be retained. These are the only attributes supported currently.\n\nNo validation of the font names specified is performed. Available fonts will depend on what your system has installed. If you specify, for example, name = \"badFont\", that value will be written to the XLSXfile.\n\nAs an expedient to get fonts to work, the scheme attribute is simply dropped from new font definitions.\n\nThe color attribute can only be defined as rgb values.\n\nThe first two digits represent transparency (α). FF is fully opaque, while 00 is fully transparent.\nThe next two digits give the red component.\nThe next two digits give the green component.\nThe next two digits give the blue component.\n\nSo, FF000000 means a fully opaque black color.\n\nFont attributes cannot be set for EmptyCells. Set a cell value first. If a cell range or column range includes any EmptyCells, they will be quietly skipped and the font will be set for the remaining cells.\n\nFor single cells, the value returned is the fontId of the font applied to the cell. This can be used to apply the same font to other cells or ranges.\n\nFor cell ranges, column ranges and named ranges, the value returned is -1.\n\nExamples:\n\njulia> setFont(sh, \"A1\"; bold=true, italic=true, size=12, name=\"Arial\")          # Single cell\n\njulia> setFont(xf, \"Sheet1!A1\"; bold=false, size=14, color=\"FFB3081F\")           # Single cell\n\njulia> setFont(sh, \"A1:B7\"; name=\"Aptos\", under=\"double\", strike=true)           # Cell range\n\njulia> setFont(xf, \"Sheet1!A1:B7\"; size=24, name=\"Berlin Sans FB Demi\")          # Cell range\n\njulia> setFont(sh, \"A:B\"; italic=true, color=\"FF8888FF\", under=\"single\")         # Column range\n\njulia> setFont(xf, \"Sheet1!A:B\"; italic=true, color=\"FF8888FF\", under=\"single\")  # Column range\n\njulia> setFont(sh, \"bigred\"; size=48, color=\"FF00FF00\")                          # Named cell or range\n\njulia> setFont(xf, \"bigred\"; size=48, color=\"FF00FF00\")                          # Named cell or range\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setUniformFont","page":"API Reference","title":"XLSX.setUniformFont","text":"setUniformFont(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformFont(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the font used by a cell range, a column range or a named range in a  worksheet or XLSXfile to be uniformly the same font.\n\nFirst, the font attributes of the first cell in the range (the top-left cell) are updated according to the given kw... (using setFont()). The resultant font is  then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform font setting.\n\nThis differs from setFont() which merges the attributes defined by kw... into  the font definition used by each cell individually. For example, if you set the  font size to 12 for a range of cells, but these cells all use different fonts names  or colors, etc, setFont() will change the font size but leave the font name and  color unchanged for each cell individually. \n\nIn contrast, setUniformFont() will set the font size to 12 for the first cell, but  will then apply all the font attributes from the updated first cell (ie. name, color,  etc) to all the other cells in the range.\n\nThis can be more efficient when setting the same font for a large number of cells.\n\nThe value returned is the fontId of the font uniformly applied to the cells. If all cells in the range are EmptyCells the returned value is -1.\n\nFor keyword definitions see setFont().\n\nExamples:\n\njulia> setUniformFont(sh, \"A1:B7\"; bold=true, italic=true, size=12, name=\"Arial\")       # Cell range\n\njulia> setUniformFont(xf, \"Sheet1!A1:B7\"; size=24, name=\"Berlin Sans FB Demi\")          # Cell range\n\njulia> setUniformFont(sh, \"A:B\"; italic=true, color=\"FF8888FF\", under=\"single\")         # Column range\n\njulia> setUniformFont(xf, \"Sheet1!A:B\"; italic=true, color=\"FF8888FF\", under=\"single\")  # Column range\n\njulia> setUniformFont(sh, \"bigred\"; size=48, color=\"FF00FF00\")                          # Named range\n\njulia> setUniformFont(xf, \"bigred\"; size=48, color=\"FF00FF00\")                          # Named range\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setBorder","page":"API Reference","title":"XLSX.setBorder","text":"setBorder(sh::Worksheet, cr::String; kw...) -> ::Int}\nsetBorder(xf::XLSXFile, cr::String; kw...) -> ::Int\n\nSet the borders used used by a single cell, a cell range, a column range or  a named cell or named range in a worksheet or XLSXfile.\n\nBorders are independently defined for the keywords:\n\nleft::Vector{Pair{String,String} = nothing\nright::Vector{Pair{String,String} = nothing\ntop::Vector{Pair{String,String} = nothing\nbottom::Vector{Pair{String,String} = nothing\ndiagonal::Vector{Pair{String,String} = nothing\n[allsides::Vector{Pair{String,String} = nothing]\n\nThese represent each of the sides of a cell . The keyword diagonal defines diagonal lines running  across the cell. These lines must share the same style and color in any cell.\n\nAn additional keyword, allsides, is provided for convenience. It can be used  in place of the four side keywords to apply the same border setting to all four  sides at once. It cannot be used in conjunction with any of the side-specific  keywords but it can be used together with diagonal.\n\nThe two attributes that can be set for each keyword are style and rgb. Additionally, for diagonal borders, a third keyword, direction can be used.\n\nAllowed values for style are:\n\nnone\nthin\nmedium\ndashed\ndotted\nthick\ndouble\nhair\nmediumDashed\ndashDot\nmediumDashDot\ndashDotDot\nmediumDashDotDot\nslantDashDot\n\nThe color attribute is set by specifying an 8-digit hexadecimal value. No other color attributes can be applied.\n\nValid values for the direction keyword (for diagonal borders) are:\n\nup   : diagonal border runs bottom-left to top-right\ndown : diagonal border runs top-left to bottom-right\nboth : diagonal borders run both ways\n\nBoth diagonal borders share the same style and color.\n\nSetting only one of the attributes leaves the other attributes unchanged for that  side's border. Omitting one of the keywords leaves the border definition for that side unchanged, only updating the other, specified sides.\n\nBorder attributes cannot be set for EmptyCells. Set a cell value first. If a cell range or column range includes any EmptyCells, they will be quietly skipped and the border will be set for the remaining cells.\n\nFor single cells, the value returned is the borderId of the borders applied to the cell. This can be used to apply the same borders to other cells or ranges.\n\nFor cell ranges, column ranges and named ranges, the value returned is -1.\n\nExamples:\n\nJulia> setBorder(sh, \"D6\"; allsides = [\"style\" => \"thick\"], diagonal = [\"style\" => \"hair\", \"direction\" => \"up\"])\n\nJulia> setBorder(xf, \"Sheet1!D4\"; left     = [\"style\" => \"dotted\", \"color\" => \"FF000FF0\"],\n                                  right    = [\"style\" => \"medium\", \"color\" => \"FF765000\"],\n                                  top      = [\"style\" => \"thick\",  \"color\" => \"FF230000\"],\n                                  bottom   = [\"style\" => \"medium\", \"color\" => \"FF0000FF\"],\n                                  diagonal = [\"style\" => \"dotted\", \"color\" => \"FF00D4D4\"]\n                                  )\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setUniformBorder","page":"API Reference","title":"XLSX.setUniformBorder","text":"setUniformBorder(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformBorder(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the border used by a cell range, a column range or a named range in a  worksheet or XLSXfile to be uniformly the same border.\n\nFirst, the border attributes of the first cell in the range (the top-left cell) are updated according to the given kw... (using setBorder()). The resultant border is  then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform border setting.\n\nThis differs from setBorder() which merges the attributes defined by kw... into  the border definition used by each cell individually. For example, if you set the  border style to thin for a range of cells, but these cells all use different border   colors, setBorder() will change the border style but leave the border color unchanged  for each cell individually. \n\nIn contrast, setUniformBorder() will set the border style to thin for the first cell, but will then apply all the border attributes from the updated first cell (ie. both style  and color) to all the other cells in the range.\n\nThis can be more efficient when setting the same border for a large number of cells.\n\nThe value returned is the borderId of the border uniformly applied to the cells. If all cells in the range are EmptyCells the returned value is -1.\n\nFor keyword definitions see setBorder().\n\nExamples:\n\nJulia> setUniformBorder(sh, \"B2:D6\"; allsides = [\"style\" => \"thick\"], diagonal = [\"style\" => \"hair\"])\n\nJulia> setUniformBorder(xf, \"Sheet1!A1:F20\"; left     = [\"style\" => \"dotted\", \"color\" => \"FF000FF0\"],\n                                             right    = [\"style\" => \"medium\", \"color\" => \"FF765000\"],\n                                             top      = [\"style\" => \"thick\",  \"color\" => \"FF230000\"],\n                                             bottom   = [\"style\" => \"medium\", \"color\" => \"FF0000FF\"],\n                                             diagonal = [\"style\" => \"none\"]\n                                             )\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setOutsideBorder","page":"API Reference","title":"XLSX.setOutsideBorder","text":"setOutsideBorder(sh::Worksheet, cr::String; kw...) -> ::Int\nsetOutsideBorder(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the border around the outside of a cell range, a column range or a named  range in a worksheet or XLSXfile.\n\nTwo key words can be defined:\n\nstyle::String = nothing   : defines the style of the outside border\ncolor::String = nothing   : defines the color of the outside border\n\nOnly the border definitions for the sides of boundary cells that are on the  ouside edge of the range will be set to the specified style and color. The  borders of internal edges and any diagonal will remain unchanged. Border  settings for all internal cells in the range will remain unchanged.\n\nThe value returned is is -1.\n\nFor keyword definitions see setBorder().\n\nExamples:\n\nJulia> setOutsideBorder(sh, \"B2:D6\"; style = \"thick\")\n\nJulia> setOutsideBorder(xf, \"Sheet1!A1:F20\"; style = \"dotted\", color = \"FF000FF0\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setFill","page":"API Reference","title":"XLSX.setFill","text":"setFill(sh::Worksheet, cr::String; kw...) -> ::Int}\nsetFill(xf::XLSXFile,  cr::String; kw...) -> ::Int\n\nSet the fill used used by a single cell, a cell range, a column range or  a named cell or named range in a worksheet or XLSXfile.\n\nThe following keywords are used to define a fill:\n\npattern::String = nothing   : Sets the patternType for the fill.\nfgColor::String = nothing   : Sets the foreground color for the fill.\nbgColor::String = nothing   : Sets the background color for the fill.\n\nHere is a list of the available pattern values (thanks to Copilot!):\n\nnone\nsolid\nmediumGray\ndarkGray\nlightGray\ndarkHorizontal\ndarkVertical\ndarkDown\ndarkUp\ndarkGrid\ndarkTrellis\nlightHorizontal\nlightVertical\nlightDown\nlightUp\nlightGrid\nlightTrellis\ngray125\ngray0625\n\nThe two colors are set by specifying an 8-digit hexadecimal value for the fgColor and/or bgColor keywords. No other color attributes can be applied.\n\nSetting only one or two of the attributes leaves the other attribute(s) unchanged  for that cell's fill.\n\nFill attributes cannot be set for EmptyCells. Set a cell value first. If a cell range or column range includes any EmptyCells, they will be quietly skipped and the fill will be set for the remaining cells.\n\nFor single cells, the value returned is the fillId of the fill applied to the cell. This can be used to apply the same fill to other cells or ranges.\n\nFor cell ranges, column ranges and named ranges, the value returned is -1.\n\nExamples:\n\nJulia> setFill(sh, \"B2\"; pattern=\"gray125\", bgColor = \"FF000000\")\n\nJulia> setFill(xf, \"Sheet1!A1:F20\"; pattern=\"none\", fgColor = \"88FF8800\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setUniformFill","page":"API Reference","title":"XLSX.setUniformFill","text":"setUniformFill(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformFill(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the fill used by a cell range, a column range or a named range in a  worksheet or XLSXfile to be uniformly the same fill.\n\nFirst, the fill attributes of the first cell in the range (the top-left cell) are updated according to the given kw... (using setFill()). The resultant fill is  then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform fill setting.\n\nThis differs from setFill() which merges the attributes defined by kw... into  the fill definition used by each cell individually. For example, if you set the  fill patern to darkGrid for a range of cells, but these cells all use different fill   colors, setFill() will change the fill pattern but leave the fill color unchanged  for each cell individually. \n\nIn contrast, setUniformFill() will set the fill pattern to darkGrid for the first cell, but will then apply all the fill attributes from the updated first cell (ie. pattern  and both foreground and background colors) to all the other cells in the range.\n\nThis can be more efficient when setting the same fill for a large number of cells.\n\nThe value returned is the fillId of the fill uniformly applied to the cells. If all cells in the range are EmptyCells the returned value is -1.\n\nFor keyword definitions see setFill().\n\nExamples:\n\nJulia> setUniformFill(sh, \"B2:D4\"; pattern=\"gray125\", bgColor = \"FF000000\")\n\nJulia> setUniformFill(xf, \"Sheet1!A1:F20\"; pattern=\"none\", fgColor = \"88FF8800\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setAlignment","page":"API Reference","title":"XLSX.setAlignment","text":"setAlignment(sh::Worksheet, cr::String; kw...) -> ::Int}\nsetAlignment(xf::XLSXFile,  cr::String; kw...) -> ::Int}\n\nSet the alignment used used by a single cell, a cell range, a column range or  a named cell or named range in a worksheet or XLSXfile.\n\nThe following keywords are used to define an alignment:\n\nhorizontal::String = nothing : Sets the horizontal alignment.\nvertical::String = nothing   : Sets the vertical alignment.\nwrapText::Bool = nothing     : Determines whether the cell content wraps within the cell.\nshrink::Bool = nothing       : Indicates whether the text should shrink to fit the cell.\nindent::Int = nothing        : Specifies the number of spaces by which to indent the text                                   (always from the left).\nrotation::Int = nothing      : Specifies the rotation angle of the text in the range -90 to 90                                   (positive values rotate the text counterclockwise), \n\nHere are the possible values for the horizontal alignment:\n\nleft             : Aligns the text to the left of the cell.\ncenter           : Centers the text within the cell.\nright            : Aligns the text to the right of the cell.\nfill             : Repeats the text to fill the entire width of the cell.\njustify          : Justifies the text, spacing it out so that it spans the entire                       width of the cell.\ncenterContinuous : Centers the text across multiple cells (specifically the currrent                       cell and all empty cells to the right) as if the text were in                       a merged cell.\ndistributed      : Distributes the text evenly across the width of the cell.\n\nHere are the possible values for the vertical alignment:\n\ntop              : Aligns the text to the top of the cell.\ncenter           : Centers the text vertically within the cell.\nbottom           : Aligns the text to the bottom of the cell.\njustify          : Justifies the text vertically, spreading it out evenly within the cell.\ndistributed      : Distributes the text evenly from top to bottom in the cell.\n\nFor single cells, the value returned is the styleId of the cell.\n\nFor cell ranges, column ranges and named ranges, the value returned is -1.\n\nExamples:\n\njulia> setAlignment(sh, \"D18\"; horizontal=\"center\", wrapText=true)\n\njulia> setAlignment(xf, \"sheet1!D18\"; horizontal=\"right\", vertical=\"top\", wrapText=true)\n\njulia> setAlignment(sh, \"L6\"; horizontal=\"center\", rotation=\"90\", shrink=true, indent=\"2\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setUniformAlignment","page":"API Reference","title":"XLSX.setUniformAlignment","text":"setUniformAlignment(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformAlignment(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the alignment used by a cell range, a column range or a named range in a  worksheet or XLSXfile to be uniformly the same alignment.\n\nFirst, the alignment attributes of the first cell in the range (the top-left cell) are updated according to the given kw... (using setAlignment()). The resultant alignment  is then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform alignment setting.\n\nThis differs from setAlignment() which merges the attributes defined by kw... into  the alignment definition used by each cell individually. For example, if you set the  horizontal alignment to left for a range of cells, but these cells all use different  vertical alignment or wrapText, setAlignment() will change the horizontal alignment but  leave the vertical alignment and wrapText unchanged for each cell individually. \n\nIn contrast, setUniformAlignment() will set the horizontal alignment to left for   the first cell, but will then apply all the alignment attributes from the updated first   cell to all the other cells in the range.\n\nThis can be more efficient when setting the same alignment for a large number of cells.\n\nThe value returned is the styleId of the reference (top-left) cell, from which the  alignment uniformly applied to the cells was taken. If all cells in the range are EmptyCells, the returned value is -1.\n\nFor keyword definitions see setAlignment().\n\nExamples:\n\nJulia> setUniformAlignment(sh, \"B2:D4\"; horizontal=\"center\", wrap = true)\n\nJulia> setUniformAlignment(xf, \"Sheet1!A1:F20\"; horizontal=\"center\", vertical=\"top\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setUniformStyle","page":"API Reference","title":"XLSX.setUniformStyle","text":"setUniformStyle(sh::Worksheet, cr::String) -> ::Int\nsetUniformStyle(xf::XLSXFile,  cr::String) -> ::Int\n\nSet the cell style used by a cell range, a column range or a named range in a  worksheet or XLSXfile to be the same as that of the first cell in the range  that is not an EmptyCell.\n\nAs a result, every cell in the range will have a uniform style.\n\nA cell style consists of the collection of format, alignment, border,  font and fill.\n\nIf the first cell has no defined style (s=\"\"), all cells will be given the  same undefined style.\n\nThe value returned is the styleId of the style uniformly applied to the cells or  nothing if the style is undefined. If all cells in the range are EmptyCells, the returned value is -1.\n\nExamples:\n\njulia> XLSX.setUniformStyle(xf, \"Sheet1!A2:L6\")\n\njulia> XLSX.setUniformStyle(sh, \"F1:F5\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setColumnWidth","page":"API Reference","title":"XLSX.setColumnWidth","text":"setColumnWidth(sh::Worksheet, cr::String; kw...) -> ::Int\nsetColumnWidth(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the width of a column or column range.\n\nA standard cell reference or cell range can be used to define the column range.  The function will use the columns and ignore the rows. Named cells and named ranges can similarly be used.\n\nThe function uses one keyword used to define a column width:\n\nwidth::Real = nothing : Defines width in Excel's own (internal) units\n\nWhen you set a column widths interactively in Excel you can see the width  in \"internal\" units and in pixels. The width stored in the xlsx file is slightly  larger than the width shown intertactively because Excel adds some cell padding.  The method Excel uses to calculate the padding is obscure and complex. This  function does not attempt to replicate it, but simply adds 0.71 internal units  to the value specified. The value set is unlikely to match the value seen  interactivley in the resultant spreadsheet, but will be close.\n\nYou can set a column width to 0.\n\nThe function returns a value of 0.\n\nNOTE: Unlike the other set and get XLSX functions, working with ColumnWidth requires  a file to be open for writing as well as reading (mode=\"rw\" or open as a template)\n\nExamples:\n\njulia> XLSX.setColumnWidth(xf, \"Sheet1!A2\"; width = 50)\n\njulia> XLSX.seColumnWidth(sh, \"F1:F5\"; width = 0)\n\njulia> XLSX.setColumnWidth(sh, \"I\"; width = 24.37)\n \n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.setRowHeight","page":"API Reference","title":"XLSX.setRowHeight","text":"setRowHeight(sh::Worksheet, cr::String; kw...) -> ::Int\nsetRowHeight(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nSet the height of a row or row range.\n\nA standard cell reference or cell range must be used to define the row range.  The function will use the rows and ignore the columns. Named cells and named ranges can similarly be used.\n\nThe function uses one keyword used to define a row height:\n\nheight::Real = nothing : Defines height in Excel's own (internal) units.\n\nWhen you set row heights interactively in Excel you can see the height  in \"internal\" units and in pixels. The height stored in the xlsx file is slightly  larger than the height shown interactively because Excel adds some cell padding.  The method Excel uses to calculate the padding is obscure and complex. This  function does not attempt to replicate it, but simply adds 0.21 internal units  to the value specified. The value set is unlikely to match the value seen  interactivley in the resultant spreadsheet, but it will be close.\n\nYou can set a row height to 0.\n\nThe function returns a value of 0.\n\nExamples:\n\njulia> XLSX.setRowHeight(xf, \"Sheet1!A2\"; height = 50)\n\njulia> XLSX.setRowHeight(sh, \"F1:F5\"; heighth = 0)\n\njulia> XLSX.setRowHeight(sh, \"I\"; height = 24.56)\n\n\n\n\n\n","category":"function"},{"location":"#XLSX.jl","page":"Home","title":"XLSX.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XLSX.jl is a Julia package to read and write Excel spreadsheet files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Internally, an Excel XLSX file is just a Zip file with a set of XML files inside. The formats for these XML files are described in the Standard ECMA-376.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package follows the EMCA-376 to parse and generate XLSX files.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia v1.6\nLinux, macOS or Windows.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From a Julia session, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"XLSX\")","category":"page"},{"location":"#Source-Code","page":"Home","title":"Source Code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code for this package is hosted at https://github.com/felipenoris/XLSX.jl.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code for the package XLSX.jl is licensed under the MIT License.","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you're having any trouble, have any questions about this package or want to ask for a new feature, just open a new issue.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are always welcome!","category":"page"},{"location":"","page":"Home","title":"Home","text":"To contribute, fork the project on GitHub and send a Pull Request.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ECMA Open XML White Paper\nECMA-376\nExcel file limits","category":"page"},{"location":"#Alternative-Packages","page":"Home","title":"Alternative Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExcelFiles.jl\nExcelReaders.jl\nXLSXReader.jl\nTaro.jl","category":"page"},{"location":"migration/#Migration-Guides","page":"Migration Guides","title":"Migration Guides","text":"","category":"section"},{"location":"migration/#Migrating-Legacy-Code-to-v0.8","page":"Migration Guides","title":"Migrating Legacy Code to v0.8","text":"","category":"section"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"Version v0.8 introduced a breaking change on methods XLSX.gettable and XLSX.readtable.","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"These methods used to return a tuple data, column_labels. On XLSX v0.8 these methods return a XLSX.DataTable struct that implements Tables.jl interface.","category":"page"},{"location":"migration/#Basic-code-replacement","page":"Migration Guides","title":"Basic code replacement","text":"","category":"section"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"Before","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"data, col_names = XLSX.readtable(joinpath(data_directory, \"general.xlsx\"), \"table4\")","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"After","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"dtable = XLSX.readtable(joinpath(data_directory, \"general.xlsx\"), \"table4\")\ndata, col_names = dtable.data, dtable.column_labels","category":"page"},{"location":"migration/#Reading-DataFrames","page":"Migration Guides","title":"Reading DataFrames","text":"","category":"section"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"Since XLSX.DataTable implements Tables.jl interface, the result of XLSX.gettable or XLSX.readtable can be passed to a DataFrame constructor.","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"Before","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\")...)","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"After","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\"))","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Setup","page":"Tutorial","title":"Setup","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, make sure you have XLSX.jl package installed.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Pkg\n\njulia> Pkg.add(\"XLSX\")","category":"page"},{"location":"tutorial/#Getting-Started","page":"Tutorial","title":"Getting Started","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The basic usage is to read an Excel file and read values.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import XLSX\n\njulia> xf = XLSX.readxlsx(\"myfile.xlsx\")\nXLSXFile(\"myfile.xlsx\") containing 3 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              mysheet 4x2           A1:B4\n           othersheet 1x1           A1:A1\n                named 1x1           B4:B4\n\njulia> XLSX.sheetnames(xf)\n3-element Array{String,1}:\n \"mysheet\"\n \"othersheet\"\n \"named\"\n\njulia> sh = xf[\"mysheet\"] # get a reference to a Worksheet\n4×2 XLSX.Worksheet: [\"mysheet\"](A1:B4)\n\njulia> sh[2, 2] # access element \"B2\" (2nd row, 2nd column)\n\"first\"\n\njulia> sh[\"B2\"] # you can also use the cell name\n\"first\"\n\njulia> sh[\"A2:B4\"] # or a cell range\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet\", \"A2:B4\") # shorthand for all above\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> sh[:] # all data inside worksheet's dimension\n4×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n 3           \"third\"\n\njulia> xf[\"mysheet!A2:B4\"] # you can also query values using a sheet reference\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> xf[\"NAMED_CELL\"] # you can even read named ranges\n\"B4 is a named cell from sheet \\\"named\\\"\"\n\njulia> xf[\"mysheet!A:B\"] # Column ranges are also supported\n4×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n 3           \"third\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To inspect the internal representation of each cell, use the getcell or getcellrange methods.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The example above used xf = XLSX.readxlsx(filename) to open a file, so all file contents are fetched at once from disk.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use XLSX.openxlsx to read file contents as needed (see Reading Large Excel Files and Caching).","category":"page"},{"location":"tutorial/#Data-Types","page":"Tutorial","title":"Data Types","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package uses the following concrete types when handling XLSX files.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"XLSX.CellValueType","category":"page"},{"location":"tutorial/#XLSX.CellValueType","page":"Tutorial","title":"XLSX.CellValueType","text":"CellValueType\n\nConcrete supported data-types.\n\nUnion{String, Missing, Float64, Int, Bool, Dates.Date, Dates.Time, Dates.DateTime}\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Abstract types of these concrete types are converted to the appropriate concrete type when writing.\nNothing values are converted to Missing when writing.","category":"page"},{"location":"tutorial/#Read-Tabular-Data","page":"Tutorial","title":"Read Tabular Data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The XLSX.gettable method returns tabular data from a spreadsheet as a struct XLSX.DataTable that implements Tables.jl interface. You can use it to create a DataFrame from DataFrames.jl. Check the docstring for gettable method for more advanced options.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There's also a helper method XLSX.readtable to read from file directly, as shown in the following example.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using DataFrames, XLSX\n\njulia> df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\"))\n3×2 DataFrames.DataFrame\n│ Row │ HeaderA │ HeaderB  │\n├─────┼─────────┼──────────┤\n│ 1   │ 1       │ \"first\"  │\n│ 2   │ 2       │ \"second\" │\n│ 3   │ 3       │ \"third\"  │","category":"page"},{"location":"tutorial/#Reading-Cells-as-a-Julia-Matrix","page":"Tutorial","title":"Reading Cells as a Julia Matrix","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use XLSX.readdata or XLSX.getdata to read content as a Julia matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import XLSX\n\njulia> m = XLSX.readdata(\"myfile.xlsx\", \"mysheet!A1:B3\")\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Indexing in a Worksheet will dispatch to XLSX.getdata method.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> xf = XLSX.readxlsx(\"myfile.xlsx\")\nXLSXFile(\"myfile.xlsx\") containing 3 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              mysheet 4x2           A1:B4\n           othersheet 1x1           A1:A1\n                named 1x1           B4:B4\n\njulia> xf[\"mysheet!A1:B3\"]\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n\njulia> sheet = xf[\"mysheet\"]\n4×2 XLSX.Worksheet: [\"mysheet\"](A1:B4)\n\njulia> sheet[\"A1:B3\"]\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But indexing in a single cell will return a single value instead of a matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> sheet[\"A1\"]\n\"HeaderA\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you don't know the desired range in advance, you can take advantage of the XLSX.readtable and XLSX.gettable methods.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> dtable = XLSX.readtable(\"myfile.xlsx\", \"mysheet\")\nXLSX.DataTable(Any[Any[1, 2, 3], Any[\"first\", \"second\", \"third\"]], [:HeaderA, :HeaderB], Dict(:HeaderB => 2, :HeaderA => 1))\n\njulia> m = hcat(dtable.data...)\n3×2 Matrix{Any}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"","category":"page"},{"location":"tutorial/#Reading-Large-Excel-Files-and-Caching","page":"Tutorial","title":"Reading Large Excel Files and Caching","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method XLSX.openxlsx has a enable_cache option to control worksheet cells caching.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Cache is enabled by default, so if you read a worksheet cell twice it will use the cached value instead of reading from disk in the second time.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If enable_cache=false, worksheet cells will always be read from disk. This is useful when you want to read a spreadsheet that doesn't fit into memory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following example shows how you would read worksheet cells, one row at a time, where myfile.xlsx is a spreadsheet that doesn't fit into memory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do f\n           sheet = f[\"mysheet\"]\n           for r in XLSX.eachrow(sheet)\n              # r is a `SheetRow`, values are read using column references\n              rn = XLSX.row_number(r) # `SheetRow` row number\n              v1 = r[1]    # will read value at column 1\n              v2 = r[\"B\"]  # will read value at column 2\n\n              println(\"v1=$v1, v2=$v2\")\n           end\n      end\nv1=HeaderA, v2=HeaderB\nv1=1, v2=first\nv1=2, v2=second\nv1=3, v2=third","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You could also stream tabular data using XLSX.eachtablerow(sheet), which is the underlying iterator in gettable method. Check docstrings for XLSX.eachtablerow for more advanced options.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do f\n           sheet = f[\"mysheet\"]\n           for r in XLSX.eachtablerow(sheet)\n               # r is a `TableRow`, values are read using column labels or numbers\n               rn = XLSX.row_number(r) # `TableRow` row number\n               v1 = r[1] # will read value at table column 1\n               v2 = r[:HeaderB] # will read value at column labeled `:HeaderB`\n\n               println(\"v1=$v1, v2=$v2\")\n            end\n       end\nv1=1, v2=first\nv1=2, v2=second\nv1=3, v2=third","category":"page"},{"location":"tutorial/#Writing-Excel-Files","page":"Tutorial","title":"Writing Excel Files","text":"","category":"section"},{"location":"tutorial/#Create-New-Files","page":"Tutorial","title":"Create New Files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Opening a file in write mode with XLSX.openxlsx will open a new (blank) Excel file for editing.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"XLSX.openxlsx(\"my_new_file.xlsx\", mode=\"w\") do xf\n    sheet = xf[1]\n    XLSX.rename!(sheet, \"new_sheet\")\n    sheet[\"A1\"] = \"this\"\n    sheet[\"A2\"] = \"is a\"\n    sheet[\"A3\"] = \"new file\"\n    sheet[\"A4\"] = 100\n\n    # will add a row from \"A5\" to \"E5\"\n    sheet[\"A5\"] = collect(1:5) # equivalent to `sheet[\"A5\", dim=2] = collect(1:4)`\n\n    # will add a column from \"B1\" to \"B4\"\n    sheet[\"B1\", dim=1] = collect(1:4)\n\n    # will add a matrix from \"A7\" to \"C9\"\n    sheet[\"A7:C9\"] = [ 1 2 3 ; 4 5 6 ; 7 8 9 ]\nend","category":"page"},{"location":"tutorial/#Edit-Existing-Files","page":"Tutorial","title":"Edit Existing Files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Opening a file in read-write mode with XLSX.openxlsx will open an existing Excel file for editing. This will preserve existing data in the original file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"XLSX.openxlsx(\"my_new_file.xlsx\", mode=\"rw\") do xf\n    sheet = xf[1]\n    sheet[\"B1\"] = \"new data\"\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nThe read-write mode is known to produce some data loss. See #159.Simple data should work fine. Users are advised to use this feature with caution when working with formulas and charts.","category":"page"},{"location":"tutorial/#Export-Tabular-Data-from-a-Worksheet","page":"Tutorial","title":"Export Tabular Data from a Worksheet","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given a sheet reference, use the XLSX.writetable! method. Anchor cell defaults to cell \"A1\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using XLSX, Test\n\nfilename = \"myfile.xlsx\"\n\ncolumns = Vector()\npush!(columns, [1, 2, 3])\npush!(columns, [\"a\", \"b\", \"c\"])\n\nlabels = [ \"column_1\", \"column_2\"]\n\nXLSX.openxlsx(filename, mode=\"w\") do xf\n    sheet = xf[1]\n    XLSX.writetable!(sheet, columns, labels, anchor_cell=XLSX.CellRef(\"B2\"))\nend\n\n# read data back\nXLSX.openxlsx(filename) do xf\n    sheet = xf[1]\n    @test sheet[\"B2\"] == \"column_1\"\n    @test sheet[\"C2\"] == \"column_2\"\n    @test sheet[\"B3\"] == 1\n    @test sheet[\"B4\"] == 2\n    @test sheet[\"B5\"] == 3\n    @test sheet[\"C3\"] == \"a\"\n    @test sheet[\"C4\"] == \"b\"\n    @test sheet[\"C5\"] == \"c\"\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use XLSX.writetable to write directly to a new file (see next section).","category":"page"},{"location":"tutorial/#Export-Tabular-Data-from-any-Tables.jl-compatible-source","page":"Tutorial","title":"Export Tabular Data from any Tables.jl compatible source","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To export tabular data to Excel, use XLSX.writetable method, which accepts either columns and column names, or any Tables.jl table.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Dates\n\njulia> import DataFrames, XLSX\n\njulia> df = DataFrames.DataFrame(integers=[1, 2, 3, 4], strings=[\"Hey\", \"You\", \"Out\", \"There\"], floats=[10.2, 20.3, 30.4, 40.5], dates=[Date(2018,2,20), Date(2018,2,21), Date(2018,2,22), Date(2018,2,23)], times=[Dates.Time(19,10), Dates.Time(19,20), Dates.Time(19,30), Dates.Time(19,40)], datetimes=[Dates.DateTime(2018,5,20,19,10), Dates.DateTime(2018,5,20,19,20), Dates.DateTime(2018,5,20,19,30), Dates.DateTime(2018,5,20,19,40)])\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats │ dates      │ times    │ datetimes           │\n├─────┼──────────┼─────────┼────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2   │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3   │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4   │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5   │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │\n\njulia> XLSX.writetable(\"df.xlsx\", df)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also export multiple tables to Excel, each table in a separate worksheet, by either passing a tuple (columns, names) to a keyword argument for each sheet name, or a list \"sheet name\" => table pairs for any Tables.jl compatible source.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import DataFrames, XLSX\n\njulia> df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[\"Fist\", \"Sec\", \"Third\"])\n3×2 DataFrames.DataFrame\n│ Row │ COL1 │ COL2  │\n├─────┼──────┼───────┤\n│ 1   │ 10   │ Fist  │\n│ 2   │ 20   │ Sec   │\n│ 3   │ 30   │ Third │\n\njulia> df2 = DataFrames.DataFrame(AA=[\"aa\", \"bb\"], AB=[10.1, 10.2])\n2×2 DataFrames.DataFrame\n│ Row │ AA │ AB   │\n├─────┼────┼──────┤\n│ 1   │ aa │ 10.1 │\n│ 2   │ bb │ 10.2 │\n\njulia> XLSX.writetable(\"report.xlsx\", \"REPORT_A\" => df1, \"REPORT_B\" => df2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This last example shows how to do the same thing, but when you don't know how many tables you'll be exporting in advance.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df1 = DataFrame(A=[1,2], B=[3,4])\ndf2 = DataFrame(C=[\"Hey\", \"you\"], D=[\"out\", \"there\"])\n\nsheet_names = [ \"1st\", \"2nd\" ]\ndataframes = [ df1, df2 ]\n\n@assert length(sheet_names) == length(dataframes)\n\nXLSX.openxlsx(\"report.xlsx\", mode=\"w\") do xf\n    for i in eachindex(sheet_names)\n        sheet_name = sheet_names[i]\n        df = dataframes[i]\n        \n        if i == firstindex(sheet_names)\n            sheet = xf[1]\n            XLSX.rename!(sheet, sheet_name)\n            XLSX.writetable!(sheet, df)\n        else\n            sheet = XLSX.addsheet!(xf, sheet_name)\n            XLSX.writetable!(sheet, df)        \n        end\n    end\nend","category":"page"},{"location":"tutorial/#Tables.jl-interface","page":"Tutorial","title":"Tables.jl interface","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Both types XLSX.DataTable and XLSX.TableRowIterator conforms to Tables.jl interface. An instance of XLSX.TableRowIterator is created by the function XLSX.eachtablerow.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Also, XLSX.writetable accepts an argument that conforms to the Tables.jl interface.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As an example, the type DataFrame from DataFrames package supports the Tables.jl interface. The following code writes and reads back a DataFrame to an Excel file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Dates\n\njulia> import DataFrames, XLSX\n\njulia> df = DataFrames.DataFrame(integers=[1, 2, 3, 4], strings=[\"Hey\", \"You\", \"Out\", \"There\"], floats=[10.2, 20.3, 30.4, 40.5], dates=[Date(2018,2,20), Date(2018,2,21), Date(2018,2,22), Date(2018,2,23)], times=[Dates.Time(19,10), Dates.Time(19,20), Dates.Time(19,30), Dates.Time(19,40)], datetimes=[Dates.DateTime(2018,5,20,19,10), Dates.DateTime(2018,5,20,19,20), Dates.DateTime(2018,5,20,19,30), Dates.DateTime(2018,5,20,19,40)])\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats  │ dates      │ times    │ datetimes           │\n│     │ Int64    │ String  │ Float64 │ Date       │ Time     │ DateTime            │\n├─────┼──────────┼─────────┼─────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2    │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3    │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4    │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5    │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │\n\njulia> XLSX.writetable(\"output_table.xlsx\", df, overwrite=true, sheetname=\"report\", anchor_cell=\"B2\")\n\njulia> f = XLSX.readxlsx(\"output_table.xlsx\")\nXLSXFile(\"output_table.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               report 6x7           A1:G6\n\n\njulia> s = f[\"report\"]\n6×7 XLSX.Worksheet: [\"report\"](A1:G6)\n\njulia> df2 = XLSX.eachtablerow(s) |> DataFrames.DataFrame\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats  │ dates      │ times    │ datetimes           │\n│     │ Int64    │ String  │ Float64 │ Date       │ Time     │ DateTime            │\n├─────┼──────────┼─────────┼─────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2    │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3    │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4    │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5    │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │","category":"page"}]
}
