var documenterSearchIndex = {"docs":
[{"location":"formatting/conditionalFormatting/#Conditional-formats","page":"Conditional formats","title":"Conditional formats","text":"","category":"section"},{"location":"formatting/conditionalFormatting/#Applying-conditional-formats","page":"Conditional formats","title":"Applying conditional formats","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"In Excel, a conditional format is a format that is applied if the content of a cell meets some criterion  but not otherwise. Such conditional formatting is generally straightforward to apply using the  setAttribute() functions or the setConditionalFormat() function described here.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"note: Note\nIn Excel, conditional formats are dynamic. If the cell values change, the formats are updated based  on application of the condition to the new values.The examples of conditional formatting given here a mix of static and dynamic formats.Static conditional formats apply formatting based on the current cell values at the time the format  is set, but the formats are then static regardless of updates to cell values. They can be updated  by re-running the conditional formatting functions described but otherwise remain unchanged. Static  formats are created by applying the setAttribute() functions described above.Dynamic conditional formatting, using the native Excel conditional format functionality, is possible  using the setConditionalFormat() function, giving access to all of Excel's options. ","category":"page"},{"location":"formatting/conditionalFormatting/#Static-conditional-formats","page":"Conditional formats","title":"Static conditional formats","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"As an example, a simple function to set true values in a range to use a bold green font color and  false values to use a bold red color a could be defined as follows:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"function trueorfalse(sheet, rng) # Use green or red font for true or false respectively\n    for c in rng\n        if !ismissing(sheet[c]) && sheet[c] isa Bool\n            XLSX.setFont(sheet, c, bold=true, color = sheet[c] ? \"FF548235\" : \"FFC00000\")\n        end\n    end\nend","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Applying this function over any range will conditionally color cells green or red if they are  true or false respectively:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"trueorfalse(sheet, XLSX.CellRange(\"E3:L6\"))","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Similarly, a function can be defined that fills any cells containing missing values with a grey  color and have diagonal borders applied:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"function blankmissing(sheet, rng) # Fill with grey and apply both diagonal borders on cells\n    for c in rng                  # with missing values\n        if ismissing(sheet[c])\n            XLSX.setFill(sheet, c; pattern = \"solid\", fgColor = \"lightgrey\")\n            XLSX.setBorder(sheet, c; diagonal = [\"style\" => \"thin\", \"color\" => \"black\"])\n           end\n    end\nend","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"This can then be applied to a range of cells to conditionally apply the format:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"blankmissing(sheet, XLSX.CellRange(\"B3:L6\"))","category":"page"},{"location":"formatting/conditionalFormatting/#Dynamic-conditional-formats","page":"Conditional formats","title":"Dynamic conditional formats","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"XLSX.jl provides a function to create native Excel conditional formats that will be saved  as part of an XLSXFile and which will update dynamically if the values in the cell range  to which the formatting is applied are subsequently updated.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"XLSX.setConditionalFormat(sheet, CellRange, :type; kwargs...)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Excel uses a range of :type values to describe these conditional formats and the same values  are used here, as follows:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":":cellIs\n:top10\n:aboveAverage\n:containsText\n:notContainsText\n:beginsWith\n:endsWith\n:timePeriod\n:containsErrors\n:notContainsErrors\n:containsBlanks\n:notContainsBlanks\n:uniqueValues\n:duplicateValues\n:expression\n:dataBar\n:colorScale\n:iconSet","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Use of these different :types is illustrated in the following sections. For more details on the range of :type values and their associated keyword  options, refer to XLSX.setConditionalFormat().","category":"page"},{"location":"formatting/conditionalFormatting/#Cell-Value","page":"Conditional formats","title":"Cell Value","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"It is possible to format each cell in a range when the cell's value meets a specified condition using one  of a number of built-in cell format options or using custom formatting. This group of formatting options  represents the greatest range of conditional formatting options available in Excel and are probably the most  often used. All the functions of Highlight Cells Rules and Top/Bottom Rules are provided.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500) (Image: image|100x500) (Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The following :type values are used to set conditional formats by making direct comparisons to a cell's value:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":":cellIs\n:top10\n:aboveAverage\n:containsText\n:notContainsText\n:beginsWith\n:endsWith\n:timePeriod\n:containsErrors\n:notContainsErrors\n:containsBlanks\n:notContainsBlanks\n:uniqueValues\n:duplicateValues","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Each of these formatting types needs a set of keyword options to fully define its operation.  This can be exemplified by considering the :cellIs type. Like the other conditional formats  in this group, :cellIs needs an operator keyword to define the test to use to determine  whether or not to apply the formatting. Valid operator values for :cellIs are:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"greaterThan     (cell >  value)\ngreaterEqual    (cell >= value)\nlessThan        (cell <  value)\nlessEqual       (cell <= value)\nequal           (cell == value)\nnotEqual        (cell != value)\nbetween         (cell between value and value2)\nnotBetween      (cell not between value and value2)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Each of these need the keyword value to be specified and, for between and notBetween, value2  must also be specified.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Like all the cell value formatting types, :cellIs can use one of six built-in Excel formats, as  illustrated here for the greaterThan comparison.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"These six built-in formatting options are available by name in XLSX.jl by specifying the dxStyle  keyword with one of the following values:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"redfilltext\nyellowfilltext\ngreenfilltext\nredfill \nredtext\nredborder","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Thus, for example, to create a simple XLSXFile from scratch and then apply some  :cellIs conditional formats to its cells:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> columns = [ [1, 2, 3, 4], [\"Hey\", \"You\", \"Out\", \"There\"], [10.2, 20.3, 30.4, 40.5] ]\n3-element Vector{Vector}:\n [1, 2, 3, 4]\n [\"Hey\", \"You\", \"Out\", \"There\"]\n [10.2, 20.3, 30.4, 40.5]\n\njulia> colnames = [ \"integers\", \"strings\", \"floats\" ]\n3-element Vector{String}:\n \"integers\"\n \"strings\"\n \"floats\"\n\njulia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range        \n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1) \n\njulia> XLSX.writetable!(s, columns, colnames)\n\njulia> s[1:5, 1:3]\n5×3 Matrix{Any}:\n  \"integers\"  \"strings\"    \"floats\"\n 1            \"Hey\"      10.2\n 2            \"You\"      20.3\n 3            \"Out\"      30.4\n 4            \"There\"    40.5\n\njulia> XLSX.setConditionalFormat(s, \"A2:A5\", :cellIs;       # Cells with a value > 2 to have red text and light red fill.\n                    operator=\"greaterThan\",\n                    value=\"2\",\n                    dxStyle=\"redfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"B2:B5\", :containsText; # Cells with text containing \"u\" to have green text and light green fill.\n                    value=\"u\",\n                    dxStyle=\"greenfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"C2:C5\", :top10;        # Cells with values in the top 10% of values in the range to have a red border.\n                    operator =\"topN%\",\n                    value=\"10\"\n                    dxStyle=\"redborder\")\n0\n","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Alternatively, it is possible to specify custom format options to match the options offered in Excel  under the Custom Format... option:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"note: Note\nIn the image above, the font name and size selectors are greyed out.  Excel limits  the formatting attributes that can be set in a conditional format. It is not  possible to set the size or name of a font and neither is it possible to set any  of the cell alignment attributes. Diagonal borders cannot be set either.Although it is not a limitation of Excel, for simplicity this function sets all the  border attributes for each side of a cell to be the same.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"For example, starting with the same simple XLSXFile as above, we can apply the following custom formats:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> XLSX.setConditionalFormat(s, \"A2:A5\", :cellIs;\n                   operator=\"greaterThan\",\n                   value=\"2\",\n                   font=[\"color\" => \"coral\", \"bold\"=>\"true\"],\n                   fill=[\"pattern\"=>\"solid\", \"bgColor\"=>\"cornsilk\"],\n                   border=[\"style\"=>\"dashed\", \"color\"=>\"orangered4\"],\n                   format=[\"format\"=>\"0.000\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"B2:B5\", :containsText;\n                    value=\"u\",\n                    font=[\"color\" => \"steelblue4\", \"italic\"=>\"true\"],\n                    fill=[\"pattern\"=>\"darkTrellis\", \"fgColor\"=>\"lawngreen\", \"bgColor\"=>\"cornsilk\"],\n                    border=[\"style\"=>\"double\", \"color\"=>\"magenta3\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"C2:C5\", :top10;\n                    operator =\"topN%\",\n                    value=\"10\",\n                    font=[\"color\" => \"magenta3\", \"strike\"=>\"true\"],\n                    fill=[\"pattern\"=>\"lightVertical\", \"fgColor\"=>\"lawngreen\", \"bgColor\"=>\"cornsilk\"],\n                    border=[\"style\"=>\"double\", \"color\"=>\"cyan\"])\n0\n\njulia> XLSX.getConditionalFormats(s)\n3-element Vector{Pair{XLSX.CellRange, NamedTuple}}:\n C2:C5 => (type = \"top10\", priority = 3)\n B2:B5 => (type = \"containsText\", priority = 2)\n A2:A5 => (type = \"cellIs\", priority = 1)\n","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Each of the conditional format types in the cell value group take similar keyword options but  the specific details vary for each. For more details, refer to XLSX.setConditionalFormat().","category":"page"},{"location":"formatting/conditionalFormatting/#Expressions","page":"Conditional formats","title":"Expressions","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"It is possible to use an Excel formula directly to determine whether to apply a conditional format.  Any expression that evaluates to true or false can be used.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"For example, to compare one column with another and apply a conditional format accordingly:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range        \n-------------------------------------------------\n               Sheet1 1x1           A1:A1        \n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1) \n\njulia> XLSX.writetable!(s, [rand(10), rand(10), rand(10), rand(10)], [\"col1\", \"col2\", \"col3\", \"col4\"])\n\njulia> s[:]\n11×4 Matrix{Any}:\n  \"col1\"     \"col2\"     \"col3\"     \"col4\"\n 0.810579   0.13742    0.0146856  0.654739\n 0.169043   0.623955   0.713874   0.103253\n 0.198619   0.19622    0.0818595  0.863316\n 0.353214   0.0949461  0.961917   0.812889\n 0.343781   0.0957323  0.061183   0.822921\n 0.34115    0.243949   0.527914   0.758945\n 0.161748   0.744446   0.119521   0.52732\n 0.39707    0.284588   0.501409   0.374944\n 0.327938   0.191197   0.943983   0.755799\n 0.0314949  0.560541   0.526068   0.45253\n\njulia> XLSX.setConditionalFormat(s, \"A2:A10\", :expression; formula = \"A2>B2\", dxStyle = \"redfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"C2:D10\", :expression; formula = \"C2>\\$B2\", dxStyle = \"greenfilltext\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Column A uses relative referencing. Columns C and D use an absolute reference for the column but not the  row of the comparison reference.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The following example uses absolute references on rows and compares the average of each column with the  average of the preceding column.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1)\n\njulia> XLSX.writetable!(s, [rand(10).*1000, rand(10).*1000, rand(10).*1000, rand(10).*1000], [\"2022\", \"2023\", \"2024\", \"2025\"])\n\njulia> XLSX.setConditionalFormat(s, \"B2:D11\", :expression; formula = \"average(B\\$2:B\\$11) > average(A\\$2:A\\$11)\", dxStyle = \"greenfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"B2:D11\", :expression; formula = \"average(B\\$2:B\\$11) < average(A\\$2:A\\$11)\", dxStyle = \"redfilltext\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Row 13 above is the average of each column, calculated in Excel)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"When a formula uses relative references, the relative position (offset) of the reference to the base cell in the  range to which the condition is applied is used consistently throughout the range. This is illustrated in the following example:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1) \n\njulia> for i=1:10; for j=1:10; s[i, j] = i*j; end; end\n\njulia> XLSX.setConditionalFormat(s, \"A1:E5\", :expression; formula = \"E5 < 50\", dxStyle = \"redfilltext\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The format applied in cell A1 is determined by comparison of cell E5 to the value 50. In B2 it is  based on cell F6, in C3, on cell G7 and so on throughtout the range.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Text based comparisons in Excel are not case sensitive by default, but can be forced to be so:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1)\n\njulia> s[1:3,1:3]=\"HELLO WORLD\"\n\"HELLO WORLD\"\n\njulia> s[\"A1\"] = \"Hello World\"\n\"Hello World\"\n\njulia> s[\"B2\"] = \"Hello World\"\n\"Hello World\"\n\njulia> s[\"C3\"] = \"Hello World\"\n\"Hello World\"\n\njulia> XLSX.setConditionalFormat(s, \"A1:A3\", :expression; formula = \"A1=\\\"hello world\\\"\", dxStyle = \"redfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"B1:B3\", :expression; formula = \"B1=\\\"HELLO WORLD\\\"\", dxStyle = \"redfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"C1:C3\", :expression; formula = \"exact(\\\"Hello World\\\", C1)\", dxStyle = \"greenfilltext\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/#Data-Bar","page":"Conditional formats","title":"Data Bar","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"A :dataBar conditional format can be applied to a range of cells. In Excel there are twelve built-in data bars available, but it is possible  to customise many elements of these.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"In XLSX.jl, the twelve built-in data bars are named as follows  (layout follows image)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"   \nGradient fill bluegrad greengrad redgrad\n orangegrad lightbluegrad purplegrad\nSolid fill blue green red\n orange lightblue purple","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Choose one of these data bars by name using the databar keyword. If no databar  is specified, bluegrad is the default choice. For example","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range        \n-------------------------------------------------\n               Sheet1 1x1           A1:A1        \n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1) \n\njulia> s[1:10, 1]=1:10\n1:10\n\njulia> s[1:10, 3]=1:10\n1:10\n\njulia> XLSX.setConditionalFormat(s, \"A1:A10\", :dataBar) # Defaults to `databar=\"bluegrad\"`\n0\n\njulia> XLSX.setConditionalFormat(s, \"C1:C10\", :dataBar; databar=\"orange\")\n0\n","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"All of the options provided by Excel can be adjusted using the provided keyword options. ","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"For example, the end points of the bar scale can be defined by setting the min_type and max_type  keywords to num (for an absolute number value), percent,  percentile, formula or min or max.  The default type is automatic.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"For the first three type options, a value must also be given by setting min_val, max_val. The value may be taken from a cell by setting min_val, max_val to a cell reference. When the type is  set to formula, any valid formula yielding a value can be given. Cell references must use absolute referencing. Types min and max set the scale endpoints to be exactly the minimum and maximum values of the data in the  cell range whereas using automatic allows Excel flexibility to make minor adjustments to these endpoints,  e.g. to improve appearance.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1)\n\njulia> s[1:10, 5]=1:10\n1:10\n\njulia> s[1:10, 1]=1:10\n1:10\n\njulia> s[1:10, 3]=1:10\n1:10\n\njulia> XLSX.setConditionalFormat(s, \"A1:A10\", :dataBar)\n0\n\njulia> XLSX.setConditionalFormat(s, \"C1:C10\", :dataBar; databar=\"purple\", min_type=\"num\", max_type=\"num\", min_val=\"2\", max_val=\"8\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"E1:E10\", :dataBar; databar=\"greengrad\", min_type=\"percent\", max_type=\"percent\", min_val=\"35\", max_val=\"65\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Choose whether to hide values using showVal=\"false\", convert a gradient fill to solid (or vice versa)  with gradient=\"false\" (gradient=\"true\") and add borders to data bars with borders=\"true\".","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> XLSX.setConditionalFormat(s, \"A1:A10\", :dataBar)\n0\n\njulia> XLSX.setConditionalFormat(s, \"C1:C10\", :dataBar, showVal=\"false\", gradient=\"false\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"E1:E10\", :dataBar; databar=purple,  borders=\"true\", gradient=\"true\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Change bar colors using fill_col= and border colors using border_col=. Colors are specified using an 8-digit hexadecimal as \"FFRRGGBB\" or using any named color from Colors.jl.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"By default, negative values are shown with red bars and borders. Override these defaults by setting sameNegFill = \"true\"and sameNegBorders=\"true\" to use the same colors as positive bars. Alternatively, to use any available color, set neg_fill_col= and neg_border_col=.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> XLSX.setConditionalFormat(s, \"A1:A11\", :dataBar)\n0\n\njulia> XLSX.setConditionalFormat(s, \"C1:C11\", :dataBar; sameNegFill=\"true\", sameNegBorders=\"true\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"E1:E11\", :dataBar; fill_col=\"cyan\", border_col=\"blue\", neg_fill_col=\"lemonchiffon1\", neg_border_col=\"goldenrod4\")\n0\n","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"By default, Excel positions the axis automatically, based on the range of the cell data.  Control the location of the axis using axis_pos = \"middle\" to locate it in the middle  of the column width or axis_pos = \"none\" to remove the axis. Excel chooses the direction  of the bars according to the context of the cell data. Force (postive) bars to go leftToRight  or rightToLeft using the direction key word. Change the color of the axis with axis_col.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> s[1:10, 1]=1:10\n1:10\n\njulia> s[1:10,3]=-5:4\n-5:4\n\njulia> s[1:10,5]=1:10\n1:10\n\njulia> XLSX.setConditionalFormat(s, \"A1:A10\", :dataBar)\n0\n\njulia> XLSX.setConditionalFormat(s, \"C1:C10\", :dataBar; direction=\"rightToLeft\", axis_pos=\"middle\", axis_col=\"magenta\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"E1:E10\", :dataBar; direction=\"leftToRight\", min_type=\"num\", min_val=\"-5\", axis_pos=\"none\")\n0\n","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/#Color-Scale","page":"Conditional formats","title":"Color Scale","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"It is possible to apply a :colorScale formatting type to a range of cells. In Excel there are twelve built-in color scales available, but it is possible to create  custom color scales, too.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"In XLSX.jl, the twelve built-in scales are named by their end/mid/start colors as follows  (layout follows image)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"   \ngreenyellowred redyellowgreen greenwhitered redwhitegreen\nbluewhitered redwhiteblue whitered redwhite\ngreenwhite whitegreen greenyellow yellowgreen","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The default colorscale is greenyellow. To use a different built-in color scale,  specify the name using the keyword colorscale, thus:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"A1:F12\", :colorScale) # Defaults to the `greenyellow` built-in scale.\n0\n\njulia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"A13:C18\", :colorScale; colorscale=\"whitered\")\n0\n\njulia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"D13:F18\", :colorScale; colorscale=\"bluewhitered\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"A custom color scale may be defined by the colors at each end of the scale and (optionally) by some  mid-point color, too. Colors can be specified using hex RGB values or by name using any of the colors in Colors.jl.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"In Excel, the colorScale options (for a 3 color scale) look like this:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The end points (and optional mid-point) can be defined using an absolute number (num), a percent,  a percentile or as a min or max. For the first three options, a value must also be given. The value may be taken from a cell by setting min_val, mid_val or max_val to a cell reference. Thus, you can apply a custom 3-color scale using, for example:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"A13:F22\", :colorScale;\n            min_type=\"num\", \n            min_val=\"2\",\n            min_col=\"tomato\",\n            mid_type=\"num\",\n            mid_val=\"6\", \n            mid_col=\"lawngreen\",\n            max_type=\"num\",\n            max_val=\"10\",\n            max_col=\"cadetblue\"\n        )\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/#Icon-Set","page":"Conditional formats","title":"Icon Set","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"It is possible to apply an :iconSet formatting type to a range of cells. In Excel there are twenty built-in icon sets available, but it is possible to  create a custom icon set from the 52 built-in icons, too.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"In XLSX.jl, the twenty built-in icon sets are named as follows  (layout follows image)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"  \nDirectional 3Arrows 3ArrowsGray\n 3Triangles 4ArrowsGray\n 4Arrows 5ArrowsGray\n 5Arrows \nShapes 3TrafficLights 3TrafficLights2\n 3Signs 4TrafficLights\n 4BlackToRed \nIndicators 3Symbols 3Symbols2\n 3Flags \nRatings 3Stars 4Ratings\n 5Quarters 5Ratings\n 5Boxes ","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Choose one of these icon sets by name using the iconset keyword. If no iconset  is specified, 3TrafficLights is the default choice. For example","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range        \n-------------------------------------------------\n               Sheet1 1x1           A1:A1        \n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1) \n\njulia> s[1:10, 1]=1:10\n1:10\n\njulia> XLSX.setConditionalFormat(s, \"A1:A10\", :iconSet)\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"All of the options to control an iconSet in Excel are available. The iconSet options  (for a 4-icon set) look like this:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Each icon set includes a default set of thresholds defining which symbol to use. These  relate the cell value to the range of values in the cell range to which the conditional  format is being applied. This can be illustrated (for a 4-icon set) as follows:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":" Range     ┌─────────────────┬─────────────────┬─────────────────┬────────────────┐   Range\n Minimum ->│     Icon 1      │     Icon 2      │     Icon 3      │     Icon 4     │<- Maximum\n                         `min_val`         `mid_val`         `max_val`\n                         threshold         threshold         threshold","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The starting value for the first icon is always the minimum value of the range, and the stopping value for the last icon is always the maximum value in the range. No cells will have values for  which an icon cannot be assigned. The internal thresholds for transition from one icon to the  next are defined (in a 3-icon set) by min_val and max_val. In a 4-icon set, an additional  threshold, mid-val, is required and in a 5-icon set, mid2_val is needed as well.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The type of these thresholds can be defined in terms of percent (of the range), percentile  or simply with a num (number) (e.g. as min_type=\"percent\"). For each threshold,  the value can either be given as a number (as a String) or as a simple cell reference.  Alternatively, specifying the type as formula allows the value to be determined by any  valid Excel formula.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"note: Note\nCell references used to define threshold values in an iconSet MUST always be given as absolute  cell references (e.g. \"\\$A\\$4\"). Relative references should not be used.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Using the example above, change both the type and value of the thresholds like this:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> XLSX.setConditionalFormat(s, \"A1:A10\", :iconSet;\n            min_type=\"num\", max_type=\"num\", \n            min_val=\"2\", max_val=\"9\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"To suppress the values in cells and just show the icons, use showVal=\"false\", to reverse the icon ordering  use reverse=\"true\" and to change the default comparison from >= to > set min_gte=\"false\" (and  equivalent for mid, mid2 and max):","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> XLSX.writetable!(s, [collect(1:10), collect(1:10), collect(1:10), collect(1:10)],\n            [\"normal\", \"showVal=\\\"false\\\"\", \"reverse=\\\"true\\\"\", \"min_gte=\\\"false\\\"\"])\n\njulia> XLSX.setConditionalFormat(s, \"A2:A11\", :iconSet;\n            min_type=\"num\",  max_type=\"num\",\n            min_val=\"3\",     max_val=\"8\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"B2:B11\", :iconSet;\n            min_type=\"num\",  max_type=\"num\",\n            min_val=\"3\",     max_val=\"8\",\n            showVal=\"false\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"C2:C11\", :iconSet;\n            min_type=\"num\",  max_type=\"num\",\n            min_val=\"3\",     max_val=\"8\",\n            reverse=\"true\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"D2:D11\", :iconSet;\n            min_type=\"num\",  max_type=\"num\",\n            min_val=\"3\",     max_val=\"8\",\n            min_gte=\"false\", max_gte=\"false\")\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Create a custom icon set by specifying iconset=\"Custom\". The icons to use in the custom set are  defined with icon_list keyword, which takes a vector of integers defining which of the 52 built  in icons to use. Use of the val and type keywords dictate the number of icons to use. If mid_type  and mid_val are both defined, but not mid2_val or mid2_type, then a 4-icon set will be used.  If both sets of keywords are defined, a 5-icon set is used and if neither is set, a 3-icon set will  be used.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"This is illustrated with code below, which produces a key defining which integer to use  in icon_list to represent any desired icon:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"using XLSX\nf=XLSX.newxlsx()\ns=f[1]\nfor i = 0:3\n    for j=1:13\n        s[i+1,j]=i*13+j\n    end\nend\nfor j=1:13\n     XLSX.setConditionalFormat(s, 1:4, j, :iconSet; # Create a custom 4-icon set in each column.\n        iconset=\"Custom\",\n        icon_list=[j, 13+j, 26+j, 39+j],\n        min_type=\"percent\", mid_type=\"percent\", max_type=\"percent\",\n        min_val=\"25\", mid_val=\"50\", max_val=\"75\"\n        )\nend\nXLSX.setColumnWidth(s, 1:13, width=6.4)\nXLSX.setRowHeight(s, 1:4, height=27.75)\nXLSX.setAlignment(s, \"A1:M4\", horizontal=\"center\", vertical=\"center\")\nXLSX.setBorder(s, \"A1:M4\", allsides = [\"style\"=>\"thin\",\"color\"=>\"black\"])\nXLSX.writexlsx(\"iconKey.xlsx\", f, overwrite=true)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Specifying too few icons in icon_list throws an error while any extra will simply be ignored.","category":"page"},{"location":"formatting/conditionalFormatting/#Cell-references-in-conditional-formats","page":"Conditional formats","title":"Cell references in conditional formats","text":"","category":"section"},{"location":"formatting/conditionalFormatting/#Cell-Ranges","page":"Conditional formats","title":"Cell Ranges","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Cell ranges for conditional formats are always absolute refences. The specified range to which a  conditional format is to be applied is always treated as being based upon absolute cell references  so that, for example","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> XLSX.setConditionalFormat(s, \"A2:C5\", :colorScale; colorscale=\"greenyellow\")","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"will be converted automatically to the range \"$A$2:$C$5\" by Excel itself. There is therefore no need to specify  absolute cell ranges when calling setCondtionalFormat()","category":"page"},{"location":"formatting/conditionalFormatting/#Relative-and-absolute-cell-references","page":"Conditional formats","title":"Relative and absolute cell references","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Cell references used to specify value or value2 or in any formula (for :expression type  conditional formats only) may be either absolute or relative. As in Excel, an absolute reference  is defined using a $ prefix to either or both the row or the column part of the cell reference  but here the $ must be appropriately escaped. Thus:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"value = \"B2\"          # relative reference\nvalue = \"\\$B\\$2\"      # (escaped) absolute reference","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The cell used in a comparison is adjusted for each cell in the range if a relative reference is used. This is  illustrated in the following example. Cells in column A are referenced to column B using a relative reference, meaning A2 is compared with B2 but A3 is compared with B3 and so on until A5 is compared with B5. In contrast, column B is referenced to cell C2 using an absolute reference. Each cell in column B is compared  with cell C2.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1)\n\njulia> col1=rand(5)\n5-element Vector{Float64}:\n 0.6283728884101448\n 0.7516580026008692\n 0.2738854683970795\n 0.13517788102005834\n 0.4659468387663539\n\njulia> col2=rand(5)\n5-element Vector{Float64}:\n 0.7582186445697804\n 0.739539172599636\n 0.4389109821689414\n 0.14156225872248773\n 0.10715394525726485\n\njulia> XLSX.writetable!(s, [col1, col2],[\"col1\", \"col2\"])\n\njulia> s[\"C2\"]=0.5\n0.5\n\njulia> s[:]\n6×3 Matrix{Any}:\n  \"col1\"    \"col2\"    missing\n 0.628373  0.758219  0.5\n 0.751658  0.739539   missing\n 0.273885  0.438911   missing\n 0.135178  0.141562   missing\n 0.465947  0.107154   missing\n\njulia> XLSX.setConditionalFormat(s, \"A2:A6\", :cellIs; operator=\"greaterThan\", value=\"B2\", dxStyle=\"redfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"B2:B6\", :cellIs; operator=\"greaterThan\", value=\"\\$C\\$2\", dxStyle=\"greenfilltext\")\n0\n","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"note: Note\nIt is not possible to use relative cell references in conditional format types :dataBar,  :colorScale or :iconSet.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"note: Note\nExcel permits cell references to cells in other sheets for comparisons in conditional formats (e.g. \"OtherSheet!A1\"), but this is handled differently internally than references within the  same sheet. This functionality is not universally implemented in XLSX.jl yet. ","category":"page"},{"location":"formatting/conditionalFormatting/#Overlaying-conditional-formats","page":"Conditional formats","title":"Overlaying conditional formats","text":"","category":"section"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"It is possible to overlay multiple conditional formats over each other in a  cell range or even in different, overlapping cell ranges. Starting with a table of  integers, we can apply three different conditional formats sequentially. Excel applies  these in priority order (priority 1 is higher priority than priority 2) which is the  same as the order in which they were defined with setConditionalFormat.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> s[1:5, 1:3]\n5×3 Matrix{Any}:\n   \"first\"    \"middle\"    \"last\"\n  1         15           9\n 12          6          10\n  3         17          11\n 14          8           2\n\njulia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"A2:C5\", :colorScale; colorscale=\"greenyellowred\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:C5\", :top10;\n                    operator =\"topN\",\n                    value=\"3\",\n                    font=[\"color\"=>\"magenta3\", \"strike\"=>\"true\"],\n                    fill=[\"pattern\"=>\"lightVertical\", \"fgColor\"=>\"lawngreen\", \"bgColor\"=>\"cornsilk\"],\n                    border=[\"style\"=>\"double\", \"color\"=>\"cyan\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:A5\", :cellIs;\n                   operator=\"lessThan\",\n                   value=\"2\",\n                   font=[\"color\"=>\"coral\", \"bold\"=>\"true\"],\n                   fill=[\"pattern\"=>\"lightHorizontal\", \"fgColor\"=>\"cornsilk\"],\n                   border=[\"style\"=>\"dashed\", \"color\"=>\"orangered4\"])\n0\n\njulia> XLSX.getConditionalFormats(s)\n3-element Vector{Pair{XLSX.CellRange, NamedTuple}}:\n A2:A5 => (type = \"cellIs\", priority = 3)\n A2:C5 => (type = \"colorScale\", priority = 1)\n A2:C5 => (type = \"top10\", priority = 2)\n","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"When applying multiple overlayed formats, it is possible to make the formatting stop if any cell meets  one of the conditions, so that lower proirity conditional formats are not applied to that cell. This is  achieved with the stopIfTrue keyword. It is not possible to apply stopIfTrue to :dataBar,  :colorScale or :iconSet types.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"The example below illustrates how stopIfTrue is used to stop further conditional formats from being  applied to cells to which red borders are applied:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> s[1:5, 1:3]\n5×3 Matrix{Any}:\n   \"first\"    \"middle\"    \"last\"\n  1         15           9\n 12          6          10\n  3         17          11\n 14          8           2\n\njulia> XLSX.setConditionalFormat(s, \"A2:C5\", :cellIs; # No further conditions will be evaluated if this condition is met.\n                    operator =\"greaterThan\",\n                    value=\"9\",\n                    stopIfTrue=\"true\",\n                    dxStyle = \"redborder\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:C5\", :top10;  # Won't apply if the max value in the range is > 9.\n                    operator =\"topN\",\n                    value=\"1\",\n                    dxStyle = \"redfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:C5\", :colorScale; colorscale=\"greenyellow\") # Won't apply to any cell with a value > 9\n0","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"Overlaying the same three conditional formats without setting the stopIfTrue option  will result in the following, instead:","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"It is possible to overlay :colorScales, :dataBars and :iconSets in the same or  overlapping cell ranges.","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"julia> \nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1)\n\njulia> XLSX.writetable!(s, [rand(10),rand(10),rand(10),rand(10),rand(10),rand(10),rand(10)],[\"col1\",\"col2\",\"col3\",\"col4\",\"col5\",\"col6\",\"col7\"])\n\njulia> XLSX.setConditionalFormat(s, \"A5:E8\", :dataBar; direction=\"rightToLeft\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"C5:G8\", :iconSet; iconset=\"5Arrows\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"C2:E11\", :colorScale; colorscale=\"greenyellowred\")\n0\n\njulia> XLSX.setFormat(s, \"A2:G11\"; format=\"#0.00\")\n-1\n","category":"page"},{"location":"formatting/conditionalFormatting/","page":"Conditional formats","title":"Conditional formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/mergedCells/#Working-with-merged-cells","page":"Working with merged cells","title":"Working with merged cells","text":"","category":"section"},{"location":"formatting/mergedCells/","page":"Working with merged cells","title":"Working with merged cells","text":"Worksheets may contain merged cells. XLSX.jl provides functions to identify the merged cells in a worksheet,  to determine if a cell is part of a merged range and to determine the value of a merged cell range from any  cell in that range.","category":"page"},{"location":"formatting/mergedCells/","page":"Working with merged cells","title":"Working with merged cells","text":"\njulia> using XLSX\n\njulia> f=XLSX.opentemplate(\"customXml.xlsx\")\nXLSXFile(\"customXml.xlsx\") containing 2 Worksheets\n            sheetname size          range        \n-------------------------------------------------\n              Mock-up 116x11        A1:K116\n     Document History 17x3          A1:C17\n\njulia> XLSX.getMergedCells(f[1])\n25-element Vector{XLSX.CellRange}:\n D49:H49\n D72:J72\n F94:J94\n F96:J96\n F84:J84\n F86:J86\n D62:J63\n D51:J53\n D55:J60\n D92:J92\n D82:J82\n D74:J74\n D67:J68\n D47:H47\n D9:H9\n D11:G11\n D12:G12\n D14:E14\n D16:E16\n D32:F32\n D38:J38\n D34:J34\n D18:E18\n D20:E20\n D13:G13\n\njulia> XLSX.isMergedCell(f[1], \"D13\")\ntrue\n\njulia> XLSX.isMergedCell(f[1], \"H13\")\nfalse\n\njulia> XLSX.getMergedBaseCell(f[1], \"E18\") # E18 is a merged cell. The base cell in the merged range is D18.\n(baseCell = D18, baseValue = \"Here\") # The base cell in the merged range is D18 and it's value is \"Here\".","category":"page"},{"location":"formatting/mergedCells/","page":"Working with merged cells","title":"Working with merged cells","text":"It is also possible to create new merged cells:","category":"page"},{"location":"formatting/mergedCells/","page":"Working with merged cells","title":"Working with merged cells","text":"\njulia> XLSX.isMergedCell(f[1], \"F5\")\nfalse\n\njulia> XLSX.isMergedCell(f[1], \"J8\")\nfalse\n\njulia> XLSX.mergeCells(s, \"F5:J8\")\n\njulia> s[\"F5\"] = pi\nπ = 3.1415926535897...\n\njulia> XLSX.isMergedCell(f[1], \"J8\")\ntrue\n\njulia> XLSX.isMergedCell(f[1], \"F5\")\ntrue\n\njulia> XLSX.getMergedBaseCell(f[1], \"J8\")\n(baseCell = F5, baseValue = 3.141592653589793)","category":"page"},{"location":"formatting/mergedCells/","page":"Working with merged cells","title":"Working with merged cells","text":"It is not allowed to create new merged cells that overlap at all with any existing merged cells.","category":"page"},{"location":"formatting/mergedCells/","page":"Working with merged cells","title":"Working with merged cells","text":"warning: Warning\nIt is possible to write into any merged cell using XLSX.jl, even those that are not the  base cell of the merged range. This is illustrated below:\njulia> using XLSX\n\njulia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range        \n-------------------------------------------------\n            Sheet1 1x1           A1:A1        \n\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1) \n\njulia> s[\"A1:A3\"]=5\n5This produces the simple sheet shown.(Image: image|320x500)Merging the three cells A1:A3 sets the cells A2 and A3 to missing just as Excel does.julia> s[\"A1\"]\n5\n\njulia> s[\"A2\"]\n5\n\njulia> s[\"A3\"]\n5\n\njulia> XLSX.mergeCells(s, \"A1:A3\")\n0\n\njulia> s[\"A1\"]\n5\n\njulia> s[\"A2\"]\nmissing\n\njulia> s[\"A3\"]\nmissing(Image: image|320x500)However, even after the merge, it is possible to explicitly write into the merged cells.  These written values will not be visible in Excel but can still be accessed by reference.julia> s[\"A2\"]=\"text here now\"\n\"text here now\"\n\njulia> s[\"A1\"]\n5\n\njulia> s[\"A2\"]\n\"text here now\"\n\njulia> s[\"A3\"]\nmissing\n\njulia> XLSX.getMergedBaseCell(s, \"A2\")\n(baseCell = A1, baseValue = 5)\nThe cell A2 remains merged, and this is how Excel displays it. The assigned cell value  won't be visible in Excel, but it can be referenced in a formula as shown here, where  cell B2 references cell A2 in its formula (\"=A2\"):(Image: image|320x500)Assigning values to cells in a merged range like this is prevented in Excel itself by the UI  although it is possible using VBA. There is currently no check to prevent this in XLSX.jl. See #241","category":"page"},{"location":"api/files/#Files-and-worksheets","page":"Files and worksheets","title":"Files and worksheets","text":"","category":"section"},{"location":"api/files/#Files","page":"Files and worksheets","title":"Files","text":"","category":"section"},{"location":"api/files/#XLSX.XLSXFile","page":"Files and worksheets","title":"XLSX.XLSXFile","text":"XLSXFile represents a reference to an Excel file.\n\nIt is created by using XLSX.readxlsx or XLSX.openxlsx  or XLSX.opentemplate or XLSX.newxlsx.\n\nFrom a XLSXFile you can navigate to a XLSX.Worksheet reference as shown in the example below.\n\nExample\n\nxf = XLSX.readxlsx(\"myfile.xlsx\")\nsh = xf[\"mysheet\"] # get a reference to a Worksheet\n\n\n\n\n\n","category":"type"},{"location":"api/files/#XLSX.readxlsx","page":"Files and worksheets","title":"XLSX.readxlsx","text":"readxlsx(source::Union{AbstractString, IO}) :: XLSXFile\n\nMain function for reading an Excel file. This function will read the whole Excel file into memory and return a closed XLSXFile.\n\nConsider using XLSX.openxlsx for lazy loading of Excel file contents.\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.openxlsx","page":"Files and worksheets","title":"XLSX.openxlsx","text":"openxlsx(f::F, source::Union{AbstractString, IO}; mode::AbstractString=\"r\", enable_cache::Bool=true) where {F<:Function}\n\nOpen an XLSX file for reading and/or writing. It returns an opened XLSXFile that will be automatically closed  after applying f to the file.\n\nDo syntax\n\nThis function should be used with do syntax, like in:\n\nXLSX.openxlsx(\"myfile.xlsx\") do xf\n    # read data from `xf`\nend\n\nFilemodes\n\nThe mode argument controls how the file is opened. The following modes are allowed:\n\nr : read-only mode. The existing data in source will be accessible for reading. This is the default mode.\nw : write mode. Opens an empty file that will be written to source. If source already exists it will be overwritten.\nrw : edit mode. Opens source for editing. The file will be saved (overwritten) to disk when the function ends.\n\nwarning: Warning\nUsing do-block syntax in \"rw\" mode will overwrite the file you read in with the modified data when the do block ends. Care is needed to ensure data are not inadvertantly overwritten, especially if the xlsx file contains any elements  that XLSX.jl cannot process (such as charts, pivot tables, etc), but that would otherwise be preserved if not  overwritten. You may avoid this risk by choosing to open files in \"rw\" mode without using do-block syntax, in which  case it becomes necessary explicitly to write the XLSXFile out again, providing the option to write to another file name.\n\nArguments\n\nsource is IO or the complete path to the file.\nmode is the file mode, as explained in the last section.\nenable_cache:\n\nIf enable_cache=true and the file is opened in read-only mode, all worksheet cells  will be cached as they are read the first time. When you read a worksheet cell for the  second (or subsequent) time it will use the cached value instead of reading from disk. If enable_cache=true and the file is opened in write mode, all cells are eagerly read  into the cache as the file is opened (they will be needed at write anyway). For very  large files, this can take a few seconds.\n\nIf enable_cache=false, worksheet cells will always be read from disk. This is useful when you want to read a spreadsheet that doesn't fit into memory.\n\nThe default value is enable_cache=true.\n\nExamples\n\nRead from file\n\nThe following example shows how you would read worksheet cells, one row at a time, where myfile.xlsx is a spreadsheet that doesn't fit into memory.\n\njulia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do xf\n          for r in eachrow(xf[\"mysheet\"])\n              # read something from row `r`\n          end\n       end\n\nWrite a new file\n\nXLSX.openxlsx(\"new.xlsx\", mode=\"w\") do xf\n    sheet = xf[1]\n    sheet[1, :] = [1, Date(2018, 1, 1), \"test\"]\nend\n\nEdit an existing file\n\nXLSX.openxlsx(\"edit.xlsx\", mode=\"rw\") do xf\n    sheet = xf[1]\n    sheet[2, :] = [2, Date(2019, 1, 1), \"add new line\"]\nend\n\nSee also XLSX.readxlsx.\n\n\n\n\n\nopenxlsx(source::Union{AbstractString, IO}; mode=\"r\", enable_cache=true) :: XLSXFile\n\nSupports opening a XLSX file without using do-syntax.\n\nIf opened with mode=\"rw\" then use savexlsx to save the XLSX back to source,  overwriting the original file. Alternatively, use writexlsx to save to a different filename.\n\nThese two invocations of openxlsx are functionally equivalent:\n\nXLSX.openxlsx(\"myfile.xlsx\", mode=\"rw\") do xf\n    # Do some processing on the content\nend\n\nxf = openxlsx(\"myfile.xlsx\", mode=\"rw\")\n# Do some processing on the content\nXLSX.savexlsx(xf)\n\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.opentemplate","page":"Files and worksheets","title":"XLSX.opentemplate","text":"opentemplate(source::Union{AbstractString, IO}) :: XLSXFile\n\nRead an existing Excel (.xlsx) file as a template and return as a writable XLSXFile for editing  and saving to another file with XLSX.writexlsx.\n\nA convenience function equivalent to openxlsx(source; mode=\"rw\", enable_cache=true)\n\nnote: Note\nXLSX.jl only works with .xlsx files and cannot work with Excel .xltx template files.  Reading as a template in this package merely means opening a .xlsx file to edit, update  and then write as an updated .xlsx file (e.g. using XLSX.writexlsx()). Doing so retains  the formatting and layout of the opened file, but this is not the same as using a .xltx file.\n\nExamples\n\njulia> xf = opentemplate(\"myExcelFile.xlsx\")\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.newxlsx","page":"Files and worksheets","title":"XLSX.newxlsx","text":"newxlsx([sheetname::AbstractString]) :: XLSXFile\n\nReturn an empty, writable XLSXFile with 1 worksheet for editing and  subsequent saving to a file with XLSX.writexlsx. By default, the worksheet is Sheet1. Specify sheetname to give the worksheet a different name.\n\nExamples\n\njulia> xf = XLSX.newxlsx()\n\njulia> xf = XLSX.newxlsx(\"MySheet\")\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.writexlsx","page":"Files and worksheets","title":"XLSX.writexlsx","text":"writexlsx(output_source::Union{AbstractString,IO}, xf::XLSXFile; [overwrite=false])\n\nWrite an XLSXFile given by xf to the IO or filepath output_source.\n\nThe source attribute of the XLSXFile will be updated to the output_source if it is a filepath.\n\nReturns the filepath of the written file if a filename is supplied, or nothing if writing to an IO.\n\nIf overwrite=true, output_source (when a filepath) will be overwritten if it exists.\n\nSee also savexlsx.\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.savexlsx","page":"Files and worksheets","title":"XLSX.savexlsx","text":"savexlsx(f::XLSXFile)\n\nSave an XLSXFile instance back to the file from which it was opened (given in f.source),  overwriting original content.\n\nA new XLSXFile created with XLSX.newxlsx (or using openxlsx without specifying a filename) will  have source set to \"blank.xlsx\" and cannot be saved with this function. Use writexlsx instead  to specify a file name for the saved file.\n\nReturns the filepath of the written file if a filename is supplied, or nothing if writing to an IO.\n\n\n\n\n\n","category":"function"},{"location":"api/files/#Worksheets","page":"Files and worksheets","title":"Worksheets","text":"","category":"section"},{"location":"api/files/#XLSX.Worksheet","page":"Files and worksheets","title":"XLSX.Worksheet","text":"A Worksheet represents a reference to an Excel Worksheet.\n\nFrom a Worksheet you can query for Cells, cell values and ranges.\n\nExample\n\nxf = XLSX.readxlsx(\"myfile.xlsx\")\nsh = xf[\"mysheet\"] # get a reference to a Worksheet\nprintln( sh[2, 2] ) # access element \"B2\" (2nd row, 2nd column)\nprintln( sh[\"B2\"] ) # you can also use the cell name\nprintln( sh[\"A2:B4\"] ) # or a cell range\nprintln( sh[:] ) # all data inside worksheet's dimension\n\n\n\n\n\n","category":"type"},{"location":"api/files/#XLSX.sheetnames","page":"Files and worksheets","title":"XLSX.sheetnames","text":"sheetnames(xl::XLSXFile)\nsheetnames(wb::Workbook)\n\nReturn a vector with Worksheet names for this Workbook.\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.sheetcount","page":"Files and worksheets","title":"XLSX.sheetcount","text":"sheetcount(xlsfile) :: Int\n\nCount the number of sheets in the Workbook.\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.hassheet","page":"Files and worksheets","title":"XLSX.hassheet","text":"hassheet(wb::Workbook, sheetname::AbstractString)\nhassheet(xl::XLSXFile, sheetname::AbstractString)\n\nReturn true if wb contains a sheet named sheetname.\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.rename!","page":"Files and worksheets","title":"XLSX.rename!","text":"rename!(ws::Worksheet, name::AbstractString)\n\nRename a Worksheet to name.\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.addsheet!","page":"Files and worksheets","title":"XLSX.addsheet!","text":"addsheet!(wb::Workbook, [name::AbstractString=\"\"]) --> ::Worksheet\naddsheet!(xf::XLSXFile, [name::AbstractString=\"\"]) --> ::Worksheet\n\nCreate a new worksheet named name. If name is not provided, a unique name is created.\n\nSee also copysheet!, deletesheet!\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.copysheet!","page":"Files and worksheets","title":"XLSX.copysheet!","text":"copysheet!(ws::Worksheet, [name::AbstractString=\"\"]) --> ::Worksheet\n\nCreate a copy of the worksheet ws and add it to the end of the workbook with the  specified worksheet name. Return the new worksheet object. If name is not provided, a new name is generated by appending \" (copy)\" to the original  worksheet name, with a further numerical suffix to guarantee uniqueness if necessary. To copy worksheets, the XLSXFile must be writable (opened with mode=\"rw\" or as a template). See also XLSX.openxlsx and XLSX.opentemplate.\n\nwarning: Experimental\nThis function is experimental is not guaranteed to work with all XLSX files,  especially those with complex features. However, cell formats, conditional formats  and worksheet defined names should all copy OK. Please report any issues.\n\nSee also addsheet!, deletesheet!\n\nExamples\n\njulia> f=XLSX.openxlsx(\"general.xlsx\", mode=\"rw\")\nXLSXFile(\"C:\\...\\general.xlsx\") containing 13 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              general 10x6          A1:F10\n               table3 5x6           A2:F6\n               table4 4x3           E12:G15\n                table 12x8          A2:H13\n               table2 5x3           A1:C5\n                empty 1x1           A1:A1\n               table5 6x1           C3:C8\n               table6 8x2           B1:C8\n               table7 7x2           B2:C8\n               lookup 4x9           B2:J5\n         header_error 3x4           B2:E4\n       named_ranges_2 4x5           A1:E4\n         named_ranges 14x6          A2:F15\n\njulia> XLSX.copysheet!(f[4])\n12×8 XLSX.Worksheet: [\"table (copy)\"](A2:H13)\n\njulia> f\nXLSXFile(\"C:\\...\\general.xlsx\") containing 14 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              general 10x6          A1:F10\n               table3 5x6           A2:F6\n               table4 4x3           E12:G15\n                table 12x8          A2:H13\n               table2 5x3           A1:C5\n                empty 1x1           A1:A1\n               table5 6x1           C3:C8\n               table6 8x2           B1:C8\n               table7 7x2           B2:C8\n               lookup 4x9           B2:J5\n         header_error 3x4           B2:E4\n       named_ranges_2 4x5           A1:E4\n         named_ranges 14x6          A2:F15\n         table (copy) 12x8          A2:H13\n\n\n\n\n\n\n","category":"function"},{"location":"api/files/#XLSX.deletesheet!","page":"Files and worksheets","title":"XLSX.deletesheet!","text":"deletesheet!(ws::Worksheet) -> ::XLSXFile\ndeletesheet!(wb::Workbook, name::AbstractString) -> ::XLSXFile\ndeletesheet!(xf::XLSXFile, name::AbstractString) -> ::XLSXFile\ndeletesheet!(xf::XLSXFile, sheetId::Integer) -> ::XLSXFile\n\nDelete the given worksheet, the worksheet with the given name or the worksheet with the given sheetId from its XLSXFile  (sheetId is a 1-based integer representing the order in which worksheet tabs are displayed in Excel).\n\nnote: Caution\nCells in the other sheets that have references to the deleted sheet will fail when the sheet is deleted. The formulae are updated to contain a #Ref! error in place of each sheetcell reference.\n\nSee also addsheet!, copysheet!\n\nExamples\n\njulia> f = XLSX.opentemplate(\"general.xlsx\")\nXLSXFile(\"C:\\...\\general.xlsx\") containing 13 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              general 10x6          A1:F10\n               table3 5x6           A2:F6\n               table4 4x3           E12:G15\n                table 12x8          A2:H13\n               table2 5x3           A1:C5\n                empty 1x1           A1:A1        \n               table5 6x1           C3:C8\n               table6 8x2           B1:C8\n               table7 7x2           B2:C8\n               lookup 4x9           B2:J5\n         header_error 3x4           B2:E4\n       named_ranges_2 4x5           A1:E4\n         named_ranges 14x6          A2:F15\n\n\njulia> XLSX.deletesheet!(f[4])\nXLSXFile(\"C:\\...\\general.xlsx\") containing 12 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              general 10x6          A1:F10\n               table3 5x6           A2:F6\n               table4 4x3           E12:G15\n               table2 5x3           A1:C5\n                empty 1x1           A1:A1\n               table5 6x1           C3:C8\n               table6 8x2           B1:C8\n               table7 7x2           B2:C8\n               lookup 4x9           B2:J5\n         header_error 3x4           B2:E4\n       named_ranges_2 4x5           A1:E4\n         named_ranges 14x6          A2:F15\n\n\njulia> XLSX.deletesheet!(f, \"table5\")\nXLSXFile(\"C:\\...\\general.xlsx\") containing 11 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              general 10x6          A1:F10\n               table3 5x6           A2:F6\n               table4 4x3           E12:G15\n               table2 5x3           A1:C5\n                empty 1x1           A1:A1\n               table6 8x2           B1:C8\n               table7 7x2           B2:C8\n               lookup 4x9           B2:J5\n         header_error 3x4           B2:E4\n       named_ranges_2 4x5           A1:E4\n         named_ranges 14x6          A2:F15\n\n\njulia> XLSX.deletesheet!(f, 1)\nXLSXFile(\"C:\\...\\general.xlsx\") containing 10 Worksheets\n            sheetname size          range\n-------------------------------------------------\n               table3 5x6           A2:F6\n               table4 4x3           E12:G15\n               table2 5x3           A1:C5\n                empty 1x1           A1:A1\n               table6 8x2           B1:C8\n               table7 7x2           B2:C8\n               lookup 4x9           B2:J5\n         header_error 3x4           B2:E4\n       named_ranges_2 4x5           A1:E4\n         named_ranges 14x6          A2:F15\n\n\n\n\n\n","category":"function"},{"location":"formatting/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"formatting/examples/#Applying-cell-format-to-an-existing-table","page":"Examples","title":"Applying cell format to an existing table","text":"","category":"section"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"Consider a simple table, created from scratch, like this:","category":"page"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"using XLSX\nusing Dates\n\n# First create some data in an empty XLSXfile\nxf = XLSX.newxlsx()\nsheet = xf[\"Sheet1\"]\n\ncol_names = [\"Integers\", \"Strings\", \"Floats\", \"Booleans\", \"Dates\", \"Times\", \"DateTimes\", \"AbstractStrings\", \"Rational\", \"Irrationals\", \"MixedStringNothingMissing\"]\ndata = Vector{Any}(undef, 11)\ndata[1] = [1, 2, missing, UInt8(4)]\ndata[2] = [\"Hey\", \"You\", \"Out\", \"There\"]\ndata[3] = [101.5, 102.5, missing, 104.5]\ndata[4] = [true, false, missing, true]\ndata[5] = [Date(2018, 2, 1), Date(2018, 3, 1), Date(2018, 5, 20), Date(2018, 6, 2)]\ndata[6] = [Dates.Time(19, 10), Dates.Time(19, 20), Dates.Time(19, 30), Dates.Time(0, 0)]\ndata[7] = [Dates.DateTime(2018, 5, 20, 19, 10), Dates.DateTime(2018, 5, 20, 19, 20), Dates.DateTime(2018, 5, 20, 19, 30), Dates.DateTime(2018, 5, 20, 19, 40)]\ndata[8] = SubString.([\"Hey\", \"You\", \"Out\", \"There\"], 1, 2)\ndata[9] = [1 // 2, 1 // 3, missing, 22 // 3]\ndata[10] = [pi, sqrt(2), missing, sqrt(5)]\ndata[11] = [nothing, \"middle\", missing, \"rotated\"]\n\nXLSX.writetable!(\n    sheet,\n    data,\n    col_names;\n    anchor_cell=XLSX.CellRef(\"B2\"),\n    write_columnnames=true,\n)\n\nXLSX.writexlsx(\"mytable_unformatted.xlsx\", xf, overwrite=true)","category":"page"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"By default, this table will look like this in Excel:","category":"page"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"We can apply some formatting choices to change the table's appearance:","category":"page"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"This is achieved with the following code:","category":"page"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"# Cell borders\nXLSX.setUniformBorder(sheet, \"B2:L6\";\n    top    = [\"style\" => \"hair\", \"color\" => \"FF000000\"],\n    bottom = [\"style\" => \"hair\", \"color\" => \"FF000000\"],\n    left   = [\"style\" => \"thin\", \"color\" => \"FF000000\"],\n    right  = [\"style\" => \"thin\", \"color\" => \"FF000000\"]\n)\nXLSX.setBorder(sheet, \"B2:L2\"; bottom = [\"style\" => \"medium\", \"color\" => \"FF000000\"]) \nXLSX.setBorder(sheet, \"B6:L6\"; top = [\"style\" => \"double\", \"color\" => \"FF000000\"])\nXLSX.setOutsideBorder(sheet, \"B2:L6\"; outside = [\"style\" => \"thick\", \"color\" => \"FF000000\"])\n\n# Cell fill\nXLSX.setFill(sheet, \"B2:L2\"; pattern = \"solid\", fgColor = \"FF444444\")\n\n# Cell fonts\nXLSX.setFont(sheet, \"B2:L2\"; bold=true, color = \"FFFFFFFF\")\nXLSX.setFont(sheet, \"B3:L6\"; color = \"FF444444\")\nXLSX.setFont(sheet, \"C3\"; name = \"Times New Roman\")\nXLSX.setFont(sheet, \"C6\"; name = \"Wingdings\", color = \"FF2F75B5\")\n\n# Cell alignment\nXLSX.setAlignment(sheet, \"L2\"; wrapText = true)\nXLSX.setAlignment(sheet, \"I4\"; horizontal=\"right\")\nXLSX.setAlignment(sheet, \"I6\"; horizontal=\"right\")\nXLSX.setAlignment(sheet, \"C4\"; indent=2)\nXLSX.setAlignment(sheet, \"F4\"; vertical=\"top\")\nXLSX.setAlignment(sheet, \"G4\"; vertical=\"center\")\nXLSX.setAlignment(sheet, \"L4\"; horizontal=\"center\", vertical=\"center\")\nXLSX.setAlignment(sheet, \"G3:G6\"; horizontal = \"center\")\nXLSX.setAlignment(sheet, \"H3:H6\"; shrink = true)\nXLSX.setAlignment(sheet, \"L6\"; horizontal = \"center\", rotation = 90, wrapText=true)\n\n# Row height and column width\nXLSX.setRowHeight(sheet, \"B4\"; height=50)\nXLSX.setRowHeight(sheet, \"B6\"; height=15)\nXLSX.setColumnWidth(sheet, \"I\"; width = 20.5)\n\n# Conditional formatting\nfunction blankmissing(sheet, rng) # Fill with grey and apply both diagonal borders on cells\n    for c in rng                  # with missing values\n        if ismissing(sheet[c])\n            XLSX.setFill(sheet, c; pattern = \"solid\", fgColor = \"grey\")\n            XLSX.setBorder(sheet, c; diagonal = [\"style\" => \"thin\", \"color\" => \"black\"])\n           end\n    end\nend\nfunction trueorfalse(sheet, rng) # Use green or red font for true or false respectively\n    for c in rng\n        if !ismissing(sheet[c]) && sheet[c] isa Bool\n            XLSX.setFont(sheet, c, bold=true, color = sheet[c] ? \"FF548235\" : \"FFC00000\")\n        end\n    end\nend\nfunction redgreenminmax(sheet, rng) # Fill light green / light red the cell with maximum / minimum value\n    mn, mx = extrema(x for x in sheet[rng] if !ismissing(x))\n    for c in rng\n        if !ismissing(sheet[c])\n            if sheet[c] == mx\n               XLSX.setFill(sheet, c; pattern = \"solid\", fgColor = \"FFC6EFCE\")\n            elseif sheet[c] == mn\n                XLSX.setFill(sheet, c; pattern = \"solid\", fgColor = \"FFFFC7CE\")\n            end\n        end\n    end\nend\n\nblankmissing(sheet, XLSX.CellRange(\"B3:L6\"))\ntrueorfalse(sheet, XLSX.CellRange(\"B2:L6\"))\nredgreenminmax(sheet, XLSX.CellRange(\"D3:D6\"))\nredgreenminmax(sheet, XLSX.CellRange(\"J3:J6\"))\nredgreenminmax(sheet, XLSX.CellRange(\"K3:K6\"))\n\n# Number formats\nXLSX.setFormat(sheet, \"J3\"; format = \"Percentage\")\nXLSX.setFormat(sheet, \"J4\"; format = \"Currency\")\nXLSX.setFormat(sheet, \"J6\"; format = \"Number\")\nXLSX.setFormat(sheet, \"K3\"; format = \"0.0\")\nXLSX.setFormat(sheet, \"K4\"; format = \"0.000\")\nXLSX.setFormat(sheet, \"K6\"; format = \"0.0000\")\n\n# Save to an actual XLSX file\nXLSX.writexlsx(\"mytable_formatted.xlsx\", xf, overwrite=true)","category":"page"},{"location":"formatting/examples/#Creating-a-formatted-form","page":"Examples","title":"Creating a formatted form","text":"","category":"section"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"There is a file, customXml.xlsx, in the \\data folder of this project that looks like a template  file - a form to be filled in. The code below creates this form from scratch and makes  extensive use of vector indexing for rows and columns and of non-contiguous ranges:","category":"page"},{"location":"formatting/examples/","page":"Examples","title":"Examples","text":"using XLSX\n\nf = XLSX.newxlsx()\ns = f[1]\ns[\"A1:K116\"] = \"\"\n\ns[\"B2\"] = \"Catalogue Entry Form\"\n\ns[\"B5\"] = \"User Data\"\ns[\"B7\"] = \"Recipient ID\"\ns[\"B9\"] = \"Recipient Name\"\ns[\"B11\"] = \"Address 1\"\ns[\"B12\"] = \"Address 2\"\ns[\"B13\"] = \"Address 3\"\ns[\"B14\"] = \"Town\"\ns[\"B16\"] = \"Postcode\"\ns[\"B18\"] = \"Ward\"\ns[\"B20\"] = \"Region\"\ns[\"H18\"] = \"Local Authority\"\ns[\"H20\"] = \"UK Constituency\"\ns[\"B22\"] = \"GrantID\"\ns[\"D22\"] = \"Grant Date\"\ns[\"F22\"] = \"Grant Amount\"\ns[\"H22\"] = \"Grant Title\"\ns[\"J22\"] = \"Distributor\"\ns[\"B32\"] = \"Distributor\"\n\ns[\"B30\"] = \"Creator\"\ns[\"B34\"] = \"Created by\"\ns[\"D36\"] = \"Email\"\ns[\"H36\"] = \"Phone\"\ns[\"B38\"] = \"Grant Manager\"\ns[\"D40\"] = \"Email\"\ns[\"H40\"] = \"Phone number\"\n\ns[\"B43\"] = \"Summary\"\ns[\"B45\"] = \"Summary ID\"\ns[\"H45\"] = \"Date Created\"\ns[\"B47\"] = \"Summary Name\"\ns[\"B49\"] = \"Headline\"\ns[\"B51\"] = \"Short Description\"\ns[\"B55\"] = \"Long Description\"\ns[\"B62\"] = \"Quote 1\"\ns[\"D65\"] = \"Quote Attribution\"\ns[\"H65\"] = \"Quote Date\"\ns[\"B67\"] = \"Quote 2\"\ns[\"D70\"] = \"Quote Attribution\"\ns[\"H70\"] = \"Quote Date\"\ns[\"B72\"] = \"Keywords\"\ns[\"B74\"] = \"Website\"\ns[\"B76\"] = \"Social media handles\"\ns[\"D76\"] = \"Twitter\"\ns[\"D78\"] = \"Facebook\"\ns[\"D80\"] = \"Instagram\"\ns[\"H76\"] = \"LinkedIn\"\ns[\"H78\"] = \"TikTok\"\ns[\"H80\"] = \"YouTube\"\ns[\"B82\"] = \"Image 1 filename\"\ns[\"D84\"] = \"Alt-Text\"\ns[\"D86\"] = \"Image Attribution\"\ns[\"D88\"] = \"Image Date\"\ns[\"D90\"] = \"Confirm permission to use image\"\ns[\"B92\"] = \"Image 2 filename\"\ns[\"D94\"] = \"Alt-Text\"\ns[\"D96\"] = \"Image Attribution\"\ns[\"D98\"] = \"Image Date\"\ns[\"D100\"] = \"Confirm permission to use image\"\n\ns[\"B103\"] = \"Penultimate category\"\ns[\"B105\"] = \"Competition Details\"\ns[\"D105\"] = \"Last year of entry\"\ns[\"D107\"] = \"Year of last win\"\ns[\"H105\"] = \"Categories of entry\"\ns[\"H107\"] = \"Categories of win\"\n\ns[\"B110\"] = \"Last category\"\ns[\"B112\"] = \"Use for Comms\"\ns[\"D112\"] = \"Comms Priority\"\ns[\"F112\"] = \"Comms End Date\"\n\nXLSX.setColumnWidth(s, 1:2:11; width=1.3)\nXLSX.setColumnWidth(s, 2:2:10; width=18)\nXLSX.setRowHeight(s, :; height=15)\nXLSX.setRowHeight(s, [3, 4, 19, 28, 29, 35, 39, 41, 42, 64, 69, 77, 79, 83, 85, 87, 89, 93, 95, 97, 99, 101, 102, 106, 108, 109, 116]; height=5.5)\nXLSX.setRowHeight(s, [5, 30, 43, 103, 110]; height=18)\nXLSX.setRowHeight(s, 2; height=23)\n\nXLSX.setFont(s, \"B2\"; size=18, bold=true)\nXLSX.setUniformFont(s, [5, 30, 43, 103, 110], 2; size=14, bold=true)\n\nXLSX.setUniformFill(s, [1, 2, 3, 4, 5, 6, 8, 10, 15, 17, 19, 21, 28, 29, 30, 31, 33, 35, 37, 39, 41, 42, 43, 44, 46, 48, 50, 52, 53, 54, 56, 57, 58, 59, 60, 61, 63, 64, 66, 68, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 102, 103, 104, 106, 108, 109, 110, 111, 115, 116], :; pattern=\"solid\", fgColor=\"lightgrey\")\nXLSX.setUniformFill(s, :, [1, 3, 5, 7, 9, 11]; pattern=\"solid\", fgColor=\"lightgrey\")\nXLSX.setFill(s, \"F7,H7,J7,J9,H11:J16,F14,F16:F20,H32:J32,B36,B40,F45,J47:J49,B65,B70,B78:B80,B84:B90,B94:B100,H88:J90,H98:J100,B107,F114,H112:J115\"; pattern=\"solid\", fgColor=\"lightgrey\")\nXLSX.setFill(s, \"D18,D20,J18,J20,D45\"; pattern=\"solid\", fgColor=\"darkgrey\")\nXLSX.setFill(s, \"B112:B114,D112:D115\"; pattern=\"solid\", fgColor=\"white\")\nXLSX.setFill(s, \"E90,E100,D115\"; pattern=\"none\")\n\nXLSX.mergeCells(s, \"D9:H9\")\nXLSX.mergeCells(s, \"D11:G11,D12:G12,D13:G13\")\nXLSX.mergeCells(s, \"D32:F32,D34:J34,D38:J38\")\nXLSX.mergeCells(s, \"D47:H47,D49:H49\")\nXLSX.mergeCells(s, \"D51:J53,D55:J60\")\nXLSX.mergeCells(s, \"D62:J63,D67:J68\")\nXLSX.mergeCells(s, \"D72:J72,D74:J74\")\nXLSX.mergeCells(s, \"D82:J82,F84:J84,F86:J86\")\nXLSX.mergeCells(s, \"D92:J92,F94:J94,F96:J96\")\n\nXLSX.setAlignment(s, \"D51:J53,D55:J60,D62:J63,D67:J68\"; vertical=\"top\", wrapText=true)\n\nXLSX.setBorder(s, \"A1:K3\"; outside = [\"style\" => \"medium\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"A4:K28\"; outside = [\"style\" => \"medium\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"A29:K41\"; outside = [\"style\" => \"medium\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"A42:K101\"; outside = [\"style\" => \"medium\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"A102:K108\"; outside = [\"style\" => \"medium\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"A109:K116\"; outside = [\"style\" => \"medium\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"B7:D7,B9:H9\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B11:G13,B14:D14,B16:D16\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B18:D18,B20:D20,H18:J18,H20:J20\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setUniformBorder(s, \"B22:J27\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"B32:F32\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B34:C34,D34:J34,D36:F36,H36:J36\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B38:C38,D38:J38,D40:F40,H40:J40\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"D34:J36,D38:J40\"; outside = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"B45:D45,H45:J45\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B47:H47,B49:H49\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B51:C51,B55:C55\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"D51:J53,D55:J60\"; outside = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"B62:C62,D65:F65,H65:J65\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B67:C67,D70:F70,H70:J70\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"D62:J63,D67:J68\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"D62:J65,D67:J70\"; outside = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"B72:J72,B74:J74\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"B76:F76,H76:J76,D78:F78,H78:J78,D80:F80,H80:J80\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"D76:J80\"; outside = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"B82:J82,D84:J84,D86:J86,D88:F88,D90:F90\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"D82:J90\"; outside = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B92:J92,D94:J94,D96:J96,D98:F98,D100:F100\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"D92:J100\"; outside = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"B105:F105,H105:J105,D107:F107,H107:J107\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"D105:J107\"; outside = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.setBorder(s, \"F112,F113\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\nXLSX.setBorder(s, \"B112:B114,D112:D115\"; outside = [\"style\" => \"thin\", \"color\" => \"black\"])\n\nXLSX.writexlsx(\"myNewTemplate.xlsx\", f, overwrite=true)","category":"page"},{"location":"api/data/#Cells-and-data","page":"Cells and data","title":"Cells and data","text":"","category":"section"},{"location":"api/data/#Cell-referencing","page":"Cells and data","title":"Cell referencing","text":"","category":"section"},{"location":"api/data/#XLSX.CellRef","page":"Cells and data","title":"XLSX.CellRef","text":"CellRef(n::AbstractString)\nCellRef(row::Int, col::Int)\n\nA CellRef represents a cell location given by row and column identifiers.\n\nCellRef(\"B6\") indicates a cell located at column 2 and row 6.\n\nThese row and column integers can also be passed directly to the CellRef constructor: CellRef(6,2) == CellRef(\"B6\").\n\nFinally, a convenience macro @ref_str is provided: ref\"B6\" == CellRef(\"B6\").\n\nExamples\n\ncn = XLSX.CellRef(\"AB1\")\nprintln( XLSX.row_number(cn) ) # will print 1\nprintln( XLSX.column_number(cn) ) # will print 28\nprintln( string(cn) ) # will print out AB1\n\ncn = XLSX.CellRef(1, 28)\nprintln( XLSX.row_number(cn) ) # will print 1\nprintln( XLSX.column_number(cn) ) # will print 28\nprintln( string(cn) ) # will print out AB1\n\ncn = XLSX.ref\"AB1\"\nprintln( XLSX.row_number(cn) ) # will print 1\nprintln( XLSX.column_number(cn) ) # will print 28\nprintln( string(cn) ) # will print out AB1\n\n\n\n\n\n","category":"type"},{"location":"api/data/#XLSX.row_number","page":"Cells and data","title":"XLSX.row_number","text":"row_number(c::CellRef) :: Int\n\nReturns the row number of a given cell reference.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.column_number","page":"Cells and data","title":"XLSX.column_number","text":"column_number(c::CellRef) :: Int\n\nReturns the column number of a given cell reference.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.eachrow","page":"Cells and data","title":"XLSX.eachrow","text":"eachrow(sheet)\n\nCreates a row iterator for a worksheet.\n\nExample: Query all cells from columns 1 to 4.\n\nleft = 1  # 1st column\nright = 4 # 4th column\nfor sheetrow in eachrow(sheet)\n    for column in left:right\n        cell = XLSX.getcell(sheetrow, column)\n\n        # do something with cell\n    end\nend\n\nNote: The eachrow row iterator will not return any row that  consists entirely of EmptyCells. These are simply not seen  by the iterator. The length(eachrow(sheet)) function therefore  defines the number of rows that are not entirely empty and will,  in any case, only succeed if the worksheet cache is in use.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.eachtablerow","page":"Cells and data","title":"XLSX.eachtablerow","text":"eachtablerow(sheet, [columns]; [first_row], [column_labels], [header], [stop_in_empty_row], [stop_in_row_function], [keep_empty_rows], [normalizenames]) -> TableRowIterator\n\nConstructs an iterator of table rows. Each element of the iterator is of type TableRow.\n\nheader is a boolean indicating whether the first row of the table is a table header.\n\nIf header == false and no column_labels were supplied, column names will be generated following the column names found in the Excel file.\n\nThe columns argument is a column range, as in \"B:E\". If columns is not supplied, the column range will be inferred by the non-empty contiguous cells in the first row of the table.\n\nThe user can replace column names by assigning the optional column_labels input variable with a Vector{Symbol}.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the end of the table. If stop_in_empty_row=false, the iterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is stop_in_empty_row=true. Empty rows may be returned by the iterator when stop_in_empty_row=false.\n\nstop_in_row_function is a Function that receives a TableRow and returns a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function:\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nkeep_empty_rows determines whether rows where all column values are equal to missing are kept (true) or skipped (false) by the row iterator. keep_empty_rows never affects the bounds of the iterator; the number of rows read from a sheet is only affected by first_row, stop_in_empty_row and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.\n\nnormalizenames controls whether column names will be \"normalized\" to valid Julia identifiers. By default, this is false. If normalizenames=true, then column names with spaces, or that start with numbers, will be adjusted with underscores to become  valid Julia identifiers. This is useful when you want to access columns via dot-access or getproperty, like file.col1. The  identifier that comes after the . must be valid, so spaces or identifiers starting with numbers aren't allowed. (Based ib CSV.jl's CSV.normalizename.)\n\nExample code:\n\nfor r in XLSX.eachtablerow(sheet)\n    # r is a `TableRow`. Values are read using column labels or numbers.\n    rn = XLSX.row_number(r) # `TableRow` row number.\n    v1 = r[1] # will read value at table column 1.\n    v2 = r[:COL_LABEL2] # will read value at column labeled `:COL_LABEL2`.\nend\n\nSee also XLSX.gettable.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#Cell-data","page":"Cells and data","title":"Cell data","text":"","category":"section"},{"location":"api/data/#XLSX.readdata","page":"Cells and data","title":"XLSX.readdata","text":"readdata(source, sheet, ref)\nreaddata(source, sheetref)\n\nReturn a scalar, vector or matrix with values from a spreadsheet file. 'ref' can be a defined name, a cell reference or a cell, column, row  or non-contiguous range.\n\nSee also XLSX.getdata.\n\nExamples\n\nThese function calls are equivalent.\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet\", \"A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", 1, \"A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet!A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\nNon-contiguous ranges return vectors of Array{Any, 2} with an entry for every non-contiguous (comma-separated)  element in the range.\n\njulia> XLSX.readdata(\"customXml.xlsx\", \"Mock-up\", \"Location\") # `Location` is a `definedName` for a non-contiguous range\n4-element Vector{Matrix{Any}}:\n [\"Here\";;]\n [missing;;]\n [missing;;]\n [missing;;]\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.getdata","page":"Cells and data","title":"XLSX.getdata","text":"getdata(sheet, ref)\ngetdata(sheet, row, column)\n\nReturns a scalar, matrix or a vector of matrices with values from  a spreadsheet.\n\nref can be a cell reference or a range or a valid defined name.\n\nIf ref is a single cell, a scalar is returned.\n\nMost ranges are rectangular and will return a 2-D matrix  (Array{AbstractCell, 2}). For row and column ranges, the  extent of the range in the other dimension is determined by  the worksheet's dimension.\n\nA non-contiguous range (which may not be rectangular) will return  a vector of Array{AbstractCell, 2} matrices with one element for  each non-contiguous (comma separated) element in the range.\n\nIndexing in a Worksheet will dispatch to getdata method.\n\nExample\n\njulia> f = XLSX.readxlsx(\"myfile.xlsx\")\n\njulia> sheet = f[\"mysheet\"] # Worksheet\n\njulia> matrix = sheet[\"A1:B4\"] # CellRange\n\njulia> matrix = sheet[\"A:B\"] # Column range\n\njulia> matrix = sheet[\"1:4\"] # Row range\n\njulia> matrix = sheet[\"Contiguous\"] # Named range\n\njulia> matrix = sheet[1:30, 1] # use unit ranges to define rows and/or columns\n\njulia> matrix = sheet[[1, 2, 3], 1] # vectors of integers to define rows and/or columns\n\njulia> vector = sheet[\"A1:A4,C1:C4,G5\"] # Non-contiguous range\n\njulia> vector = sheet[\"Location\"] # Non-contiguous named range\n\njulia> scalar = sheet[2, 2] # Cell \"B2\"\n\n\nSee also XLSX.readdata.\n\n\n\n\n\ngetdata(ws::Worksheet, cell::Cell) :: CellValue\n\nReturns a Julia representation of a given cell value. The result data type is chosen based on the value of the cell as well as its style.\n\nFor example, date is stored as integers inside the spreadsheet, and the style is the information that is taken into account to chose Date as the result type.\n\nFor numbers, if the style implies that the number is visualized with decimals, the method will return a float, even if the underlying number is stored as an integer inside the spreadsheet XML.\n\nIf cell has empty value or empty String, this function will return missing.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.getcell","page":"Cells and data","title":"XLSX.getcell","text":"getcell(xlsxfile, cell_reference_name) :: AbstractCell\ngetcell(worksheet, cell_reference_name) :: AbstractCell\ngetcell(sheetrow, column_name) :: AbstractCell\ngetcell(sheetrow, column_number) :: AbstractCell\n\nReturns the internal representation of a worksheet cell.\n\nReturns XLSX.EmptyCell if the cell has no data.\n\n\n\n\n\ngetcell(sheet, ref)\ngetcell(sheet, row, col)\n\nReturn an AbstractCell that represents a cell in the spreadsheet. Return a 2-D matrix as Array{AbstractCell, 2} if ref is a  rectangular range. For row and column ranges, the extent of the range in the other  dimension is determined by the worksheet's dimension. A non-contiguous range (which may not be rectangular) will return  a vector of Array{AbstractCell, 2} with one element for each  non-contiguous (comma separated) element in the range.\n\nIf ref is a range, getcell dispatches to getcellrange.\n\nExample:\n\njulia> xf = XLSX.readxlsx(\"myfile.xlsx\")\n\njulia> sheet = xf[\"mysheet\"]\n\njulia> cell = XLSX.getcell(sheet, \"A1\")\n\njulia> cell = XLSX.getcell(sheet, 1:3, [2,4,6])\n\n\nOther examples are as getdata().\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.getcellrange","page":"Cells and data","title":"XLSX.getcellrange","text":"getcellrange(sheet, rng)\n\nReturn a matrix with cells as Array{AbstractCell, 2}. rng must be a valid cell range, column range or row range, as in \"A1:B2\", \"A:B\" or \"1:2\", or a non-contiguous range. For row and column ranges, the extent of the range in the other  dimension is determined by the worksheet's dimension. A non-contiguous range (which may not be rectangular) will return  a vector of Array{AbstractCell, 2} with one element for each  non-contiguous (comma separated) element in the range.\n\nExample:\n\njulia> ncr = \"B3,A1,C2\" # non-contiguous range, \"out of order\".\n\"B3,A1,C2\"\n\njulia>  XLSX.getcellrange(f[1], ncr)\n3-element Vector{Matrix{XLSX.AbstractCell}}:\n [XLSX.Cell(B3, \"\", \"\", \"5\", XLSX.Formula(\"\", nothing));;]\n [XLSX.Cell(A1, \"\", \"\", \"2\", XLSX.Formula(\"\", nothing));;]\n [XLSX.Cell(C2, \"\", \"\", \"5\", XLSX.Formula(\"\", nothing));;]\n\n\nFor other examples, see getcell() and getdata().\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.gettable","page":"Cells and data","title":"XLSX.gettable","text":"gettable(\n    sheet,\n    [columns];\n    [first_row],\n    [column_labels],\n    [header],\n    [infer_eltypes],\n    [stop_in_empty_row],\n    [stop_in_row_function],\n    [keep_empty_rows],\n    [normalizenames]\n) -> DataTable\n\nReturns tabular data from a spreadsheet as a struct XLSX.DataTable. Use this function to create a DataFrame from package DataFrames.jl.\n\nUse columns argument to specify which columns to get. For example, \"B:D\" will select columns B, C and D. If columns is not given, the algorithm will find the first sequence of consecutive non-empty cells.\n\nUse first_row to indicate the first row from the table. first_row=5 will look for a table starting at sheet row 5. If first_row is not given, the algorithm will look for the first non-empty row in the spreadsheet.\n\nheader is a Bool indicating if the first row is a header. If header=true and column_labels is not specified, the column labels for the table will be read from the first row of the table. If header=false and column_labels is not specified, the algorithm will generate column labels. The default value is header=true.\n\nUse column_labels as a vector of symbols to specify names for the header of the table.\n\nUse normalizenames=true to normalize column names to valid Julia identifiers.\n\nUse infer_eltypes=true to get data as a Vector{Any} of typed vectors. The default value is infer_eltypes=true.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the end of the table. If stop_in_empty_row=false, the TableRowIterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is stop_in_empty_row=true.\n\nstop_in_row_function is a Function that receives a TableRow and returns a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nkeep_empty_rows determines whether rows where all column values are equal to missing are kept (true) or dropped (false) from the resulting table. keep_empty_rows never affects the bounds of the table; the number of rows read from a sheet is only affected by first_row, stop_in_empty_row and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.\n\nExample\n\njulia> using DataFrames, XLSX\n\njulia> df = XLSX.openxlsx(\"myfile.xlsx\") do xf\n        DataFrame(XLSX.gettable(xf[\"mysheet\"]))\n    end\n\nSee also: XLSX.readtable.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.readtable","page":"Cells and data","title":"XLSX.readtable","text":"readtable(\n    source,\n    [sheet,\n    [columns]];\n    [first_row],\n    [column_labels],\n    [header],\n    [infer_eltypes],\n    [stop_in_empty_row],\n    [stop_in_row_function],\n    [enable_cache],\n    [keep_empty_rows],\n    [normalizenames]\n) -> DataTable\n\nReturns tabular data from a spreadsheet as a struct XLSX.DataTable. Use this function to create a DataFrame from package DataFrames.jl  (or other Tables.jl` compatible object).\n\nIf sheet is not given, the first sheet in the XLSXFile will be used.\n\nUse columns argument to specify which columns to get. For example, \"B:D\" will select columns B, C and D. If columns is not given, the algorithm will find the first sequence of consecutive non-empty cells. A valid sheet must be specified  when specifying columns.\n\nUse first_row to indicate the first row of the table. first_row=5 will look for a table starting at sheet row 5. If first_row is not given, the algorithm will look for the first non-empty row in the spreadsheet.\n\nheader is a Bool indicating if the first row is a header. If header=true and column_labels is not specified, the column labels for the table will be read from the first row of the table. If header=false and column_labels is not specified, the algorithm will generate column labels. The default value is header=true.\n\nUse column_labels to specify names for the header of the table.\n\nUse normalizenames=true to normalize column names to valid Julia identifiers.\n\nUse infer_eltypes=true to get data as a Vector{Any} of typed vectors. The default value is infer_eltypes=true.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the  end of the table. If stop_in_empty_row=false, the TableRowIterator will  continue to fetch rows until there's no more rows in the Worksheet or range. The default behavior is stop_in_empty_row=true.\n\nstop_in_row_function is a Function that receives a TableRow and returns  a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function:\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nenable_cache is a boolean that determines whether cell data are loaded  into the worksheet cache on reading. The default behavior is enable_cache=true.\n\nkeep_empty_rows determines whether rows where all column values are equal  to missing are kept (true) or dropped (false) from the resulting table.  keep_empty_rows never affects the bounds of the table; the number of  rows read from a sheet is only affected by first_row, stop_in_empty_row  and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table  have been determined, to see whether to keep or drop empty rows between the  first and the last row. The default behavior is `keep_empty_rows=false.\n\nExample\n\njulia> using DataFrames, XLSX\n\njulia> df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\"))\n\nSee also: XLSX.gettable.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.readto","page":"Cells and data","title":"XLSX.readto","text":"readto(\n    source,\n    [sheet,\n    [columns]],\n    sink;\n    [first_row],\n    [column_labels],\n    [header],\n    [infer_eltypes],\n    [stop_in_empty_row],\n    [stop_in_row_function],\n    [enable_cache],\n    [keep_empty_rows],\n    [normalizenames]\n) -> sink\n\nRead and parse an Excel worksheet, materializing directly using  the sink function (e.g. DataFrame or StructArray).\n\nTakes the same keyword arguments as XLSX.readtable \n\nExample\n\njulia> using DataFrames, StructArrays, XLSX\n\njulia> df = XLSX.readto(\"myfile.xlsx\", DataFrame)\n\njulia> df = XLSX.readto(\"myfile.xlsx\", StructArray)\n\njulia> df = XLSX.readto(\"myfile.xlsx\", \"mysheet\", DataFrame)\n\njulia> df = XLSX.readto(\"myfile.xlsx\", \"mysheet\", \"A:C\", DataFrame)\n\nSee also: XLSX.gettable.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.writetable","page":"Cells and data","title":"XLSX.writetable","text":"writetable(filename, table; [overwrite], [sheetname])\n\nWrite a Tables.jl compatible table as an Excel file with the specified file name (and sheet name, if specified).\n\nIf a file with the given name already exists, writing will fail unless overwrite=true is specified, in which  case the existing file will be overwritten.\n\n\n\n\n\nwritetable(filename::Union{AbstractString, IO}, tables::Vector{Pair{String, T}}; overwrite::Bool=false)\nwritetable(filename::Union{AbstractString, IO}, tables::Pair{String, Any}...; overwrite::Bool=false)\n\n\n\n\n\nwritetable(filename, data, columnnames; [overwrite], [sheetname])\n\ndata is a vector of columns.\ncolumnames is a vector of column labels.\noverwrite is a Bool to control if filename should be overwritten if already exists.\nsheetname is the name for the worksheet.\n\nReturns the filepath of the written file if a filename is supplied, or nothing if writing to an IO.\n\nExample\n\nimport XLSX\ncolumns = [ [1, 2, 3, 4], [\"Hey\", \"You\", \"Out\", \"There\"], [10.2, 20.3, 30.4, 40.5] ]\ncolnames = [ \"integers\", \"strings\", \"floats\" ]\nXLSX.writetable(\"table.xlsx\", columns, colnames)\n\nSee also: XLSX.writetable!.\n\n\n\n\n\nwritetable(filename::Union{AbstractString, IO}; overwrite::Bool=false, kw...)\nwritetable(filename::Union{AbstractString, IO}, tables::Vector{Tuple{String, Vector{Any}, Vector{String}}}; overwrite::Bool=false)\n\nWrite multiple tables.\n\nkw is a variable keyword argument list. Each element should be in this format: sheetname=( data, column_names ), where data is a vector of columns and column_names is a vector of column labels.\n\nReturns the filepath of the written file if a filename is supplied, or nothing if writing to an IO.\n\nExample:\n\njulia> import DataFrames, XLSX\n\njulia> df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[\"Fist\", \"Sec\", \"Third\"])\n\njulia> df2 = DataFrames.DataFrame(AA=[\"aa\", \"bb\"], AB=[10.1, 10.2])\n\njulia> XLSX.writetable(\"report.xlsx\", \"REPORT_A\" => df1, \"REPORT_B\" => df2)\n\n\n\n\n\n","category":"function"},{"location":"api/data/#XLSX.writetable!","page":"Cells and data","title":"XLSX.writetable!","text":"writetable!(sheet::Worksheet, table; anchor_cell::CellRef=CellRef(\"A1\")))\n\nWrite a Tables.jl compatible table to the specified sheet starting with the  anchor cell (if given) in the top left.\n\n\n\n\n\nwritetable!(\n    sheet::Worksheet,\n    data,\n    columnnames;\n    anchor_cell::CellRef=CellRef(\"A1\"),\n    write_columnnames::Bool=true,\n)\n\nWrite tabular data data with labels given by columnnames to sheet, starting at anchor_cell.\n\ndata must be a vector of columns. columnnames must be a vector of column labels.\n\nColumn labels that are not of type String will be converted  to strings before writing. Any data columns that are not of  type String, Float64, Int64, Bool, Date, Time,  DateTime, Missing, or Nothing will be converted to strings  before writing.\n\nSee also: XLSX.writetable.\n\n\n\n\n\n","category":"function"},{"location":"api/data/#Defined-names","page":"Cells and data","title":"Defined names","text":"","category":"section"},{"location":"api/data/#XLSX.addDefinedName","page":"Cells and data","title":"XLSX.addDefinedName","text":"addDefinedName(xf::XLSXFile,  name::AbstractString, value::Union{Int, Float64, String}; absolute=true)\naddDefinedName(xf::XLSXFile,  name::AbstractString, value::AbstractString; absolute=true)\naddDefinedName(sh::Worksheet, name::AbstractString, value::Union{Int, Float64, String}; absolute=true)\naddDefinedName(sh::Worksheet, name::AbstractString, value::AbstractString; absolute=true)\n\nAdd a defined name to the Workbook or Worksheet. If an XLSXFile is passed, the defined name  is added to the Workbook. If a Worksheet is passed, the defined name is added to the Worksheet.\n\nWhen adding defined name referring to a cell or range to a workbook, value must include the sheet  name (e.g. Sheet1!A1:B2). \n\nIf the new definedName is a cell reference or range, by default, it will be an absolute  reference (e.g. $A$1:$C$6). If absolute=false is specified, the new definedName will be  a relative reference (e.g. A1:C6). Any absolute argument specified is ignored if the  definedName is not a cell reference or range.\n\nIn the context of XLSX.jl there is no difference between an absolute reference and a relative  reference. However, Excel treats them differently. When definedNames are read in as part of  an XLSXFile, we keep track of whether they are absolute or not. If the XLSXFile is subsequently  written out again, the status of the definedNames is preserved.\n\nExamples\n\njulia> XLSX.addDefinedName(sh, \"ID\", \"C21\")\n\njulia> XLSX.addDefinedName(sh, \"NEW\", \"A1:B2\")\n\njulia> XLSX.addDefinedName(sh, \"my_name\", \"A1,B2,C3\")\n\njulia> XLSX.addDefinedName(xf, \"New\", \"'Mock-up'!A1:B2\")\n\njulia> XLSX.addDefinedName(xf, \"Life_the_universe_and_everything\", 42)\n\njulia> XLSX.addDefinedName(xf, \"first_name\", \"Hello World\")\n\n\n\n\n\n\n","category":"function"},{"location":"formatting/cellFormatting/#Cell-formats","page":"Cell formats","title":"Cell formats","text":"","category":"section"},{"location":"formatting/cellFormatting/#Excel-formatting","page":"Cell formats","title":"Excel formatting","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Each cell in an Excel spreadsheet may refer to an Excel style. Multiple cells can  refer to the same style and therefore have a uniform appearance. A style defines the cell's alignment directly (as part of the style definition), but it may also  refer to further formatting definitions for font, fill, border, format.  Multiple styles may each refer to the same fill definition or the same font  definition, etc, and therefore share these formatting characteristics. This hierarchy can be shown like this:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"                `Cell`\n                  │\n               `Style` => `Alignment`\n                  │\n  ┌──────────┬────┴─────┬─────────┐\n  │          │          │         │\n`font`     `fill`    `border`  `format`","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"A family of setter functions is provided to set each of the formatting characteristics  Excel uses. These are applied to cells, and the functions deal with the relationships  between the individual characteristics, the overarching style and the cell(s) themselves.","category":"page"},{"location":"formatting/cellFormatting/#Setting-format-attributes-of-a-cell","page":"Cell formats","title":"Setting format attributes of a cell","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Set the font attributes of a cell using XLSX.setFont. For example, to set cells A1 and  A5 in the general sheet of a workbook to specific font values, use:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"\njulia> using XLSX\n\njulia> f=XLSX.opentemplate(\"general.xlsx\")\nXLSXFile(\"general.xlsx\") containing 13 Worksheets\n            sheetname size          range        \n-------------------------------------------------\n              general 10x6          A1:F10       \n               table3 5x6           A2:F6        \n               table4 4x3           E12:G15\n                table 12x8          A2:H13\n               table2 5x3           A1:C5\n                empty 1x1           A1:A1\n               table5 6x1           C3:C8\n               table6 8x2           B1:C8\n               table7 7x2           B2:C8\n               lookup 4x9           B2:J5\n         header_error 3x4           B2:E4\n       named_ranges_2 4x5           A1:E4\n         named_ranges 14x6          A2:F15\n\njulia> s=f[\"general\"]\n10×6 XLSX.Worksheet: [\"general\"](A1:F10)\n\njulia> XLSX.setFont(s, \"A1\"; name=\"Arial\", size=24, color=\"blue\", bold=true)\n2\n\njulia> XLSX.setFont(s, \"A5\"; name=\"Arial\", size=24, color=\"blue\", bold=true)\n2","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"The function returns the fontId that has been used to define this combination  of attributes.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"There are more font attributes that can be set. Setting attributes for a cell  that already has some, merges the new attributes with the old. Thus:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> XLSX.setFont(s, \"A5\"; italic=true, under=\"double\", bold=false)\n3","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"will over-ride the bold setting that was previously defined and add a double  underline and make the font italic. However, the color, font name and size will  all remain unchanged from before. This new combination of attributes is unique,  so a new fontId has been created.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Font colors (and colors in any of the other formatting functions) can be set using a  hex RGB value or by name using any of the colors provided by Colors.jl","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"The other set attribute functions behave in similar ways. See XLSX.setBorder,  XLSX.setFill, XLSX.setFormat and XLSX.setAlignment.","category":"page"},{"location":"formatting/cellFormatting/#Formatting-multiple-cells-at-once","page":"Cell formats","title":"Formatting multiple cells at once","text":"","category":"section"},{"location":"formatting/cellFormatting/#Applying-setAttribute-to-multiple-cells","page":"Cell formats","title":"Applying setAttribute to multiple cells","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Each of the setter functions can be applied to multiple cells at once using cell-ranges,  row- or column-ranges or non-contiguous ranges. Additionally, indexing can use integer indices for rows and columns, vectors of index values, unit- or step-ranges. This makes  it easy to apply formatting to many cells at once.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Thus, for example:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"\njulia> using XLSX\n\njulia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range        \n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1)\n\njulia> s[1:100, 1:100] = \"\" # Ensure these aren't `EmptyCell`s.\n\"\"\n\njulia> XLSX.setFont(s, \"A1:CV100\"; name=\"Arial\", size=24, color=\"blue\", bold=true)\n-1                          # Returns -1 on a range.\n\njulia> XLSX.setBorder(s, \"A1:CV100\"; allsides = [\"style\" => \"thin\", \"color\" => \"black\"])\n-1\n\njulia> XLSX.setAlignment(s, [10, 50, 90], 1:100; wrapText=true) # Wrap text in the specified rows.\n-1\n\njulia>  XLSX.setAlignment(s, 1:100, 2:2:100; rotation=90) # Rotate text 90° every second column in the first 100 rows.\n-1","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"It is even possible to use defined names to index these functions:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"\njulia> XLSX.addDefinedName(s, \"my_name\", \"A1,B20,C30\") # Define a non-contiguous named range.\nXLSX.DefinedNameValue(Sheet1!A1,Sheet1!B20,Sheet1!C30, Bool[1, 1, 1])\n\njulia> XLSX.setFill(s, \"my_name\"; pattern=\"solid\", fgColor=\"coral\")\n-1","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"When setting format attributes over a range of cells as decribed, the new attributes are merged  with existing on a cell by cell basis. If you set the font name on a range of cells that previously  all had different font colors, the color differences will persist even as the font name is applied  to the range consistently.","category":"page"},{"location":"formatting/cellFormatting/#Setting-uniform-attributes","page":"Cell formats","title":"Setting uniform attributes","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Sometimes it is useful to be able to apply a fully consistent set of format attributes to a range of  cells, over-riding any pre-existing differences. This is the purpose of the setUniformAttribute  family of functions. These functions update the attributes of the first cell in the range and then  apply the relevant attribute Id to the rest of the cells in the range. Thus:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> XLSX.setUniformBorder(s, \"A1:CV100\"; allsides = [\"color\" => \"green\"], diagonal = [\"direction\"=>\"both\", \"color\"=>\"red\"])\n2 # This is the `borderId` that has now been uniformly applied to every cell.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"This sets the border color in cell A1 to be green and adds red diagonal lines across the cell.  It then applies all the Border attributes of cell A1 uniformly to all the other cells in the range,  overriding their previous attributes.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"All the format setter functions have setUniformAttribute versions, too. See XLSX.setUniformBorder,  XLSX.setUniformFill, XLSX.setUniformFormat and XLSX.setUniformAlignment.","category":"page"},{"location":"formatting/cellFormatting/#Setting-uniform-styles","page":"Cell formats","title":"Setting uniform styles","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"It is possible to use each of the setUniformAttribute functions in turn to ensure every possible  attribute is consistently applied to a range of cells. However, if perfect uniformity is required,  then setUniformStyle is considerably more efficient. It will simply take the styleId of the  first cell in the range and apply it uniformly to each cell in the range. This ensures that all  of font, fill, border, format, and alignment are all completely consistent across the range:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> XLSX.setUniformStyle(s, \"A1:CV100\") # set all formatting attributes to be uniformly the same as cell A1.\n7    # this is the `styleId` that has now been applied to all cells in the range","category":"page"},{"location":"formatting/cellFormatting/#Illustrating-the-different-approaches","page":"Cell formats","title":"Illustrating the different approaches","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"To illustrate the differences between applying setAttribute, setUniformAttribute and setUinformStyle, consider the following worksheet, which has very hetrogeneous formatting across the three cells:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"We can apply setBorder() to add a top border to each cell:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> XLSX.setBorder(s, \"B2,D2,F2\"; top=[\"style\"=>\"thick\", \"color\"=>\"red\"])\n-1","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"This merges the new top border definition with the other, existing border attributes, to get","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Alternatively, we can apply setUniformBorder(), which will update the borders of cell B2  and then apply all the border attributes of B2 to the other cells, overwriting the previous  settings:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> XLSX.setUniformBorder(s, \"B2,D2,F2\"; top=[\"style\"=>\"thick\", \"color\"=>\"red\"])\n4","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"This makes the border formatting entirely consistent across the cells but leaves the other formatting  attributes (font, fill, format, alignment) as they were.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Finally, we can set B2 to have the formatting we want, and then apply a uniform style to all three cells.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> XLSX.setBorder(s, \"B2\"; top=[\"style\"=>\"thick\", \"color\"=>\"red\"])\n4\n\njulia> XLSX.setUniformStyle(s, \"B2,D2,F2\")\n19","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Which results in all formatting attributes being entirely consistent across the cells.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/#Performance-differences-between-methods","page":"Cell formats","title":"Performance differences between methods","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"To illustrtate the relative performance of these three methods, applied to a million cells:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"using XLSX\nfunction setup()\n    f = XLSX.newxlsx()\n    s = f[1]\n    s[1:1000, 1:1000] = pi\n    return f\nend\ndo_format(f) = XLSX.setFormat(f[1], 1:1000, 1:1000; format=\"0.0000\")\ndo_uniform_format(f) = XLSX.setUniformFormat(f[1], 1:1000, 1:1000; format=\"0.0000\")\nfunction do_format_styles(f)\n    XLSX.setFormat(f[1], \"A1\"; format=\"0.0000\")\n    XLSX.setUniformStyle(f[1], 1:1000, 1:1000)\nend\nfunction timeit()\n    f = setup()\n    do_format(f)\n    do_uniform_format(f)\n    do_format_styles(f)\n    f = setup()\n    print(\"Using `setFormat`        : \")\n    @time do_format(f)\n    f = setup()\n    print(\"Using `setUniformFormat` : \")\n    @time do_uniform_format(f)\n    f = setup()\n    print(\"Using `setUniformStyle` : \")\n    @time do_format_styles(f)\n    return f\nend\nf=timeit()","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"which yields the following timings:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Using `setFormat`        :  10.966803 seconds (256.00 M allocations: 19.771 GiB, 18.81% gc time)\nUsing `setUniformFormat` :   2.222868 seconds (31.00 M allocations: 1.137 GiB, 19.48% gc time)\nUsing `setUniformStyles` :   0.519658 seconds (14.00 M allocations: 416.587 MiB)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"The same test, using the more involved setBorder function","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"do_format(f) = XLSX.setBorder(f[1], 1:1000, 1:1000;\n        left     = [\"style\" => \"dotted\", \"color\" => \"FF000FF0\"],\n        right    = [\"style\" => \"medium\", \"color\" => \"firebrick2\"],\n        top      = [\"style\" => \"thick\",  \"color\" => \"FF230000\"],\n        bottom   = [\"style\" => \"medium\", \"color\" => \"goldenrod3\"],\n        diagonal = [\"style\" => \"dotted\", \"color\" => \"FF00D4D4\", \"direction\" => \"both\"]\n    )","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"gives","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Using `setBorder`        :  29.536010 seconds (759.00 M allocations: 64.286 GiB, 22.01% gc time)\nUsing `setUniformBorder` :   2.052018 seconds (31.00 M allocations: 1.197 GiB, 13.18% gc time)\nUsing `setUniformStyles` :   0.599491 seconds (14.00 M allocations: 416.586 MiB, 15.20% gc time)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"If maintaining heterogeneous formatting attributes is not important, it is more efficient to  apply setUinformAttribute functions rather than setAttribute functions, especially on large  cell ranges, and more efficient still to use setUniformStyle.","category":"page"},{"location":"formatting/cellFormatting/#Copying-formatting-attributes","page":"Cell formats","title":"Copying formatting attributes","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"It is possible to use non-contiguous ranges to copy format attributes from any cell to any other cells,  whether you are also updating the source cell's format or not.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> XLSX.setBorder(s, \"BB50\"; allsides = [\"style\" => \"medium\", \"color\" => \"yellow\"])\n3 # Cell BB50 now has the border format I want!\n\njulia> XLSX.setUniformBorder(s, \"BB50,A1:CV100\") # Make cell BB50 the first (reference) cell in a non-contiguous range.\n3\n\njulia> XLSX.setUniformStyle(s, \"BB50,A1:CV100\") # Or if I want to apply all formatting attributes from BB50 to the range.\n11","category":"page"},{"location":"formatting/cellFormatting/#Rich-text-formats","page":"Cell formats","title":"Rich text formats","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Text in a cell can have font formats applied to any substring element as in this example:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"This is referred to here as rich text formatting.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"These rich text formats are stored separately from the cell Style and over-ride any Style-based formatting.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"The setFont, setUniformFont and setUniformStyle functions operate at the cell level and cannot appply  formatting at a substring level. Instead, using any of these functions will remove from a cell's rich text format  any attributes that these functions are themselves applying or updating to the whole cell, but will leave the remaining  rich text format attributes in place.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"For example, to remove the underlining in column B:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> setFont(s, \"B\"; under=\"none\")\n-1","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"The underlining has been removed, but the other rich text formats remain in place.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Applying setUniformFont to a range of cells will remove those elements of the rich text format that are now being applied  to the whole cell so that those elements become uniform. Any other heterogeneity arising from rich text formats  (which over-ride Style-based formatting) will remain. For example:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> setUniformFont(s, \"A1:F2\"; color=\"orange\")\n23","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Similarly, applying setUniformStyle to a range of cells will remove those elements of the rich text format that are now being applied to the whole cells so that those elements become uniform. Any other heterogeneity arising from rich text formats will remain.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Rich text formats only affect the font settings; other elements of the style (number format, borders, fill, alignment) will be unaffected and will be applied uniformly to the range.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"To illustrate, starting from the initial Excel file above, and using setUniformStyle to apply the Style in cell A1 to the cells D1:F2:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> setFont(s, \"A1\"; size=20) # make sure cell A1 has the formatting we want\n22\n\njulia> XLSX.getFont(s, \"A1\") # just to illustrate the cell A1 Style's font attributes\nXLSX.CellFont(22, Dict{String, Union{Nothing, Dict{String, String}}}(\"name\" => Dict(\"val\" => \"Aptos Narrow\"), \"sz\" => Dict(\"val\" => \"20\"), \"color\" => Dict(\"theme\" => \"1\")), \"1\")\n\njulia> setUniformStyle(s, \"A1,D1:F2\") # apply cell A1's Style to cells D1:F2\n1","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"The Style for cell A1 has a specified font, size and color. These have been uniformly applied to the range D1:F2, but the other rich text attributes (in this case, bold, italic, underline, super- and sub-script) retain the original heterogeneity.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"If the first cell in the specified range has no defined Style (s=\"\"), all cells will be given the same undefined style and any rich text formatting will remain unchanged.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"In Excel, subscript and superscript formatting to a substring (for example) can only be made using this kind of rich text formatting, and cannot be set at cell level (neither in Excel nor in setFont). Retaining rich text format heterogeneity in the ways described here preserves these string formatting elements through format changes.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"To clear any rich text formatting and remove the heterogeneity it introduces, simply copy the cells over themselves. This strips out all formatting and style information from the cells, leaving only the cell content. For example, for arbitrary cells:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> for row=1:2, col=1:6; s[row,col] = s[row,col]; end","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"or, for tabular data:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> writetable!(s, gettable(s, \"A:F\"; header=false); write_columnnames=false)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"(Image: image|320x500)","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"An XLSXFile must be opened in write mode for rich text formatting to be editable, otherwise an error is thrown.","category":"page"},{"location":"formatting/cellFormatting/#Setting-column-width-and-row-height","page":"Cell formats","title":"Setting column width and row height","text":"","category":"section"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Two functions offer the ability to set the column width and row height within a worksheet. These can use  all of the indexing options described above. For example:","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"julia> XLSX.setRowHeight(s, \"A2:A5\"; height=25)  # Rows 2 to 5 (columns ignored)\n\njulia> XLSX.setColumnWidth(s, 5:5:100; width=50) # Every 5th column up to column 100.","category":"page"},{"location":"formatting/cellFormatting/","page":"Cell formats","title":"Cell formats","text":"Excel applies some padding to user specified widths and heights. The two functions described here attempt  to do something similar but it is not an exact match to what Excel does. User specified row heights and  column widths will therefore differ by a small amount from the values you would see setting the same  widths in Excel itself.","category":"page"},{"location":"api/formats/#Cells-and-data","page":"Formats","title":"Cells and data","text":"","category":"section"},{"location":"api/formats/#Cell-format","page":"Formats","title":"Cell format","text":"","category":"section"},{"location":"api/formats/#XLSX.setFormat","page":"Formats","title":"XLSX.setFormat","text":"setFormat(sh::Worksheet, cr::String; kw...) -> ::Int\nsetFormat(xf::XLSXFile,  cr::String; kw...) -> ::Int\n\nsetFormat(sh::Worksheet, row, col; kw...) -> ::Int\n\nSet the number format used used by a single cell, a cell range, a column  range or row range or a named cell or named range in a worksheet or  XLSXfile. Alternatively, specify the row and column using any combination  of Integer, UnitRange, Vector{Integer} or :.\n\nThe function uses one keyword used to define a format:\n\nformat::String = nothing : Defines a built-in or custom number format\n\nThe format keyword can define some built-in formats by name:\n\nGeneral    : specifies internal format ID  0 (General)\nNumber     : specifies internal format ID  2 (0.00)\nCurrency   : specifies internal format ID  7 ($#,##0.00_);($#,##0.00))\nPercentage : specifies internal format ID  9 (0%)\nShortDate  : specifies internal format ID 14 (m/d/yyyy)\nLongDate   : specifies internal format ID 15 (d-mmm-yy)\nTime       : specifies internal format ID 21 (h:mm:ss)\nScientific : specifies internal format ID 48 (##0.0E+0)\n\nIf Currency is specified, Excel will use the appropriate local currency symbol.\n\nAlternatively, format can be used to specify any custom format directly.  Only weak checks are made of custom formats specified - they are otherwise added  to the XLSXfile verbatim.\n\nFormats may need characters that must be escaped when specified (see third  example, below).\n\nExamples:\n\njulia> XLSX.setFormat(sh, \"D2\"; format = \"h:mm AM/PM\")\n\njulia> XLSX.setFormat(xf, \"Sheet1!A2\"; format = \"# ??/??\")\n\njulia> XLSX.setFormat(sh, \"F1:F5\"; format = \"Currency\")\n\njulia> XLSX.setFormat(sh, \"named_range\"; format = \"Percentage\")\n\njulia> XLSX.setFormat(sh, \"A2\"; format = \"_-£* #,##0.00_-;-£* #,##0.00_-;_-£* \\\"-\\\"??_-;_-@_-\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setUniformFormat","page":"Formats","title":"XLSX.setUniformFormat","text":"setUniformFormat(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformFormat(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nsetUniformFormat(sh::Worksheet, rows, cols; kw...) -> ::Int\n\nSet the number format used by a cell range, a column range or row range or a  named range in a worksheet or XLSXfile to be to be uniformly the same format. Alternatively, specify the rows and columns using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nFirst, the number format of the first cell in the range (the top-left cell) is updated according to the given kw... (using setFormat()). The resultant format is  then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform number format.\n\nThis is functionally equivalent to applying setFormat() to each cell in the range  but may be very marginally more efficient.\n\nApplying setUniformFormat() without any keyword arguments simply copies the Format  attributes from the first cell specified to all the others.\n\nThe value returned is the numfmtId of the format uniformly applied to the cells. If all cells in the range are EmptyCells, the returned value is -1.\n\nFor keyword definitions see setFormat().\n\nExamples:\n\njulia> XLSX.setUniformFormat(xf, \"Sheet1!A2:L6\"; format = \"# ??/??\")\n\njulia> XLSX.setUniformFormat(sh, \"F1:F5\"; format = \"Currency\")\n\njulia> setUniformFormat(sh, \"B2,A5:D22\")                   # Copy `Format` from B2 to cells in A5:D22\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setFont","page":"Formats","title":"XLSX.setFont","text":"setFont(sh::Worksheet, cr::String; kw...) -> ::Int\nsetFont(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nsetFont(sh::Worksheet, row, col; kw...) -> ::Int\n\nSet the font used by a single cell, a cell range, a column range or  row range or a named cell or named range in a worksheet or XLSXfile. Alternatively, specify the row and column using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nFont attributes are specified using keyword arguments:\n\nbold::Bool = nothing    : set to true to make the font bold.\nitalic::Bool = nothing  : set to true to make the font italic.\nunder::String = nothing : set to single, double or none.\nstrike::Bool = nothing  : set to true to strike through the font.\nsize::Int = nothing     : set the font size (0 < size < 410).\ncolor::String = nothing : set the font color.\nname::String = nothing  : set the font name.\n\nOnly the attributes specified will be changed. If an attribute is not specified, the current value will be retained. These are the only attributes supported currently.\n\nNo validation of the font names specified is performed. Available fonts will depend on what your system has installed. If you specify, for example, name = \"badFont\", that value will be written to the XLSXFile.\n\nAs an expedient to get fonts to work, the scheme attribute is simply dropped from new font definitions.\n\nThe color attribute can be defined using 8-digit rgb values.\n\nThe first two digits represent transparency (α). Excel ignores transparency.\nThe next two digits give the red component.\nThe next two digits give the green component.\nThe next two digits give the blue component.\n\nSo, FF000000 means a fully opaque black color.\n\nAlternatively, you can use the name of any named color from Colors.jl (here).\n\nFont attributes cannot be set for EmptyCells. Set a cell value first. If a cell range or column range includes any EmptyCells, they will be quietly skipped and the font will be set for the remaining cells.\n\nFor single cells, the value returned is the fontId of the font applied to the cell. This can be used to apply the same font to other cells or ranges.\n\nFor cell ranges, column ranges and named ranges, the value returned is -1.\n\nExamples:\n\njulia> setFont(sh, \"A1\"; bold=true, italic=true, size=12, name=\"Arial\")          # Single cell\n\njulia> setFont(xf, \"Sheet1!A1\"; bold=false, size=14, color=\"yellow\")             # Single cell\n\njulia> setFont(sh, \"A1:B7\"; name=\"Aptos\", under=\"double\", strike=true)           # Cell range\n\njulia> setFont(xf, \"Sheet1!A1:B7\"; size=24, name=\"Berlin Sans FB Demi\")          # Cell range\n\njulia> setFont(sh, \"A:B\"; italic=true, color=\"green\", under=\"single\")            # Column range\n\njulia> setFont(xf, \"Sheet1!A:B\"; italic=true, color=\"red\", under=\"single\")       # Column range\n\njulia> setFont(xf, \"Sheet1!6:12\"; italic=false, color=\"FF8888FF\", under=\"none\")  # Row range\n\njulia> setFont(sh, \"bigred\"; size=48, color=\"FF00FF00\")                          # Named cell or range\n\njulia> setFont(xf, \"bigred\"; size=48, color=\"magenta\")                           # Named cell or range\n\njulia> setFont(sh, 1, 2; size=48, color=\"magenta\")                               # row and column as integers\n\njulia> setFont(sh, 1:3, 2; size=48, color=\"magenta\")                             # row as unit range\n\njulia> setFont(sh, 6, [2, 3, 8, 12]; size=48, color=\"magenta\")                   # column as vector of indices\n\njulia> setFont(sh, :, 2:6; size=48, color=\"lightskyblue2\")                       # all rows, columns 2 to 6\n\n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setUniformFont","page":"Formats","title":"XLSX.setUniformFont","text":"setUniformFont(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformFont(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nsetUniformFont(sh::Worksheet, rows, cols; kw...) -> ::Int\n\nSet the font used by a cell range, a column range or row range or  a named range in a worksheet or XLSXfile to be uniformly the same font. Alternatively, specify the rows and columns using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nFirst, the font attributes of the first cell in the range (the top-left cell) are updated according to the given kw... (using setFont()). The resultant font is  then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform font setting.\n\nThis differs from setFont() which merges the attributes defined by kw... into  the font definition used by each cell individually. For example, if you set the  font size to 12 for a range of cells, but these cells all use different fonts names  or colors, etc, setFont() will change the font size but leave the font name and  color unchanged for each cell individually. \n\nIn contrast, setUniformFont() will set the font size to 12 for the first cell, but  will then apply all the font attributes from the updated first cell (ie. name, color,  etc) to all the other cells in the range.\n\nThis can be more efficient when setting the same font for a large number of cells.\n\nApplying setUniformFont() without any keyword arguments simply copies the Font  attributes from the first cell specified to all the others.\n\nThe value returned is the fontId of the font uniformly applied to the cells. If all cells in the range are EmptyCells the returned value is -1.\n\nFor keyword definitions see setFont().\n\nExamples:\n\njulia> setUniformFont(sh, \"A1:B7\"; bold=true, italic=true, size=12, name=\"Arial\")       # Cell range\n\njulia> setUniformFont(xf, \"Sheet1!A1:B7\"; size=24, name=\"Berlin Sans FB Demi\")          # Cell range\n\njulia> setUniformFont(sh, \"A:B\"; italic=true, color=\"FF8888FF\", under=\"single\")         # Column range\n\njulia> setUniformFont(xf, \"Sheet1!A:B\"; italic=true, color=\"FF8888FF\", under=\"single\")  # Column range\n\njulia> setUniformFont(sh, \"33\"; italic=true, color=\"FF8888FF\", under=\"single\")          # Row\n\njulia> setUniformFont(sh, \"bigred\"; size=48, color=\"FF00FF00\")                          # Named range\n\njulia> setUniformFont(sh, 1, [2, 4, 6]; size=48, color=\"lightskyblue2\")                 # vector of column indices\n\njulia> setUniformFont(sh, \"B2,A5:D22\")                                                  # Copy `Font` from B2 to cells in A5:D22\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setBorder","page":"Formats","title":"XLSX.setBorder","text":"setBorder(sh::Worksheet, cr::String; kw...) -> ::Int\nsetBorder(xf::XLSXFile, cr::String; kw...) -> ::Int\n\nsetBorder(sh::Worksheet, row, col; kw...) -> ::Int\n\nSet the borders used used by a single cell, a cell range, a column range or  row range or a named cell or named range in a worksheet or XLSXfile. Alternatively, specify the row and column using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nBorders are independently defined for the keywords:\n\nleft::Vector{Pair{String,String}} = nothing\nright::Vector{Pair{String,String}} = nothing\ntop::Vector{Pair{String,String}} = nothing\nbottom::Vector{Pair{String,String}} = nothing\ndiagonal::Vector{Pair{String,String}} = nothing\n[allsides::Vector{Pair{String,String}} = nothing]\n[outside::Vector{Pair{String,String}} = nothing]\n\nThese represent each of the sides of a cell . The keyword diagonal defines  diagonal lines running across the cell. These lines must share the same style  and color in any cell.\n\nAn additional keyword, allsides, is provided for convenience. It can be used  in place of the four side keywords to apply the same border setting to all four  sides at once. It cannot be used in conjunction with any of the side-specific  keywords or with outside but it can be used together with diagonal.\n\nA further keyword, outside, can be used to set the outside border around a  range. Any internal borders will remain unchanged. An outside border cannot be  set for any non-contiguous/non-rectangular range, cannot be indexed with  vectors and cannot be used in conjunction with any other keywords.\n\nThe two attributes that can be set for each keyword are style and color. Additionally, for diagonal borders, a third keyword, direction can be used.\n\nAllowed values for style are:\n\nnone\nthin\nmedium\ndashed\ndotted\nthick\ndouble\nhair\nmediumDashed\ndashDot\nmediumDashDot\ndashDotDot\nmediumDashDotDot\nslantDashDot\n\nThe color attribute can be set by specifying an 8-digit hexadecimal value  in the format \"FFRRGGBB\". The transparency (\"FF\") is ignored by Excel but  is required. Alternatively, you can use the name of any named color from Colors.jl (here).\n\nValid values for the direction keyword (for diagonal borders) are:\n\nup   : diagonal border runs bottom-left to top-right\ndown : diagonal border runs top-left to bottom-right\nboth : diagonal borders run both ways\n\nBoth diagonal borders share the same style and color.\n\nSetting only one of the attributes leaves the other attributes unchanged for that  side's border. Omitting one of the keywords leaves the border definition for that side unchanged, only updating the other, specified sides.\n\nBorder attributes cannot be set for EmptyCells. Set a cell value first. If a cell range or column range includes any EmptyCells, they will be quietly skipped and the border will be set for the remaining cells.\n\nFor single cells, the value returned is the borderId of the borders applied to the cell. This can be used to apply the same borders to other cells or ranges.\n\nFor cell ranges, column ranges and named ranges, the value returned is -1.\n\nExamples:\n\nJulia> setBorder(sh, \"D6\"; allsides = [\"style\" => \"thick\"], diagonal = [\"style\" => \"hair\", \"direction\" => \"up\"])\n\nJulia> setBorder(sh, 2:45, 2:12; outside = [\"style\" => \"thick\", \"color\" => \"lightskyblue2\"])\n\nJulia> setBorder(xf, \"Sheet1!D4\"; left     = [\"style\" => \"dotted\", \"color\" => \"FF000FF0\"],\n                                  right    = [\"style\" => \"medium\", \"color\" => \"firebrick2\"],\n                                  top      = [\"style\" => \"thick\",  \"color\" => \"FF230000\"],\n                                  bottom   = [\"style\" => \"medium\", \"color\" => \"goldenrod3\"],\n                                  diagonal = [\"style\" => \"dotted\", \"color\" => \"FF00D4D4\", \"direction\" => \"both\"]\n                                  )\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setUniformBorder","page":"Formats","title":"XLSX.setUniformBorder","text":"setUniformBorder(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformBorder(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nsetUniformBorder(sh::Worksheet, rows, cols; kw...) -> ::Int\n\nSet the border used by a cell range, a column range or row range or  a named range in a worksheet or XLSXfile to be uniformly the same border. Alternatively, specify the rows and columns using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nFirst, the border attributes of the first cell in the range (the top-left cell) are updated according to the given kw... (using setBorder()). The resultant border is  then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform border setting.\n\nThis differs from setBorder() which merges the attributes defined by kw... into  the border definition used by each cell individually. For example, if you set the  border style to thin for a range of cells, but these cells all use different border  colors, setBorder() will change the border style but leave the border color unchanged  for each cell individually. \n\nIn contrast, setUniformBorder() will set the border style to thin for the first cell, but will then apply all the border attributes from the updated first cell (ie. both style  and color) to all the other cells in the range.\n\nThis can be more efficient when setting the same border for a large number of cells.\n\nApplying setUniformBorder() without any keyword arguments simply copies the Border  attributes from the first cell specified to all the others.\n\nThe value returned is the borderId of the border uniformly applied to the cells. If all cells in the range are EmptyCells the returned value is -1.\n\nFor keyword definitions see setBorder().\n\nNote: setUniformBorder cannot be used with the outside keyword.\n\nExamples:\n\nJulia> setUniformBorder(sh, \"B2:D6\"; allsides = [\"style\" => \"thick\"], diagonal = [\"style\" => \"hair\"])\n\nJulia> setUniformBorder(sh, [1, 2, 3], [3, 5, 9]; allsides = [\"style\" => \"thick\"], diagonal = [\"style\" => \"hair\", \"color\" => \"yellow2\"])\n\nJulia> setUniformBorder(xf, \"Sheet1!A1:F20\"; left     = [\"style\" => \"dotted\", \"color\" => \"FF000FF0\"],\n                                             right    = [\"style\" => \"medium\", \"color\" => \"FF765000\"],\n                                             top      = [\"style\" => \"thick\",  \"color\" => \"FF230000\"],\n                                             bottom   = [\"style\" => \"medium\", \"color\" => \"FF0000FF\"],\n                                             diagonal = [\"style\" => \"none\"]\n                                             )\n                                             \njulia> setUniformBorder(sh, \"B2,A5:D22\")     # Copy `Border` from B2 to cells in A5:D22\n\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setFill","page":"Formats","title":"XLSX.setFill","text":"setFill(sh::Worksheet, cr::String; kw...) -> ::Int\nsetFill(xf::XLSXFile,  cr::String; kw...) -> ::Int\n\nsetFill(sh::Worksheet, row, col; kw...) -> ::Int\n\nSet the fill used used by a single cell, a cell range, a column range or  row range or a named cell or named range in a worksheet or XLSXfile. Alternatively, specify the row and column using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nThe following keywords are used to define a fill:\n\npattern::String = nothing   : Sets the patternType for the fill.\nfgColor::String = nothing   : Sets the foreground color for the fill.\nbgColor::String = nothing   : Sets the background color for the fill.\n\nHere is a list of the available pattern values (thanks to Copilot!):\n\nnone\nsolid\nmediumGray\ndarkGray\nlightGray\ndarkHorizontal\ndarkVertical\ndarkDown\ndarkUp\ndarkGrid\ndarkTrellis\nlightHorizontal\nlightVertical\nlightDown\nlightUp\nlightGrid\nlightTrellis\ngray125\ngray0625\n\nThe two colors may be set by specifying an 8-digit hexadecimal value for the fgColor and/or bgColor keywords.  Alternatively, you can use the name of any named color from Colors.jl (here).\n\nSetting only one or two of the attributes leaves the other attribute(s) unchanged  for that cell's fill.\n\nFill attributes cannot be set for EmptyCells. Set a cell value first. If a cell range or column range includes any EmptyCells, they will be quietly skipped and the fill will be set for the remaining cells.\n\nFor single cells, the value returned is the fillId of the fill applied to the cell. This can be used to apply the same fill to other cells or ranges.\n\nFor cell ranges, column ranges and named ranges, the value returned is -1.\n\nExamples:\n\nJulia> setFill(sh, \"B2\"; pattern=\"gray125\", bgColor = \"FF000000\")\n\nJulia> setFill(xf, \"Sheet1!A1:F20\"; pattern=\"none\", fgColor = \"darkseagreen3\")\n \nJulia> setFill(sh, \"11:24\"; pattern=\"none\", fgColor = \"yellow2\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setUniformFill","page":"Formats","title":"XLSX.setUniformFill","text":"setUniformFill(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformFill(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nsetUniformFill(sh::Worksheet, rows, cols; kw...) -> ::Int\n\nSet the fill used by a cell range, a column range or row range or a  named range in a worksheet or XLSXfile to be uniformly the same fill. Alternatively, specify the rows and columns using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nFirst, the fill attributes of the first cell in the range (the top-left cell) are updated according to the given kw... (using setFill()). The resultant fill is  then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform fill setting.\n\nThis differs from setFill() which merges the attributes defined by kw... into  the fill definition used by each cell individually. For example, if you set the  fill patern to darkGrid for a range of cells, but these cells all use different fill   colors, setFill() will change the fill pattern but leave the fill color unchanged  for each cell individually. \n\nIn contrast, setUniformFill() will set the fill pattern to darkGrid for the first cell, but will then apply all the fill attributes from the updated first cell (ie. pattern  and both foreground and background colors) to all the other cells in the range.\n\nThis can be more efficient when setting the same fill for a large number of cells.\n\nApplying setUniformFill() without any keyword arguments simply copies the Fill  attributes from the first cell specified to all the others.\n\nThe value returned is the fillId of the fill uniformly applied to the cells. If all cells in the range are EmptyCells the returned value is -1.\n\nFor keyword definitions see setFill().\n\nExamples:\n\nJulia> setUniformFill(sh, \"B2:D4\"; pattern=\"gray125\", bgColor = \"FF000000\")\n\nJulia> setUniformFill(xf, \"Sheet1!A1:F20\"; pattern=\"none\", fgColor = \"darkseagreen3\")\n\njulia> setUniformFill(sh, \"B2,A5:D22\")               # Copy `Fill` from B2 to cells in A5:D22\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setAlignment","page":"Formats","title":"XLSX.setAlignment","text":"setAlignment(sh::Worksheet, cr::String; kw...) -> ::Int}\nsetAlignment(xf::XLSXFile,  cr::String; kw...) -> ::Int}\n\nsetAlignment(sh::Worksheet, row, col; kw...) -> ::Int}\n\nSet the alignment used used by a single cell, a cell range, a column range or  row range or a named cell or named range in a worksheet or XLSXfile. Alternatively, specify the row and column using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nThe following keywords are used to define an alignment:\n\nhorizontal::String = nothing : Sets the horizontal alignment.\nvertical::String = nothing   : Sets the vertical alignment.\nwrapText::Bool = nothing     : Determines whether the cell content wraps within the cell.\nshrink::Bool = nothing       : Indicates whether the text should shrink to fit the cell.\nindent::Int = nothing        : Specifies the number of spaces by which to indent the text                                   (always from the left).\nrotation::Int = nothing      : Specifies the rotation angle of the text in the range -90 to 90                                   (positive values rotate the text counterclockwise), \n\nHere are the possible values for the horizontal alignment:\n\nleft             : Aligns the text to the left of the cell.\ncenter           : Centers the text within the cell.\nright            : Aligns the text to the right of the cell.\nfill             : Repeats the text to fill the entire width of the cell.\njustify          : Justifies the text, spacing it out so that it spans the entire                       width of the cell.\ncenterContinuous : Centers the text across multiple cells (specifically the currrent                       cell and all empty cells to the right) as if the text were in                       a merged cell.\ndistributed      : Distributes the text evenly across the width of the cell.\n\nHere are the possible values for the vertical alignment:\n\ntop              : Aligns the text to the top of the cell.\ncenter           : Centers the text vertically within the cell.\nbottom           : Aligns the text to the bottom of the cell.\njustify          : Justifies the text vertically, spreading it out evenly within the cell.\ndistributed      : Distributes the text evenly from top to bottom in the cell.\n\nFor single cells, the value returned is the styleId of the cell.\n\nFor cell ranges, column ranges and named ranges, the value returned is -1.\n\nExamples:\n\njulia> setAlignment(sh, \"D18\"; horizontal=\"center\", wrapText=true)\n\njulia> setAlignment(xf, \"sheet1!D18\"; horizontal=\"right\", vertical=\"top\", wrapText=true)\n\njulia> setAlignment(sh, \"L6\"; horizontal=\"center\", rotation=\"90\", shrink=true, indent=\"2\")\n\njulia> setAlignment(sh, 1:3, 3:6; horizontal=\"center\", rotation=\"90\", shrink=true, indent=\"2\")\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setUniformAlignment","page":"Formats","title":"XLSX.setUniformAlignment","text":"setUniformAlignment(sh::Worksheet, cr::String; kw...) -> ::Int\nsetUniformAlignment(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nsetUniformAlignment(sh::Worksheet, rows, cols; kw...) -> ::Int\n\nSet the alignment used by a cell range, a column range or row range or a  named range in a worksheet or XLSXfile to be uniformly the same alignment. Alternatively, specify the rows and columns using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nFirst, the alignment attributes of the first cell in the range (the top-left cell) are updated according to the given kw... (using setAlignment()). The resultant alignment  is then applied to each remaining cell in the range.\n\nAs a result, every cell in the range will have a uniform alignment setting.\n\nThis differs from setAlignment() which merges the attributes defined by kw... into  the alignment definition used by each cell individually. For example, if you set the  horizontal alignment to left for a range of cells, but these cells all use different  vertical alignment or wrapText, setAlignment() will change the horizontal alignment but  leave the vertical alignment and wrapText unchanged for each cell individually. \n\nIn contrast, setUniformAlignment() will set the horizontal alignment to left for   the first cell, but will then apply all the alignment attributes from the updated first   cell to all the other cells in the range.\n\nThis can be more efficient when setting the same alignment for a large number of cells.\n\nApplying setUniformAlignment() without any keyword arguments simply copies the Alignment  attributes from the first cell specified to all the others.\n\nThe value returned is the styleId of the reference (top-left) cell, from which the  alignment uniformly applied to the cells was taken. If all cells in the range are EmptyCells, the returned value is -1.\n\nFor keyword definitions see setAlignment().\n\nExamples:\n\nJulia> setUniformAlignment(sh, \"B2:D4\"; horizontal=\"center\", wrap = true)\n\nJulia> setUniformAlignment(xf, \"Sheet1!A1:F20\"; horizontal=\"center\", vertical=\"top\")\n\nJulia> setUniformAlignment(sh, :, 1:24; horizontal=\"center\", vertical=\"top\")\n\njulia> setUniformAlignment(sh, \"B2,A5:D22\")                # Copy `Alignment` from B2 to cells in A5:D22\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setUniformStyle","page":"Formats","title":"XLSX.setUniformStyle","text":"setUniformStyle(sh::Worksheet, cr::String) -> ::Int\nsetUniformStyle(xf::XLSXFile,  cr::String) -> ::Int\n\nsetUniformStyle(sh::Worksheet, rows, cols) -> ::Int\n\nSet the cell style used by a cell range, a column range or row range  or a named range in a worksheet or XLSXfile to be the same as that of  the first cell in the range that is not an EmptyCell. Alternatively, specify the rows and columns using any combination of  Integer, UnitRange, Vector{Integer} or :.\n\nAs a result, every cell in the range will have a uniform style.\n\nA cell style consists of the collection of format, alignment, border,  font and fill.\n\nIf the first cell has no defined style (s=\"\"), all cells will be given the  same undefined style.\n\nThe value returned is the styleId of the style uniformly applied to the cells or  nothing if the style is undefined. If all cells in the range are EmptyCells, the returned value is -1.\n\nExamples:\n\njulia> XLSX.setUniformStyle(xf, \"Sheet1!A2:L6\")\n\njulia> XLSX.setUniformStyle(sh, \"F1:F5\")\n\njulia> XLSX.setUniformStyle(sh, 2:5, 5)\n\njulia> XLSX.setUniformStyle(sh, 2, :)\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#Conditional-format","page":"Formats","title":"Conditional format","text":"","category":"section"},{"location":"api/formats/#XLSX.getConditionalFormats","page":"Formats","title":"XLSX.getConditionalFormats","text":"getConditionalFormats(ws::Worksheet)\n\nGet the conditional formats for a worksheet.\n\nArguments\n\nws::Worksheet: The worksheet for which to get the conditional formats.\n\nReturn a vector of pairs: CellRange => NamedTuple{type::String, priority::Int}}.\n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setConditionalFormat","page":"Formats","title":"XLSX.setConditionalFormat","text":"setConditionalFormat(ws::Worksheet, cr::String, type::Symbol; kw...) -> ::Int\nsetConditionalFormat(xf::XLSXFile,  cr::String, type::Symbol; kw...) -> ::Int\n\nsetConditionalFormat(ws::Worksheet, rows, cols, type::Symbol; kw...) -> ::Int\n\nAdd a new conditional format to a cell range, row range or column range in a  worksheet or XLSXFile.  Alternatively, ranges can be specified by giving rows  and columns separately.\n\nThere are many options for applying differnt types of custom format. For a basic guide,  refer to the section on Conditional formats in the Formatting Guide.\n\nThe type argument specifies which of Excel's conditional format types will be applied.\n\nValid options for type are:\n\n:cellIs\n:top10\n:aboveAverage\n:containsText\n:notContainsText\n:beginsWith\n:endsWith\n:timePeriod\n:containsErrors\n:notContainsErrors\n:containsBlanks\n:notContainsBlanks\n:uniqueValues\n:duplicateValues\n:dataBar\n:colorScale\n:iconSet\n\nKeyword options differ according to the type specified, as set out below.\n\ntype = :cellIs\n\nDefines a conditional format based on the value of each cell in a range.\n\nValid keywords are:\n\noperator   : Defines the comparison to make.\nvalue      : defines the first value to compare against. This can be a cell reference (e.g. \"A1\") or a number.\nvalue2     : defines the second value to compare against. This can be a cell reference (e.g. \"A1\") or a number.\nstopIfTrue : Stops evaluating the conditional formats for this cell if this one is true.\ndxStyle    : Used optionally to select one of the built-in Excel formats to apply\nformat     : defines the numFmt to apply if opting for a custom format.\nfont       : defines the font to apply if opting for a custom format.\nborder     : defines the border to apply if opting for a custom format.\nfill       : defines the fill to apply if opting for a custom format.\n\nAll keywords are defined using Strings (e.g. value = \"2\" or value = \"A2\").\n\nThe keyword operator defines the comparison to use in the conditional formatting.  If the condition is met, the format is applied. Valid options are:\n\ngreaterThan     (cell >  value) (default)\ngreaterEqual    (cell >= value)\nlessThan        (cell <  value)\nlessEqual       (cell <= value)\nequal           (cell == value)\nnotEqual        (cell != value)\nbetween         (cell between value and value2)\nnotBetween      (cell not between value and value2)\n\nIf not specified (when required), value will be the arithmetic average of the  (non-missing) cell values in the range if values are numeric. If the cell values  are non-numeric, an error is thrown.\n\nFormatting to be applied if the condition is met can be defined in one of two ways.  Use the keyword dxStyle to select one of the built-in Excel formats.  Valid options are:\n\nredfilltext     (light red fill, dark red text) (default)\nyellowfilltext  (light yellow fill, dark yellow text)\ngreenfilltext   (light green fill, dark green text)\nredfill         (light red fill)\nredtext         (dark red text)\nredborder       (dark red cell borders)\n\nAlternatively, you can define a custom format by using the keywords format, font, border, and fill which each take a vector of pairs of strings. The first string  is the name of the attribute to set and the second is the value to set it to.   Valid attributes for each keyword are:\n\nformat : format\nfont   : color, bold, italic, under, strike\nfill   : pattern, bgColor, fgColor\nborder : style, color\n\nRefer to setFormat(), setFont(), setFill() and setBorder() for more details on the valid attributes and values.\n\nnote: Note\nExcel limits the formatting attributes that can be set in a conditional format. It is not possible to set the size or name of a font and neither is it possible to set  any of the cell alignment attributes. Diagonal borders cannot be set either.Although it is not a limitation of Excel, this function sets all the border attributes  for each side of a cell to be the same.\n\nIf both dxStyle and custom formatting keywords are specified, dxStyle will be used  and the custom formatting will be ignored. If neither dxStyle nor custom formatting keywords are specified, the default  is dxStyle=\"redfilltext\".\n\nExamples\n\njulia> XLSX.setConditionalFormat(s, \"B1:B5\", :cellIs) # Defaults to `operator=\"greaterThan\"`, `dxStyle=\"redfilltext\"` and `value` set to the arithmetic agverage of cell values in `rng`.\n\njulia> XLSX.setConditionalFormat(s, \"B1:B5\", :cellIs;\n            operator=\"between\",\n            value=\"2\",\n            value2=\"3\",\n            fill = [\"pattern\" => \"none\", \"bgColor\"=>\"FFFFC7CE\"],\n            format = [\"format\"=>\"0.00%\"],\n            font = [\"color\"=>\"blue\", \"bold\"=>\"true\"]\n        )\n\njulia> XLSX.setConditionalFormat(s, \"B1:B5\", :cellIs; \n            operator=\"greaterThan\",\n            value=\"4\",\n            fill = [\"pattern\" => \"none\", \"bgColor\"=>\"green\"],\n            format = [\"format\"=>\"0.0\"],\n            font = [\"color\"=>\"red\", \"italic\"=>\"true\"]\n        )\n\njulia> XLSX.setConditionalFormat(s, \"B1:B5\", :cellIs;\n            operator=\"lessThan\",\n            value=\"2\",\n            fill = [\"pattern\" => \"none\", \"bgColor\"=>\"yellow\"],\n            format = [\"format\"=>\"0.0\"],\n            font = [\"color\"=>\"green\"],\n            border = [\"style\"=>\"thick\", \"color\"=>\"coral\"]\n        )\n\n\ntype = :top10\n\nThis conditional format can be used to highlight cells in the top (bottom) n within the  range or in the top (bottom) n% (ie in the top 5 or in the top 5% of values in the range). \n\nThe available keywords are:\n\noperator   : Defines the comparison to make.\nvalue      : Gives the for comparison or a cell reference (e.g. \"A1\").\nstopIfTrue : Stops evaluating the conditional formats if this one is true.\ndxStyle    : Used optionally to select one of the built-in Excel formats to apply.\nformat     : defines the numFmt to apply if opting for a custom format.\nfont       : defines the font to apply if opting for a custom format.\nborder     : defines the border to apply if opting for a custom format.\nfill       : defines the fill to apply if opting for a custom format.\n\nValid values for the operator keyword are the following:\n\ntopN            (cell is in the top n (= value) values of the range)\nbottomN         (cell is in the bottom n (= value) values of the range)\ntopN%           (cell is in the top n% (= value) values of the range)\nbottomN%        (cell is in the bottom n% (= value) values of the range)\n\nDefault keyowrds are operator=\"TopN\" and value=\"10\".\n\nMultiple conditional formats may be applied to the same or overlapping cell ranges.  If stopIfTrue=true the first condition that is met will be applied but all subsequent  conditional formats for that cell will be skipped. If stopIfTrue=false (default) all  relevant conditional formats will be applied to the cell in turn.\n\nFor example usage of the stopIfTrue keyword, refer to Overlaying conditional formats  in the Formatting Guide.\n\nThe remaining keywords are defined as above for type = :cellIs.\n\nExamples\n\njulia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1)\n\njulia> for i=1:10;for j=1:10; s[i,j]=i*j;end;end\n\njulia> s[:]\n10×10 Matrix{Any}:\n  1   2   3   4   5   6   7   8   9   10\n  2   4   6   8  10  12  14  16  18   20\n  3   6   9  12  15  18  21  24  27   30\n  4   8  12  16  20  24  28  32  36   40\n  5  10  15  20  25  30  35  40  45   50\n  6  12  18  24  30  36  42  48  54   60\n  7  14  21  28  35  42  49  56  63   70\n  8  16  24  32  40  48  56  64  72   80\n  9  18  27  36  45  54  63  72  81   90\n 10  20  30  40  50  60  70  80  90  100\n\njulia> XLSX.setConditionalFormat(s, \"A1:J10\", :top10; operator=\"bottomN\", value=\"1\", stopIfTrue=\"true\", dxStyle=\"redfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:J10\", :top10; operator=\"topN\", value=\"1\", stopIfTrue=\"true\", dxStyle=\"greenfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:J10\", :top10;\n                operator=\"topN%\",\n                value=\"20\",\n                fill=[\"pattern\"=>\"solid\", \"bgColor\"=>\"cyan\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:J10\", :top10;\n                operator=\"bottomN%\",\n                value=\"20\",\n                fill=[\"pattern\"=>\"solid\", \"bgColor\"=>\"yellow\"])\n0\n\n\n(Image: image|320x500)\n\ntype = :aboveAverage\n\nThis conditional format can be used to compare cell values in the range with the  average value for the range. \n\nThe available keywords are:\n\noperator   : Defines the comparison to make.\nstopIfTrue : Stops evaluating the conditional formats if this one is true.\ndxStyle    : Used optionally to select one of the built-in Excel formats to apply.\nformat     : defines the numFmt to apply if opting for a custom format.\nfont       : defines the font to apply if opting for a custom format.\nborder     : defines the border to apply if opting for a custom format.\nfill       : defines the fill to apply if opting for a custom format.\n\nValid values for the operator keyword are the following:\n\naboveAverage    (cell is above the average of the range) (default)\naboveEqAverage  (cell is above or equal to the average of the range)\nplus1StdDev     (cell is above the average of the range + 1 standard deviation)\nplus2StdDev     (cell is above the average of the range + 2 standard deviations)\nplus3StdDev     (cell is above the average of the range + 3 standard deviations)\nbelowAverage    (cell is below the average of the range)\nbelowEqAverage  (cell is below or equal to the average of the range)\nminus1StdDev    (cell is below the average of the range - 1 standard deviation)\nminus2StdDev    (cell is below the average of the range - 2 standard deviations)\nminus3StdDev    (cell is below the average of the range - 3 standard deviations)\n\nThe remaining keywords are defined as above for type = :cellIs.\n\nExamples\n\njulia> using Random, Distributions\n\njulia> d=Normal()\nNormal{Float64}(μ=0.0, σ=1.0)\n\njulia> columns=rand(d,1000)                                                                                                                                                        \n1000-element Vector{Float64}:\n-1.5515478694605092\n  0.36859583733587165\n  1.5349535865662158\n -0.2352610551087202\n  0.12355875388105911\n  0.5859222303845908\n -0.6326662651426166\n  1.0610118292961683\n -0.7891578831398097\n  0.031022172414689787\n -0.5534440118018843\n -2.3538883599955023\n  ⋮\n  0.4813001892130465\n  0.03871017417416217\n  0.7224728281160403\n -1.1265372949908539\n  1.5714393857211955\n  0.31438739499933255\n  0.4852591013082452\n  0.5363388236349432\n  1.1268430910133729\n  0.7691442442244849\n  1.0061732938516454\n\njulia> f=XLSX.newxlsx()\nXLSXFile(\"C:\\...\\blank.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 1x1           A1:A1\n\n\njulia> s=f[1]\n1×1 XLSX.Worksheet: [\"Sheet1\"](A1:A1) \n\njulia> XLSX.writetable!(s, [columns], [\"normal\"])\n\njulia> XLSX.setConditionalFormat(s, \"A2:A1001\", :aboveAverage ;\n                operator=\"plus3StdDev\",\n                stopIfTrue=\"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"red\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:A1001\", :aboveAverage ;\n                operator=\"minus3StdDev\",\n                stopIfTrue=\"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"red\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:A1001\", :aboveAverage ;\n                operator=\"plus2StdDev\",\n                stopIfTrue=\"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"tomato\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:A1001\", :aboveAverage ;\n                operator=\"minus2StdDev\",\n                stopIfTrue=\"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"tomato\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:A1001\", :aboveAverage ;\n                operator=\"minus1StdDev\",\n                stopIfTrue=\"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"pink\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:A1001\", :aboveAverage ;\n                operator=\"plus1StdDev\",\n                stopIfTrue = \"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"pink\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:A1001\", :aboveAverage ;\n                operator=\"belowEqAverage\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"green\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A2:A1001\", :aboveAverage ;\n                operator=\"aboveEqAverage\", \n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"green\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\n\ntype = :containsText, :notContainsText, :beginsWith or :endsWith\n\nHighlight cells in the range that contain (or do not contain), begin or end with  a specific text string. The default is containsText.\n\nValid keywords are:\n\nvalue      : Gives the literal text to match or provides a cell reference (e.g. \"A1\").\nstopIfTrue : Stops evaluating the conditional formats if this one is true.\ndxStyle    : Used optionally to select one of the built-in Excel formats to apply.\nformat     : defines the numFmt to apply if opting for a custom format.\nfont       : defines the font to apply if opting for a custom format.\nborder     : defines the border to apply if opting for a custom format.\nfill       : defines the fill to apply if opting for a custom format.\n\nThe keyword value gives the literal text to compare (eg. \"Hello World\") or provides a cell reference  (e.g. \"A1\"). It is a required keyword with no default value.\n\nThe remaining keywords are optional and are defined as above for type = :cellIs.\n\nExamples\n\njulia> s[:]\n4×1 Matrix{Any}:\n \"Hello World\"\n \"Life the universe and everything\"\n \"Once upon a time\"\n \"In America\"\n\njulia> XLSX.setConditionalFormat(s, \"A1:A4\", :containsText;\n                value=\"th\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"cyan\"],\n                font = [\"color\"=>\"black\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A4\", :notContainsText;\n                value=\"i\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"green\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A4\", :beginsWith ;\n                value=\"On\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"red\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A4\", :endsWith ;\n                value=\"ica\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"blue\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])\n0\n\n\n(Image: image|320x500)\n\ntype = :timePeriod\n\nWhen cells contain dates, this conditional format can be used to highlight cells. The available keywords are:\n\noperator   : Defines the comparison to make.\nstopIfTrue : Stops evaluating the conditional formats if this one is true.\ndxStyle    : Used optionally to select one of the built-in Excel formats to apply\nformat     : defines the numFmt to apply if opting for a custom format.\nfont       : defines the font to apply if opting for a custom format.\nborder     : defines the border to apply if opting for a custom format.\nfill       : defines the fill to apply if opting for a custom format.\n\nValid values for the keyword operator are the following:\n\nyesterday\ntoday\ntomorrow\nlast7Days (default)\nlastWeek\nthisWeek\nnextWeek\nlastMonth\nthisMonth\nnextMonth\n\nThe remaining keywords are defined as above for type = :cellIs.\n\nExamples\n\njulia> s[1:13, 1]\n13×1 Matrix{Any}:\n \"Dates\"\n 2024-11-20\n 2024-12-20\n 2025-01-08\n 2025-02-08\n 2025-03-08\n 2025-04-08\n 2025-05-08\n 2025-05-09\n 2025-05-10\n 2025-05-14\n 2025-06-08\n 2025-07-08\n\njulia> XLSX.setConditionalFormat(s, \"A1:A13\", :timePeriod; operator=\"today\", dxStyle = \"greenfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A13\", :timePeriod; operator=\"tomorrow\", dxStyle = \"yellowfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A13\", :timePeriod; operator=\"nextMonth\", dxStyle = \"redfilltext\")\n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A13\", :timePeriod;\n                operator=\"lastMonth\", \n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"blue\"], \n                font = [\"color\"=>\"yellow\", \"bold\"=>\"true\"])        \n0\n\n\n(Image: image|320x500)\n\ntype = :containsErrors, :notContainsErrors, :containsBlanks, :notContainsBlanks, :uniqueValues or :duplicateValues\n\nThese conditional formatting options highlight cells that contain or don't contain errors,  are blank (default) or not blank, are unique in the range or are duplicates within the range.  The available keywords are: \n\nstopIfTrue : Stops evaluating the conditional formats if this one is true.\ndxStyle    : Used optionally to select one of the built-in Excel formats to apply\nformat     : defines the numFmt to apply if opting for a custom format.\nfont       : defines the font to apply if opting for a custom format.\nborder     : defines the border to apply if opting for a custom format.\nfill       : defines the fill to apply if opting for a custom format.\n\nThese keywords are defined as above for the :cellIs conditional format type.\n\nExamples\n\njulia> XLSX.setConditionalFormat(s, \"A1:A7\", :containsErrors;\n                stopIfTrue=\"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"blue\"],\n                font = [\"color\"=>\"white\", \"bold\"=>\"true\"])        \n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A7\", :containsBlanks;\n                stopIfTrue=\"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"green\"],\n                font = [\"color\"=>\"black\", \"bold\"=>\"true\"])       \n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A7\", :uniqueValues;\n                stopIfTrue=\"true\",\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"yellow\"],\n                font = [\"color\"=>\"black\", \"bold\"=>\"true\"])        \n0\n\njulia> XLSX.setConditionalFormat(s, \"A1:A7\", :duplicateValues;\n                fill = [\"pattern\"=>\"solid\", \"bgColor\"=>\"cyan\"],\n                font = [\"color\"=>\"black\", \"bold\"=>\"true\"])\n0\n\n\n(Image: image|320x500)\n\ntype = :expressiom\n\nSet a conditional format when an expression evaluated in each cell is true.\n\nThe available keywords are:\n\nformula    : Specifies the formula to use. This must be a valid Excel formula.\nstopIfTrue : Stops evaluating the conditional formats if this one is true.\ndxStyle    : Used optionally to select one of the built-in Excel formats to apply\nformat     : defines the numFmt to apply if opting for a custom format.\nfont       : defines the font to apply if opting for a custom format.\nborder     : defines the border to apply if opting for a custom format.\nfill       : defines the fill to apply if opting for a custom format.\n\nThe keyword formula is required and there is no default value. Formulae must be valid  Excel formulae and written in US english with comma separators. Cell references may be  absolute or relative references in either the row or the column or both.\n\nThe remaining keywords are defined as above for type = :cellIs.\n\nExamples\n\njulia> XLSX.setConditionalFormat(s, \"A1:C4\", :expression; formula = \"A1 < 16\", dxStyle=\"greenfilltext\")\n\njulia> XLSX.setConditionalFormat(s, 1:5, 1:4, :expression;\n            formula=\"A1=1\",\n            fill=[\"pattern\" => \"none\", \"bgColor\" => \"yellow\"],\n            format=[\"format\" => \"0.0\"],\n            font=[\"color\" => \"green\"],\n            border=[\"style\" => \"thick\", \"color\" => \"coral\"]\n        )\n\njulia> XLSX.setConditionalFormat(s, \"B2:D11\", :expression; formula = \"average(B$2:B$11) > average(A$2:A$11)\", dxStyle = \"greenfilltext\")\n\njulia> XLSX.setConditionalFormat(s, \"A1:E5\", :expression; formula = \"E5<50\", dxStyle = \"redfilltext\")\n\n\ntype = :dataBar\n\nApply data bars to cells in a range depending on their values. The keyword databar can be used to select one of 12 built-in databars Excel provides by name. Valid names are:\n\nbluegrad (default)\ngreengrad\nredgrad\norangegrad\nlightbluegrad\npurplegrad\nblue\ngreen\nred\norange\nlightblue\npurple\n\nThe first six (with a grad suffix) yield bars with a color gradient while the remainder  yield bars of solid color. By default, all built in data bars define their range from the  minumum and maximum values in the range and negative values are given a red bar. These default settings can each be modified using the other keyword options available.\n\nRemaining keyword options provided are:\n\nshowVal - set to \"false\" to show databars only and hide cell values\ngradient - set to \"false\" to use a solid color bar rather than a gradient fill\nborders - set to \"true\" to show borders around each bar\nsameNegFill - set to \"true\" to use the same fill color on negative bars as positive.\nsameNegBorders - set to \"false\" to use the same border color on negative bars as positive\ndirection - determines the direction of the bars from the axis, \"leftToRight\" or \"rightToLeft\"\nmin_type - Defines how the minimum of the bar scale is defined (\"num\", \"min\", \"percent\", percentile\", \"formula\" or \"automatic\")\nmin_val - Defines the minimum value for the data bar scale. May be a number(as a string), a cell reference or a formula (if type=\"formula\").\nmax_type - Defines how the maximum of the bar scale is defined (\"num\", \"max\", \"percent\", percentile\", \"formula\" or \"automatic\")\nmax_val - Defines the maximum value for the data bar scale. May be a number(as a string), a cell reference or a formula (if type=\"formula\").\nfill_col - Defines the color of the fill for positive bars (8 digit hex or by name)\nborder_col - Defines the color of the border for positive bars (8 digit hex or by name)\nneg_fill_col - Defines the color of the fill for negative bars (8 digit hex or by name)\nneg_border_col - Defines the color of the border for negative bars (8 digit hex or by name)\naxis_pos - Defines the position of the axis (\"middle\" or \"none\")\naxis_col - Defines the color of the axis (8 digit hex or by name)\n\nExamples\n\njulia> XLSX.setConditionalFormat(s, \"A1:A11\", :dataBar)\n\njulia> XLSX.setConditionalFormat(s, \"B1:B11\", :dataBar; databar=\"purple\")\n\njulia> XLSX.setConditionalFormat(s, \"D1:D11\", :dataBar; \n            gradient=\"true\", \n            direction=\"rightToLeft\", \n            axis_pos=\"none\", \n            showVal=\"false\"\n        )\n\njulia> XLSX.setConditionalFormat(s, \"F1:F11\", :dataBar;\n            gradient=\"false\",\n            sameNegFill=\"true\",\n            sameNegBorders=\"true\"\n        )\n\njulia> XLSX.setConditionalFormat(f, \"Sheet1!G1:G11\", :dataBar;\n            fill_col=\"coral\", border_col = \"cyan\",\n            neg_fill_col=\"cyan\", neg_border_col = \"coral\"\n        )\n\njulia> XLSX.setConditionalFormat(f, \"Sheet1!J1:J11\", :dataBar; axis_col=\"magenta\")\n\njulia> XLSX.setConditionalFormat(s, 15:25, 1, :dataBar;\n            min_type=\"least\", max_type=\"highest\"\n        )\n\njulia> XLSX.setConditionalFormat(s, 15:25, 2, :dataBar; \n            databar=\"purple\", \n            min_type=\"percent\", max_type=\"percent\",\n            min_val=\"20\", max_val=\"60\"\n        )\n\njulia> XLSX.setConditionalFormat(s, \"C15:C25\", :dataBar;\n            databar=\"blue\",\n            min_type=\"num\", max_type=\"num\",\n            min_val=\"-1\", max_val=\"6\",\n            gradient=\"true\",\n            direction=\"leftToRight\", \n            axis_pos=\"none\"\n        )\n\njulia> XLSX.setConditionalFormat(s, \"E15:E25\", :dataBar;\n            gradient=\"true\",\n            min_type=\"percentile\", max_type=\"percentile\",\n            min_val=\"20\", max_val=\"80\",\n            direction=\"rightToLeft\",\n            axis_pos=\"middle\"\n        )\n\njulia> XLSX.setConditionalFormat(s, \"G15:G25\", :dataBar; \n            min_type=\"num\", max_type=\"formula\", \n            min_val=\"$L$1\", max_val=\"$M$1 * $N$1 + 3\",\n            fill_col=\"coral\", border_col = \"cyan\",\n            neg_fill_col=\"cyan\", neg_border_col = \"coral\"\n        )\n\n\ntype = :colorScale\n\nDefine a 2-color or 3-color colorscale conditional format.\n\nUse the keyword colorscale to choose one of the 12 built-in Excel colorscales:\n\n\"redyellowgreen\": Red, Yellow, Green 3-color scale.\n\"greenyellowred\": Green, Yellow, Red 3-color scale.\n\"redwhitegreen\" : Red, White, Green 3-color scale.\n\"greenwhitered\" : Green, White, Red 3-color scale.\n\"redwhiteblue\"  : Red, White, Blue 3-color scale.\n\"bluewhitered\"  : Blue, White, Red 3-color scale.\n\"redwhite\"      : Red, White 2-color scale.\n\"whitered\"      : White, Red 2-color scale.\n\"whitegreen\"    : White, Green 2-color scale.\n\"greenwhite\"    : Green, White 2-color scale.\n\"yellowgreen\"   : Yellow, Green 2-color scale.\n\"greenyellow\"   : Green, Yellow 2-color scale (default).\n\nAlternatively, you can define a custom color scale by omitting the colorscale keyword and  instead using the following keywords:\n\nmin_type: The type of the minimum value. Valid values are: min, percentile, percent, num or formula.\nmin_val : The value of the minimum. Omit if min_type=\"min\".\nmin_col : The color of the minimum value.\nmid_type: Valid values are: percentile, percent, num or formula. Omit for a 2-color scale.\nmid_val : The value of the scale mid point. Omit for a 2-color scale.\nmid_col : The color of the mid point. Omit for a 2-color scale.\nmax_type: The type of the maximum value. Valid values are: max, percentile, percent, num or formula.\nmax_val : The value of the maximum value. Omit if max_type=\"max\".\nmax_col : The color of the maximum value.\n\nThe keywords min_val, mid_val, and max_val can be a number or cell reference (e.g. \"$A$1\") for any value  of the related type keyword or, if the related type keyword is set to formula, may be a valid Excel formula that  calculates a number. Cell references used in a formula must be specified as absolute references.\n\nColors can be specified using an 8-digit hex string (e.g. FF0000FF for blue) or any named  color from Colors.jl.\n\nExamples\n\njulia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"A1:F12\", :colorScale) # Defaults to the `greenyellow` built-in scale.\n0\n\njulia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"A13:C18\", :colorScale; colorscale=\"whitered\")\n0\n\njulia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"D13:F18\", :colorScale; colorscale=\"bluewhitered\")\n0\n\njulia> XLSX.setConditionalFormat(f[\"Sheet1\"], \"A13:F22\", :colorScale;\n            min_type=\"num\", \n            min_val=\"2\",\n            min_col=\"tomato\",\n            mid_type=\"num\",\n            mid_val=\"6\", \n            mid_col=\"lawngreen\",\n            max_type=\"num\",\n            max_val=\"10\",\n            max_col=\"cadetblue\"\n        )\n0\n\n\ntype = :iconSet\n\nApply a set of icons to cells in a range depending on their values. The keyword iconset can be used to select one of 20 built-in icon sets Excel provides by name. Valid names are:\n\n3Arrows\n5ArrowsGray\n3TrafficLights (default)\n3Flags\n5Quarters\n4Rating\n5Rating\n3Symbols\n3Symbols2\n3Signs\n3TrafficLights2\n4TrafficLights\n4BlackToRed\n4Arrows\n5Arrows\n3ArrowsGray\n4ArrowsGray\n3Triangles\n3Stars\n5Boxes\n\nThe digit prefix to the name indicates how many icons there are in a set, and therefore how the cell values with be binned by value. Bin boundaries may optionally be specified by the following keywords to override the default values for each icon set:\n\nmin_type  = \"percent\" (default), \"percentile\", \"num\" or \"formula\"\nmin_val     (default: \"33\" (3 icons), \"25\" (4 icons) or \"20\" (5 icons))\nmid_type  = \"percent\" (default), \"percentile\", \"num\" or \"formula\"\nmid_val     (default: \"50\" (4 icons), \"40\" (5 icons))\nmid2_type = \"percent\" (default), \"percentile\", \"num\" or \"formula\"\nmid2_val    (default: \"60\" (5 icons))\nmax_type  = \"percent\" (default), \"percentile\", \"num\" or \"formula\"\nmax_val     (default: \"67\" (3 icons), \"75\" (4 icons) or \"80\" (5 icons))\n\nThe keywords min_val, mid_val, mid2_val and max_val may contain numbers (as strings)  or valid cell references. If formula is specified for the related type keyword, a valid  Excel formula can be provided to evaluate to the bin threshold value to be used. Three-icon sets require two thresholds (min_type/min_val and max_type/max_val),  four-icon sets require three thresholds (with the addition of mid_type/mid_val) and  five-icon sets require four thresholds (adding mid2_type/mid2_val). Thresholds defined  (using val and type keywords) that are unnecessary are simply ignored.\n\nEach value can be tested using >= (default) or >. To change from the default, optionally set min_gte, mid_gte, mid2_gte and/or max_gte to \"false\" to  use > in the comparison. Any other value for these gte keywords will be ignored  and the default >= comparison used.\n\nThe built-in icon sets Excel provides are composed of 52 individual icons. It is  possible to mix and match any of these to make a custom 3-icon, 4-icon or 5-icon  set by specifying iconset = \"Custom\". The number of icons in the set will be  determined by whether the mid_val/mid_type keywords and mid2_val/mid2_type  keywords are provided.\n\nThe icons that will be used in a Custom iconset are defined using the icon_list  keyword which takes a vector of integers in the range from 1 to 52. For a key relating integers to the icons they represent, see the Icon Set section in the Formatting  Guide.\n\nThe order in which the symbols are appiled can be reversed from the default order (or, for  Custom icon sets, the order given in icon_list), by optionally setting reverse = \"true\".  Any other value provided for reverse will be ignored, and the default order applied.\n\nThe cell value can be suppressed, so that only the icon is shown in the Excel cell by  optionally specifying showVal = \"false\". Any other value provided for showVal will be  ignored, and the cell value will be displayed with the icon.\n\nExamples\n\nXLSX.setConditionalFormat(s, \"F2:F11\", :iconSet; iconset=\"3Arrows\")\n\nXLSX.setConditionalFormat(s, 2, :, :iconSet; iconset = \"5Boxes\",\n            reverse = \"true\",\n            showVal = \"false\",\n            min_type=\"num\",  mid_type=\"percentile\", mid2_type=\"percentile\", max_type=\"num\",\n            min_val=\"3\",     mid_val=\"45\",          mid2_val=\"65\",          max_val=\"8\",\n            min_gte=\"false\", mid_gte=\"false\",       mid2_gte=\"false\",       max_gte=\"false\")\n\nXLSX.setConditionalFormat(s, \"A2:A11\", :iconSet;\n        iconset = \"Custom\",\n        icon_list = [31,24],\n        min_type=\"num\",  max_type=\"formula\",\n        min_val=\"3\",     max_val=\"if($G$4=\"y\", $G$1+5, 10)\")\n\n\n\n\n\n\n","category":"function"},{"location":"api/formats/#Column-width-and-row-height","page":"Formats","title":"Column width and row height","text":"","category":"section"},{"location":"api/formats/#XLSX.getColumnWidth","page":"Formats","title":"XLSX.getColumnWidth","text":"getColumnWidth(sh::Worksheet, cr::String) -> ::Union{Nothing, Real}\ngetColumnWidth(xf::XLSXFile,  cr::String) -> ::Union{Nothing, Real}\n\ngetColumnWidth(sh::Worksheet,  row::Int, col::Int) -> ::Union{Nothing, Real}\n\nGet the width of a column defined by a cell reference or named cell. The specified cell must be within the sheet dimension.\n\nA standard cell reference or defined name may be used to define the column.  The function will use the column number and ignore the row.\n\nThe function returns the value of the column width or nothing if the column  does not have an explicitly defined width.\n\nExamples:\n\njulia> XLSX.getColumnWidth(xf, \"Sheet1!A2\")\n\njulia> XLSX.getColumnWidth(sh, \"F1\")\n\njulia> XLSX.getColumnWidth(sh, 1, 6)\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setColumnWidth","page":"Formats","title":"XLSX.setColumnWidth","text":"setColumnWidth(sh::Worksheet, cr::String; kw...) -> ::Int\nsetColumnWidth(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nsetColumnWidth(sh::Worksheet, row, col; kw...) -> ::Int\n\nSet the width of a column or column range.\n\nA standard cell reference or cell range can be used to define the column range.  The function will use the columns and ignore the rows. Named cells and named ranges can similarly be used. Alternatively, specify the row and column using any combination of  Integer, UnitRange, Vector{Integer} or :, but only the columns will be used.\n\nThe function uses one keyword used to define a column width:\n\nwidth::Real = nothing : Defines width in Excel's own (internal) units\n\nWhen you set a column widths interactively in Excel you can see the width  in \"internal\" units and in pixels. The width stored in the xlsx file is slightly  larger than the width shown intertactively because Excel adds some cell padding.  The method Excel uses to calculate the padding is obscure and complex. This  function does not attempt to replicate it, but simply adds 0.71 internal units  to the value specified. The value set is unlikely to match the value seen  interactivley in the resultant spreadsheet, but will be close.\n\nYou can set a column width to 0.\n\nThe function returns a value of 0.\n\nsetColumnWidth requires a file to be open for writing as well as reading (mode=\"rw\" or open as a template) but  it can work on empty cells.\n\nExamples:\n\njulia> XLSX.setColumnWidth(xf, \"Sheet1!A2\"; width = 50)\n\njulia> XLSX.seColumnWidth(sh, \"F1:F5\"; width = 0)\n\njulia> XLSX.setColumnWidth(sh, \"I\"; width = 24.37)\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.getRowHeight","page":"Formats","title":"XLSX.getRowHeight","text":"getRowHeight(sh::Worksheet, cr::String) -> ::Union{Nothing, Real}\ngetRowHeight(xf::XLSXFile,  cr::String) -> ::Union{Nothing, Real}\n\ngetRowHeight(sh::Worksheet,  row::Int, col::Int) -> ::Union{Nothing, Real}\n\nGet the height of a row defined by a cell reference or named cell. The specified cell must be within the sheet dimension.\n\nA standard cell reference or defined name must be used to define the row.  The function will use the row number and ignore the column.\n\nThe function returns the value of the row height or nothing if the row  does not have an explicitly defined height.\n\nIf the row is not found (an empty row), returns -1.\n\nExamples:\n\njulia> XLSX.getRowHeight(xf, \"Sheet1!A2\")\n\njulia> XLSX.getRowHeight(sh, \"F1\")\n\njulia> XLSX.getRowHeight(sh, 1, 6)\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.setRowHeight","page":"Formats","title":"XLSX.setRowHeight","text":"setRowHeight(sh::Worksheet, cr::String; kw...) -> ::Int\nsetRowHeight(xf::XLSXFile,  cr::String, kw...) -> ::Int\n\nsetRowHeight(sh::Worksheet, row, col; kw...) -> ::Int\n\nSet the height of a row or row range.\n\nA standard cell reference or cell range must be used to define the row range.  The function will use the rows and ignore the columns. Named cells and named ranges can similarly be used. Alternatively, specify the row and column using any combination of  Integer, UnitRange, Vector{Integer} or :, but only the rows will be used.\n\nThe function uses one keyword used to define a row height:\n\nheight::Real = nothing : Defines height in Excel's own (internal) units.\n\nWhen you set row heights interactively in Excel you can see the height  in \"internal\" units and in pixels. The height stored in the xlsx file is slightly  larger than the height shown interactively because Excel adds some cell padding.  The method Excel uses to calculate the padding is obscure and complex. This  function does not attempt to replicate it, but simply adds 0.21 internal units  to the value specified. The value set is unlikely to match the value seen  interactivley in the resultant spreadsheet, but it will be close.\n\nRow height cannot be set for empty rows, which will quietly be skipped. A row must have at least one cell containing a value before its height can be set.\n\nYou can set a row height to 0.\n\nThe function returns a value of 0 unless all rows are empty, in which case  it returns a value of -1.\n\nExamples:\n\njulia> XLSX.setRowHeight(xf, \"Sheet1!A2\"; height = 50)\n\njulia> XLSX.setRowHeight(sh, \"F1:F5\"; height = 0)\n\njulia> XLSX.setRowHeight(sh, \"I\"; height = 24.56)\n\n\n\n\n\n\n","category":"function"},{"location":"api/formats/#Merged-Cells","page":"Formats","title":"Merged Cells","text":"","category":"section"},{"location":"api/formats/#XLSX.getMergedCells","page":"Formats","title":"XLSX.getMergedCells","text":"getMergedCells(ws::Worksheet) -> Union{Vector{CellRange}, Nothing}\n\nReturn a vector of the CellRange of all merged cells in the specified worksheet. Return nothing if the worksheet contains no merged cells.\n\nThe Excel file must be opened in write mode to work with merged cells.\n\nExamples:\n\njulia> f = XLSX.readxlsx(\"test.xlsx\")\nXLSXFile(\"C:\\Users\\tim\\Downloads\\test.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               Sheet1 2x2           A1:B2\n\njulia> s = f[\"Sheet1\"]\n2×2 XLSX.Worksheet: [\"Sheet1\"](A1:B2)\n\njulia> XLSX.getMergedCells(s)\n1-element Vector{XLSX.CellRange}:\n B1:B2\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.isMergedCell","page":"Formats","title":"XLSX.isMergedCell","text":"isMergedCell(ws::Worksheet,  cr::String) -> Bool\nisMergedCell(xf::XLSXFile,   cr::String) -> Bool\n\nisMergedCell(ws::Worksheet,  row::Int, col::Int) -> Bool\n\nReturn true if a cell is part of a merged cell range and false if not. The specified cell must be within the sheet dimension.\n\nAlternatively, if you have already obtained the merged cells for the worksheet, you can avoid repeated determinations and pass them as a keyword argument to  the function:\n\nisMergedCell(ws::Worksheet, cr::String; mergedCells::Union{Vector{CellRange}, Nothing, Missing}=missing) -> Bool\nisMergedCell(xf::XLSXFile,  cr::String; mergedCells::Union{Vector{CellRange}, Nothing, Missing}=missing) -> Bool\n\nisMergedCell(ws::Worksheet,  row:Int, col::Int; mergedCells::Union{Vector{CellRange}, Nothing, Missing}=missing) -> Bool\n\nThe Excel file must be opened in write mode to work with merged cells.\n\nExamples:\n\njulia> XLSX.isMergedCell(xf, \"Sheet1!A1\")\n\njulia> XLSX.isMergedCell(sh, \"A1\")\n\njulia> XLSX.isMergedCell(sh, 2, 4) # cell D2\n\njulia> mc = XLSX.getMergedCells(sh)\n\njulia> XLSX.isMergedCell(sh, XLSX.CellRef(\"A1\"), mc)\n \n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.getMergedBaseCell","page":"Formats","title":"XLSX.getMergedBaseCell","text":"getMergedBaseCell(ws::Worksheet, cr::String) -> Union{Nothing, NamedTuple{CellRef, Any}}\ngetMergedBaseCell(xf::XLSXFile,  cr::String) -> Union{Nothing, NamedTuple{CellRef, Any}}\n\ngetMergedBaseCell(ws::Worksheet, row::Int, col::Int) -> Union{Nothing, NamedTuple{CellRef, Any}}\n\nReturn the cell reference and cell value of the base cell of a merged cell range in a worksheet as a named tuple. The specified cell must be within the sheet dimension. If the specified cell is not part of a merged cell range, return nothing.\n\nThe base cell is the top-left cell of the merged cell range and is the reference cell for the range.\n\nThe tuple returned contains:\n\nbaseCell  : the reference (CellRef) of the base cell\nbaseValue : the value of the base cell\n\nAdditionally, if you have already obtained the merged cells for the worksheet, you can avoid repeated determinations and pass them as a keyword argument to  the function:\n\ngetMergedBaseCell(ws::Worksheet, cr::String; mergedCells::Union{Vector{CellRange}, Nothing, Missing}=missing) -> Union{Nothing, NamedTuple{CellRef, Any}}\ngetMergedBaseCell(xf::XLSXFile,  cr::String; mergedCells::Union{Vector{CellRange}, Nothing, Missing}=missing) -> Union{Nothing, NamedTuple{CellRef, Any}}\n\ngetMergedBaseCell(ws::Worksheet, row::Int, col::Int; mergedCells::Union{Vector{CellRange}, Nothing, Missing}=missing) -> Union{Nothing, NamedTuple{CellRef, Any}}\n\nThe Excel file must be opened in write mode to work with merged cells.\n\nExamples:\n\njulia> XLSX.getMergedBaseCell(xf, \"Sheet1!B2\")\n(baseCell = B1, baseValue = 3)\n\njulia> XLSX.getMergedBaseCell(sh, \"B2\")\n(baseCell = B1, baseValue = 3)\n\njulia> XLSX.getMergedBaseCell(sh, 2, 2)\n(baseCell = B1, baseValue = 3)\n\n\n\n\n\n\n","category":"function"},{"location":"api/formats/#XLSX.mergeCells","page":"Formats","title":"XLSX.mergeCells","text":"mergeCells(ws::Worksheet, cr::String) -> 0\nmergeCells(xf::XLSXFile,  cr::String) -> 0\n\nmergeCells(ws::Worksheet, row::Int, col::Int) -> 0\n\nMerge the cells in the range given by cr. The value of the merged cell  will be the value of the first cell in the range (the base cell) prior  to the merge. All other cells in the range will be set to missing,  reflecting the behaviour of Excel itself.\n\nMerging is limited to the extent of the worksheet dimension.\n\nThe specified range must not overlap with any previously merged cells.\n\nIt is not possible to merge a single cell!\n\nA non-contiguous range composed of multiple cell ranges will be processed as a  list of separate ranges. Each range will be merged separately. No range within  a non-contiguous range may be a single cell.\n\nThe Excel file must be opened in write mode to work with merged cells.\n\nExamples:\n\njulia> XLSX.mergeCells(xf, \"Sheet1!B2:D3\")  # Merge a cell range.\n\njulia> XLSX.mergeCells(sh, 1:3, :)          # Merge rows to the extent of the dimension.\n\njulia> XLSX.mergeCells(sh, \"A:D\")           # Merge columns to the extent of the dimension.\n\n\n\n\n\n\n","category":"function"},{"location":"#XLSX.jl","page":"Home","title":"XLSX.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XLSX.jl is a Julia package to read and write Excel spreadsheet files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Internally, an Excel XLSX file is just a Zip file with a set of XML files inside. The formats for these XML files are described in the Standard ECMA-376.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package follows the EMCA-376 to parse and generate XLSX files.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia v1.8\nLinux, macOS or Windows.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From a Julia session, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"XLSX\")","category":"page"},{"location":"#Source-Code","page":"Home","title":"Source Code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code for this package is hosted at https://github.com/felipenoris/XLSX.jl.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code for the package XLSX.jl is licensed under the MIT License.","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you're having any trouble, have any questions about this package or want to ask for a new feature, just open a new issue.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are always welcome!","category":"page"},{"location":"","page":"Home","title":"Home","text":"To contribute, fork the project on GitHub and send a Pull Request.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ECMA Open XML White Paper\nECMA-376\nExcel file limits","category":"page"},{"location":"#Alternative-Packages","page":"Home","title":"Alternative Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"LibXLSXWriter.jl\nExcelFiles.jl\nExcelReaders.jl\nXLSXReader.jl\nTaro.jl","category":"page"},{"location":"migration/#Migration-Guide","page":"Migration Guide","title":"Migration Guide","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"note: Note\nThis migration guide was introduced to describe migrating from a pre v0.8 version  of XLSX.jl to v0.8. It is a largely historic document now.","category":"page"},{"location":"migration/#Migrating-Legacy-Code-to-v0.8","page":"Migration Guide","title":"Migrating Legacy Code to v0.8","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Version v0.8 introduced a breaking change on methods XLSX.gettable and XLSX.readtable.","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"These methods used to return a tuple data, column_labels. On XLSX v0.8 these methods return a XLSX.DataTable struct that implements Tables.jl interface.","category":"page"},{"location":"migration/#Basic-code-replacement","page":"Migration Guide","title":"Basic code replacement","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Before","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"data, col_names = XLSX.readtable(joinpath(data_directory, \"general.xlsx\"), \"table4\")","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"After","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"dtable = XLSX.readtable(joinpath(data_directory, \"general.xlsx\"), \"table4\")\ndata, col_names = dtable.data, dtable.column_labels","category":"page"},{"location":"migration/#Reading-DataFrames","page":"Migration Guide","title":"Reading DataFrames","text":"","category":"section"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Since XLSX.DataTable implements Tables.jl interface, the result of XLSX.gettable or XLSX.readtable can be passed to a DataFrame constructor.","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"Before","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\")...)","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"After","category":"page"},{"location":"migration/","page":"Migration Guide","title":"Migration Guide","text":"df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\"))","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Setup","page":"Tutorial","title":"Setup","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, make sure you have XLSX.jl package installed.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Pkg\n\njulia> Pkg.add(\"XLSX\")","category":"page"},{"location":"tutorial/#Getting-Started","page":"Tutorial","title":"Getting Started","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The basic usage is to read an Excel file and read values.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import XLSX\n\njulia> xf = XLSX.readxlsx(\"myfile.xlsx\")\nXLSXFile(\"myfile.xlsx\") containing 3 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              mysheet 4x2           A1:B4\n           othersheet 1x1           A1:A1\n                named 1x1           B4:B4\n\njulia> XLSX.sheetnames(xf)\n3-element Array{String,1}:\n \"mysheet\"\n \"othersheet\"\n \"named\"\n\njulia> sh = xf[\"mysheet\"] # get a reference to a Worksheet\n4×2 XLSX.Worksheet: [\"mysheet\"](A1:B4)\n\njulia> sh[2, 2] # access element \"B2\" (2nd row, 2nd column)\n\"first\"\n\njulia> sh[\"B2\"] # you can also use the cell name\n\"first\"\n\njulia> sh[\"A2:B4\"] # or a cell range\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet\", \"A2:B4\") # shorthand for all above\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> sh[:] # all data inside worksheet's dimension\n4×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n 3           \"third\"\n\njulia> xf[\"mysheet!A2:B4\"] # you can also query values using a sheet reference\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> xf[\"NAMED_CELL\"] # you can even read named ranges\n\"B4 is a named cell from sheet \\\"named\\\"\"\n\njulia> xf[\"mysheet!A:B\"] # Column ranges are also supported\n4×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n 3           \"third\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To inspect the internal representation of each cell, use the getcell or getcellrange methods.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The example above used xf = XLSX.readxlsx(filename) to open a file, so all file contents are fetched at once from disk.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use XLSX.openxlsx to read file contents as needed (see Reading Large Excel Files and Caching).","category":"page"},{"location":"tutorial/#Data-Types","page":"Tutorial","title":"Data Types","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package uses the following concrete types when handling XLSX files.","category":"page"},{"location":"tutorial/#XLSX.CellValueType","page":"Tutorial","title":"XLSX.CellValueType","text":"CellValueType\n\nConcrete supported data-types.\n\nUnion{String, Missing, Float64, Int, Bool, Dates.Date, Dates.Time, Dates.DateTime}\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Abstract types of these concrete types are converted to the appropriate concrete type when writing.\nNothing values are converted to Missing when writing.","category":"page"},{"location":"tutorial/#Read-Tabular-Data","page":"Tutorial","title":"Read Tabular Data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The XLSX.gettable method returns tabular data from a spreadsheet as a struct XLSX.DataTable that implements Tables.jl interface. You can use it to create a DataFrame from DataFrames.jl. Check the docstring for gettable method for more advanced options.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are also two helper methods XLSX.readtable and XLSX.readto to read from file  directly, as shown in the following examples.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using DataFrames, XLSX\n\njulia> df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\")) # Returns a `Tables.jl` table that `DataFrame` can accept\n3×2 DataFrame\n Row │ HeaderA  HeaderB \n     │ Int64    String  \n─────┼──────────────────\n   1 │       1  first\n   2 │       2  second\n   3 │       3  third\n\njulia> df = XLSX.readto(\"myfile.xlsx\", \"mysheet\", DataFrame) # Returns a `DataFrame` directly.\n3×2 DataFrame\n Row │ HeaderA  HeaderB \n     │ Int64    String  \n─────┼──────────────────\n   1 │       1  first\n   2 │       2  second\n   3 │       3  third\n\n","category":"page"},{"location":"tutorial/#Reading-Cells-as-a-Julia-Matrix","page":"Tutorial","title":"Reading Cells as a Julia Matrix","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use XLSX.readdata or XLSX.getdata to read content as a Julia matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import XLSX\n\njulia> m = XLSX.readdata(\"myfile.xlsx\", \"mysheet!A1:B3\")\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Indexing in a Worksheet will dispatch to XLSX.getdata method.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> xf = XLSX.readxlsx(\"myfile.xlsx\")\nXLSXFile(\"myfile.xlsx\") containing 3 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              mysheet 4x2           A1:B4\n           othersheet 1x1           A1:A1\n                named 1x1           B4:B4\n\njulia> xf[\"mysheet!A1:B3\"]\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n\njulia> sheet = xf[\"mysheet\"]\n4×2 XLSX.Worksheet: [\"mysheet\"](A1:B4)\n\njulia> sheet[\"A1:B3\"]\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But indexing in a single cell will return a single value instead of a matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> sheet[\"A1\"]\n\"HeaderA\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you don't know the desired range in advance, you can take advantage of the XLSX.readtable and XLSX.gettable methods.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> dtable = XLSX.readtable(\"myfile.xlsx\", \"mysheet\")\nXLSX.DataTable(Any[Any[1, 2, 3], Any[\"first\", \"second\", \"third\"]], [:HeaderA, :HeaderB], Dict(:HeaderB => 2, :HeaderA => 1))\n\njulia> m = hcat(dtable.data...)\n3×2 Matrix{Any}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"","category":"page"},{"location":"tutorial/#Reading-Large-Excel-Files-and-Caching","page":"Tutorial","title":"Reading Large Excel Files and Caching","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method XLSX.openxlsx has a enable_cache option to control worksheet cells caching.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Cache is enabled by default, so if you read a worksheet cell twice it will use the cached value instead of reading from disk in the second time.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If enable_cache=false, worksheet cells will always be read from disk. In addition, if enable_cache=false  and openxlsx is used with do-syntax, the xlsx file itself will be opened usning Mmap.mmap so that the  zip archives themselves are not read into memory. This is useful when you want to read a spreadsheet that  doesn't fit into memory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following example shows how you would read worksheet cells, one row at a time, where myfile.xlsx is a spreadsheet that doesn't fit into memory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do f\n           sheet = f[\"mysheet\"]\n           for r in XLSX.eachrow(sheet)\n              # r is a `SheetRow`, values are read using column references\n              rn = XLSX.row_number(r) # `SheetRow` row number\n              v1 = r[1]    # will read value at column 1\n              v2 = r[\"B\"]  # will read value at column 2\n\n              println(\"v1=$v1, v2=$v2\")\n           end\n      end\nv1=HeaderA, v2=HeaderB\nv1=1, v2=first\nv1=2, v2=second\nv1=3, v2=third","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You could also stream tabular data using XLSX.eachtablerow(sheet), which is the underlying iterator in gettable method. Check docstrings for XLSX.eachtablerow for more advanced options.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do f\n           sheet = f[\"mysheet\"]\n           for r in XLSX.eachtablerow(sheet)\n               # r is a `TableRow`, values are read using column labels or numbers\n               rn = XLSX.row_number(r) # `TableRow` row number\n               v1 = r[1] # will read value at table column 1\n               v2 = r[:HeaderB] # will read value at column labeled `:HeaderB`\n\n               println(\"v1=$v1, v2=$v2\")\n            end\n       end\nv1=1, v2=first\nv1=2, v2=second\nv1=3, v2=third","category":"page"},{"location":"tutorial/#Writing-Excel-Files","page":"Tutorial","title":"Writing Excel Files","text":"","category":"section"},{"location":"tutorial/#Create-New-Files","page":"Tutorial","title":"Create New Files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Opening a file in write mode with XLSX.openxlsx will open a new (blank) Excel file for editing.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"XLSX.openxlsx(\"my_new_file.xlsx\", mode=\"w\") do xf\n    sheet = xf[1]\n    XLSX.rename!(sheet, \"new_sheet\")\n    sheet[\"A1\"] = \"this\"\n    sheet[\"A2\"] = \"is a\"\n    sheet[\"A3\"] = \"new file\"\n    sheet[\"A4\"] = 100\n\n    # will add a row from \"A5\" to \"E5\"\n    sheet[\"A5\"] = collect(1:5) # equivalent to `sheet[\"A5\", dim=2] = collect(1:4)`\n\n    # will add a column from \"B1\" to \"B4\"\n    sheet[\"B1\", dim=1] = collect(1:4)\n\n    # will add a matrix from \"A7\" to \"C9\"\n    sheet[\"A7:C9\"] = [ 1 2 3 ; 4 5 6 ; 7 8 9 ]\nend","category":"page"},{"location":"tutorial/#Edit-Existing-Files","page":"Tutorial","title":"Edit Existing Files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Opening a file in read-write mode with XLSX.openxlsx will open an existing Excel file for editing. This will preserve existing data and formatting in the original file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"XLSX.openxlsx(\"my_new_file.xlsx\", mode=\"rw\") do xf\n    sheet = xf[1]\n    sheet[\"B1\"] = \"new data\"\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nUsing do-block syntax in \"rw\" mode will overwrite the file you read in with the modified data when the do block ends. Care is needed to ensure data are not inadvertantly overwritten, especially if the xlsx file contains any elements that XLSX.jl cannot process (such as charts, pivot tables, etc), but that would otherwise be preserved if not overwritten. You may avoid this risk by choosing to open files in \"rw\" mode without using do-block syntax, in which case it becomes necessary explicitly to write the XLSXFile out again, providing the option to write to another file name.","category":"page"},{"location":"tutorial/#Export-Tabular-Data-from-a-Worksheet","page":"Tutorial","title":"Export Tabular Data from a Worksheet","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given a sheet reference, use the XLSX.writetable! method. Anchor cell defaults to cell \"A1\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using XLSX, Test\n\nfilename = \"myfile.xlsx\"\n\ncolumns = Vector()\npush!(columns, [1, 2, 3])\npush!(columns, [\"a\", \"b\", \"c\"])\n\nlabels = [ \"column_1\", \"column_2\"]\n\nXLSX.openxlsx(filename, mode=\"w\") do xf\n    sheet = xf[1]\n    XLSX.writetable!(sheet, columns, labels, anchor_cell=XLSX.CellRef(\"B2\"))\nend\n\n# read data back\nXLSX.openxlsx(filename) do xf\n    sheet = xf[1]\n    @test sheet[\"B2\"] == \"column_1\"\n    @test sheet[\"C2\"] == \"column_2\"\n    @test sheet[\"B3\"] == 1\n    @test sheet[\"B4\"] == 2\n    @test sheet[\"B5\"] == 3\n    @test sheet[\"C3\"] == \"a\"\n    @test sheet[\"C4\"] == \"b\"\n    @test sheet[\"C5\"] == \"c\"\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use XLSX.writetable to write directly to a new file (see next section).","category":"page"},{"location":"tutorial/#Export-Tabular-Data-from-any-Tables.jl-compatible-source","page":"Tutorial","title":"Export Tabular Data from any Tables.jl compatible source","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To export tabular data to Excel, use XLSX.writetable method, which accepts either columns and column names, or any Tables.jl table.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Dates\n\njulia> import DataFrames, XLSX\n\njulia> df = DataFrames.DataFrame(integers=[1, 2, 3, 4], strings=[\"Hey\", \"You\", \"Out\", \"There\"], floats=[10.2, 20.3, 30.4, 40.5], dates=[Date(2018,2,20), Date(2018,2,21), Date(2018,2,22), Date(2018,2,23)], times=[Dates.Time(19,10), Dates.Time(19,20), Dates.Time(19,30), Dates.Time(19,40)], datetimes=[Dates.DateTime(2018,5,20,19,10), Dates.DateTime(2018,5,20,19,20), Dates.DateTime(2018,5,20,19,30), Dates.DateTime(2018,5,20,19,40)])\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats │ dates      │ times    │ datetimes           │\n├─────┼──────────┼─────────┼────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2   │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3   │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4   │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5   │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │\n\njulia> XLSX.writetable(\"df.xlsx\", df)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also export multiple tables to Excel, each table in a separate worksheet, by either passing a tuple (columns, names) to a keyword argument for each sheet name, or a list \"sheet name\" => table pairs for any Tables.jl compatible source.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import DataFrames, XLSX\n\njulia> df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[\"Fist\", \"Sec\", \"Third\"])\n3×2 DataFrames.DataFrame\n│ Row │ COL1 │ COL2  │\n├─────┼──────┼───────┤\n│ 1   │ 10   │ Fist  │\n│ 2   │ 20   │ Sec   │\n│ 3   │ 30   │ Third │\n\njulia> df2 = DataFrames.DataFrame(AA=[\"aa\", \"bb\"], AB=[10.1, 10.2])\n2×2 DataFrames.DataFrame\n│ Row │ AA │ AB   │\n├─────┼────┼──────┤\n│ 1   │ aa │ 10.1 │\n│ 2   │ bb │ 10.2 │\n\njulia> XLSX.writetable(\"report.xlsx\", \"REPORT_A\" => df1, \"REPORT_B\" => df2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This last example shows how to do the same thing, but when you don't know how many tables you'll be exporting in advance.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df1 = DataFrame(A=[1,2], B=[3,4])\ndf2 = DataFrame(C=[\"Hey\", \"you\"], D=[\"out\", \"there\"])\n\nsheet_names = [ \"1st\", \"2nd\" ]\ndataframes = [ df1, df2 ]\n\n@assert length(sheet_names) == length(dataframes)\n\nXLSX.openxlsx(\"report.xlsx\", mode=\"w\") do xf\n    for i in eachindex(sheet_names)\n        sheet_name = sheet_names[i]\n        df = dataframes[i]\n        \n        if i == firstindex(sheet_names)\n            sheet = xf[1]\n            XLSX.rename!(sheet, sheet_name)\n            XLSX.writetable!(sheet, df)\n        else\n            sheet = XLSX.addsheet!(xf, sheet_name)\n            XLSX.writetable!(sheet, df)        \n        end\n    end\nend","category":"page"},{"location":"tutorial/#Tables.jl-interface","page":"Tutorial","title":"Tables.jl interface","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Both types XLSX.DataTable and XLSX.TableRowIterator conforms to Tables.jl interface. An instance of XLSX.TableRowIterator is created by the function XLSX.eachtablerow.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Also, XLSX.writetable accepts an argument that conforms to the Tables.jl interface.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As an example, the type DataFrame from DataFrames package supports the Tables.jl interface. The following code writes and reads back a DataFrame to an Excel file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Dates\n\njulia> import DataFrames, XLSX\n\njulia> df = DataFrames.DataFrame(integers=[1, 2, 3, 4], strings=[\"Hey\", \"You\", \"Out\", \"There\"], floats=[10.2, 20.3, 30.4, 40.5], dates=[Date(2018,2,20), Date(2018,2,21), Date(2018,2,22), Date(2018,2,23)], times=[Dates.Time(19,10), Dates.Time(19,20), Dates.Time(19,30), Dates.Time(19,40)], datetimes=[Dates.DateTime(2018,5,20,19,10), Dates.DateTime(2018,5,20,19,20), Dates.DateTime(2018,5,20,19,30), Dates.DateTime(2018,5,20,19,40)])\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats  │ dates      │ times    │ datetimes           │\n│     │ Int64    │ String  │ Float64 │ Date       │ Time     │ DateTime            │\n├─────┼──────────┼─────────┼─────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2    │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3    │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4    │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5    │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │\n\njulia> XLSX.writetable(\"output_table.xlsx\", df, overwrite=true, sheetname=\"report\", anchor_cell=\"B2\")\n\njulia> f = XLSX.readxlsx(\"output_table.xlsx\")\nXLSXFile(\"output_table.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               report 6x7           A1:G6\n\n\njulia> s = f[\"report\"]\n6×7 XLSX.Worksheet: [\"report\"](A1:G6)\n\njulia> df2 = XLSX.eachtablerow(s) |> DataFrames.DataFrame\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats  │ dates      │ times    │ datetimes           │\n│     │ Int64    │ String  │ Float64 │ Date       │ Time     │ DateTime            │\n├─────┼──────────┼─────────┼─────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2    │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3    │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4    │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5    │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │","category":"page"}]
}
