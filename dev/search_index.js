var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"XLSX.XLSXFile\nXLSX.readxlsx\nXLSX.openxlsx\nXLSX.writexlsx\nXLSX.sheetnames\nXLSX.sheetcount\nXLSX.hassheet\nXLSX.Worksheet\nXLSX.readdata\nXLSX.getdata\nXLSX.getcell\nXLSX.getcellrange\nXLSX.row_number\nXLSX.column_number\nXLSX.eachrow\nXLSX.readtable\nXLSX.gettable\nXLSX.eachtablerow\nXLSX.writetable\nXLSX.writetable!\nXLSX.rename!\nXLSX.addsheet!","category":"page"},{"location":"api/#XLSX.XLSXFile","page":"API Reference","title":"XLSX.XLSXFile","text":"XLSXFile represents a reference to an Excel file.\n\nIt is created by using XLSX.readxlsx or XLSX.openxlsx.\n\nFrom a XLSXFile you can navigate to a XLSX.Worksheet reference as shown in the example below.\n\nExample\n\nxf = XLSX.readxlsx(\"myfile.xlsx\")\nsh = xf[\"mysheet\"] # get a reference to a Worksheet\n\n\n\n\n\n","category":"type"},{"location":"api/#XLSX.readxlsx","page":"API Reference","title":"XLSX.readxlsx","text":"readxlsx(source::Union{AbstractString, IO}) :: XLSXFile\n\nMain function for reading an Excel file. This function will read the whole Excel file into memory and return a closed XLSXFile.\n\nConsider using XLSX.openxlsx for lazy loading of Excel file contents.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.openxlsx","page":"API Reference","title":"XLSX.openxlsx","text":"openxlsx(f::F, source::Union{AbstractString, IO}; mode::AbstractString=\"r\", enable_cache::Bool=true) where {F<:Function}\n\nOpen XLSX file for reading and/or writing. It returns an opened XLSXFile that will be automatically closed after applying f to the file.\n\nDo syntax\n\nThis function should be used with do syntax, like in:\n\nXLSX.openxlsx(\"myfile.xlsx\") do xf\n    # read data from `xf`\nend\n\nFilemodes\n\nThe mode argument controls how the file is opened. The following modes are allowed:\n\nr : read mode. The existing data in source will be accessible for reading. This is the default mode.\nw : write mode. Opens an empty file that will be written to source.\nrw : edit mode. Opens source for editing. The file will be saved to disk when the function ends.\n\nwarning: Warning\nThe rw mode is known to produce some data loss. See #159.Simple data should work fine. Users are advised to use this feature with caution when working with formulas and charts.\n\nArguments\n\nsource is IO or the complete path to the file.\nmode is the file mode, as explained in the last section.\nenable_cache:\n\nIf enable_cache=true, all read worksheet cells will be cached. If you read a worksheet cell twice it will use the cached value instead of reading from disk the second time.\n\nIf enable_cache=false, worksheet cells will always be read from disk. This is useful when you want to read a spreadsheet that doesn't fit into memory.\n\nThe default value is enable_cache=true.\n\nExamples\n\nRead from file\n\nThe following example shows how you would read worksheet cells, one row at a time, where myfile.xlsx is a spreadsheet that doesn't fit into memory.\n\njulia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do xf\n          for r in XLSX.eachrow(xf[\"mysheet\"])\n              # read something from row `r`\n          end\n       end\n\nWrite a new file\n\nXLSX.openxlsx(\"new.xlsx\", mode=\"w\") do xf\n    sheet = xf[1]\n    sheet[1, :] = [1, Date(2018, 1, 1), \"test\"]\nend\n\nEdit an existing file\n\nXLSX.openxlsx(\"edit.xlsx\", mode=\"rw\") do xf\n    sheet = xf[1]\n    sheet[2, :] = [2, Date(2019, 1, 1), \"add new line\"]\nend\n\nSee also XLSX.readxlsx.\n\n\n\n\n\nopenxlsx(source::Union{AbstractString, IO}; mode=\"r\", enable_cache=true) :: XLSXFile\n\nSupports opening a XLSX file without using do-syntax. In this case, the user is responsible for closing the XLSXFile using close or writing it to file using XLSX.writexlsx.\n\nSee also XLSX.writexlsx.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.writexlsx","page":"API Reference","title":"XLSX.writexlsx","text":"writexlsx(output_source, xlsx_file; [overwrite=false])\n\nWrites an Excel file given by xlsx_file::XLSXFile to IO or filepath output_source.\n\nIf overwrite=true, output_source (when a filepath) will be overwritten if it exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.sheetnames","page":"API Reference","title":"XLSX.sheetnames","text":"sheetnames(xl::XLSXFile)\nsheetnames(wb::Workbook)\n\nReturns a vector with Worksheet names for this Workbook.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.sheetcount","page":"API Reference","title":"XLSX.sheetcount","text":"sheetcount(xlsfile) :: Int\n\nCounts the number of sheets in the Workbook.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.hassheet","page":"API Reference","title":"XLSX.hassheet","text":"hassheet(wb::Workbook, sheetname::AbstractString)\nhassheet(xl::XLSXFile, sheetname::AbstractString)\n\nReturns true if wb contains a sheet named sheetname.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.Worksheet","page":"API Reference","title":"XLSX.Worksheet","text":"A Worksheet represents a reference to an Excel Worksheet.\n\nFrom a Worksheet you can query for Cells, cell values and ranges.\n\nExample\n\nxf = XLSX.readxlsx(\"myfile.xlsx\")\nsh = xf[\"mysheet\"] # get a reference to a Worksheet\nprintln( sh[2, 2] ) # access element \"B2\" (2nd row, 2nd column)\nprintln( sh[\"B2\"] ) # you can also use the cell name\nprintln( sh[\"A2:B4\"] ) # or a cell range\nprintln( sh[:] ) # all data inside worksheet's dimension\n\n\n\n\n\n","category":"type"},{"location":"api/#XLSX.readdata","page":"API Reference","title":"XLSX.readdata","text":"readdata(source, sheet, ref)\nreaddata(source, sheetref)\n\nReturns a scalar or matrix with values from a spreadsheet.\n\nSee also XLSX.getdata.\n\nExamples\n\nThese function calls are equivalent.\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet\", \"A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", 1, \"A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet!A2:B4\")\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.getdata","page":"API Reference","title":"XLSX.getdata","text":"getdata(sheet, ref)\ngetdata(sheet, row, column)\n\nReturns a scalar or a matrix with values from a spreadsheet. ref can be a cell reference or a range.\n\nIndexing in a Worksheet will dispatch to getdata method.\n\nExample\n\njulia> f = XLSX.readxlsx(\"myfile.xlsx\")\n\njulia> sheet = f[\"mysheet\"]\n\njulia> matrix = sheet[\"A1:B4\"]\n\njulia> single_value = sheet[2, 2] # B2\n\nSee also XLSX.readdata.\n\n\n\n\n\ngetdata(ws::Worksheet, cell::Cell) :: CellValue\n\nReturns a Julia representation of a given cell value. The result data type is chosen based on the value of the cell as well as its style.\n\nFor example, date is stored as integers inside the spreadsheet, and the style is the information that is taken into account to chose Date as the result type.\n\nFor numbers, if the style implies that the number is visualized with decimals, the method will return a float, even if the underlying number is stored as an integer inside the spreadsheet XML.\n\nIf cell has empty value or empty String, this function will return missing.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.getcell","page":"API Reference","title":"XLSX.getcell","text":"getcell(xlsxfile, cell_reference_name) :: AbstractCell\ngetcell(worksheet, cell_reference_name) :: AbstractCell\ngetcell(sheetrow, column_name) :: AbstractCell\ngetcell(sheetrow, column_number) :: AbstractCell\n\nReturns the internal representation of a worksheet cell.\n\nReturns XLSX.EmptyCell if the cell has no data.\n\n\n\n\n\ngetcell(sheet, ref)\n\nReturns an AbstractCell that represents a cell in the spreadsheet.\n\nExample:\n\njulia> xf = XLSX.readxlsx(\"myfile.xlsx\")\n\njulia> sheet = xf[\"mysheet\"]\n\njulia> cell = XLSX.getcell(sheet, \"A1\")\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.getcellrange","page":"API Reference","title":"XLSX.getcellrange","text":"getcellrange(sheet, rng)\n\nReturns a matrix with cells as Array{AbstractCell, 2}. rng must be a valid cell range, as in \"A1:B2\".\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.row_number","page":"API Reference","title":"XLSX.row_number","text":"row_number(c::CellRef) :: Int\n\nReturns the row number of a given cell reference.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.column_number","page":"API Reference","title":"XLSX.column_number","text":"column_number(c::CellRef) :: Int\n\nReturns the column number of a given cell reference.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.eachrow","page":"API Reference","title":"XLSX.eachrow","text":"eachrow(sheet)\n\nCreates a row iterator for a worksheet.\n\nExample: Query all cells from columns 1 to 4.\n\nleft = 1  # 1st column\nright = 4 # 4th column\nfor sheetrow in XLSX.eachrow(sheet)\n    for column in left:right\n        cell = XLSX.getcell(sheetrow, column)\n\n        # do something with cell\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.readtable","page":"API Reference","title":"XLSX.readtable","text":"readtable(\n    source,\n    sheet,\n    [columns];\n    [first_row],\n    [column_labels],\n    [header],\n    [infer_eltypes],\n    [stop_in_empty_row],\n    [stop_in_row_function],\n    [keep_empty_rows]\n) -> DataTable\n\nReturns tabular data from a spreadsheet as a struct XLSX.DataTable. Use this function to create a DataFrame from package DataFrames.jl.\n\nUse columns argument to specify which columns to get. For example, \"B:D\" will select columns B, C and D. If columns is not given, the algorithm will find the first sequence of consecutive non-empty cells.\n\nUse first_row to indicate the first row from the table. first_row=5 will look for a table starting at sheet row 5. If first_row is not given, the algorithm will look for the first non-empty row in the spreadsheet.\n\nheader is a Bool indicating if the first row is a header. If header=true and column_labels is not specified, the column labels for the table will be read from the first row of the table. If header=false and column_labels is not specified, the algorithm will generate column labels. The default value is header=true.\n\nUse column_labels to specify names for the header of the table.\n\nUse infer_eltypes=true to get data as a Vector{Any} of typed vectors. The default value is infer_eltypes=false.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the end of the table. If stop_in_empty_row=false, the TableRowIterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is stop_in_empty_row=true.\n\nstop_in_row_function is a Function that receives a TableRow and returns a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function:\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nkeep_empty_rows determines whether rows where all column values are equal to missing are kept (true) or dropped (false) from the resulting table.  keep_empty_rows never affects the bounds of the table; the number of rows read from a sheet is only affected by, first_row, stop_in_empty_row and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.\n\nExample\n\njulia> using DataFrames, XLSX\n\njulia> df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\"))\n\nSee also: XLSX.gettable.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.gettable","page":"API Reference","title":"XLSX.gettable","text":"gettable(\n    sheet,\n    [columns];\n    [first_row],\n    [column_labels],\n    [header],\n    [infer_eltypes],\n    [stop_in_empty_row],\n    [stop_in_row_function],\n    [keep_empty_rows]\n) -> DataTable\n\nReturns tabular data from a spreadsheet as a struct XLSX.DataTable. Use this function to create a DataFrame from package DataFrames.jl.\n\nUse columns argument to specify which columns to get. For example, \"B:D\" will select columns B, C and D. If columns is not given, the algorithm will find the first sequence of consecutive non-empty cells.\n\nUse first_row to indicate the first row from the table. first_row=5 will look for a table starting at sheet row 5. If first_row is not given, the algorithm will look for the first non-empty row in the spreadsheet.\n\nheader is a Bool indicating if the first row is a header. If header=true and column_labels is not specified, the column labels for the table will be read from the first row of the table. If header=false and column_labels is not specified, the algorithm will generate column labels. The default value is header=true.\n\nUse column_labels as a vector of symbols to specify names for the header of the table.\n\nUse infer_eltypes=true to get data as a Vector{Any} of typed vectors. The default value is infer_eltypes=false.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the end of the table. If stop_in_empty_row=false, the TableRowIterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is stop_in_empty_row=true.\n\nstop_in_row_function is a Function that receives a TableRow and returns a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nkeep_empty_rows determines whether rows where all column values are equal to missing are kept (true) or dropped (false) from the resulting table. keep_empty_rows never affects the bounds of the table; the number of rows read from a sheet is only affected by first_row, stop_in_empty_row and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.\n\nExample\n\njulia> using DataFrames, XLSX\n\njulia> df = XLSX.openxlsx(\"myfile.xlsx\") do xf\n        DataFrame(XLSX.gettable(xf[\"mysheet\"]))\n    end\n\nSee also: XLSX.readtable.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.eachtablerow","page":"API Reference","title":"XLSX.eachtablerow","text":"eachtablerow(sheet, [columns]; [first_row], [column_labels], [header], [stop_in_empty_row], [stop_in_row_function], [keep_empty_rows])\n\nConstructs an iterator of table rows. Each element of the iterator is of type TableRow.\n\nheader is a boolean indicating whether the first row of the table is a table header.\n\nIf header == false and no column_labels were supplied, column names will be generated following the column names found in the Excel file.\n\nThe columns argument is a column range, as in \"B:E\". If columns is not supplied, the column range will be inferred by the non-empty contiguous cells in the first row of the table.\n\nThe user can replace column names by assigning the optional column_labels input variable with a Vector{Symbol}.\n\nstop_in_empty_row is a boolean indicating whether an empty row marks the end of the table. If stop_in_empty_row=false, the iterator will continue to fetch rows until there's no more rows in the Worksheet. The default behavior is stop_in_empty_row=true. Empty rows may be returned by the iterator when stop_in_empty_row=false.\n\nstop_in_row_function is a Function that receives a TableRow and returns a Bool indicating if the end of the table was reached.\n\nExample for stop_in_row_function:\n\nfunction stop_function(r)\n    v = r[:col_label]\n    return !ismissing(v) && v == \"unwanted value\"\nend\n\nkeep_empty_rows determines whether rows where all column values are equal to missing are kept (true) or skipped (false) by the row iterator. keep_empty_rows never affects the bounds of the iterator; the number of rows read from a sheet is only affected by first_row, stop_in_empty_row and stop_in_row_function (if specified). keep_empty_rows is only checked once the first and last row of the table have been determined, to see whether to keep or drop empty rows between the first and the last row.\n\nExample code:\n\nfor r in XLSX.eachtablerow(sheet)\n    # r is a `TableRow`. Values are read using column labels or numbers.\n    rn = XLSX.row_number(r) # `TableRow` row number.\n    v1 = r[1] # will read value at table column 1.\n    v2 = r[:COL_LABEL2] # will read value at column labeled `:COL_LABEL2`.\nend\n\nSee also XLSX.gettable.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.writetable","page":"API Reference","title":"XLSX.writetable","text":"writetable(filename, table; [overwrite], [sheetname])\n\nWrite Tables.jl table to the specified filename.\n\n\n\n\n\nwritetable(filename::Union{AbstractString, IO}, tables::Vector{Pair{String, T}}; overwrite::Bool=false)\nwritetable(filename::Union{AbstractString, IO}, tables::Pair{String, Any}...; overwrite::Bool=false)\n\n\n\n\n\nwritetable(filename, data, columnnames; [overwrite], [sheetname])\n\ndata is a vector of columns.\ncolumnames is a vector of column labels.\noverwrite is a Bool to control if filename should be overwritten if already exists.\nsheetname is the name for the worksheet.\n\nExample\n\nimport XLSX\ncolumns = [ [1, 2, 3, 4], [\"Hey\", \"You\", \"Out\", \"There\"], [10.2, 20.3, 30.4, 40.5] ]\ncolnames = [ \"integers\", \"strings\", \"floats\" ]\nXLSX.writetable(\"table.xlsx\", columns, colnames)\n\nSee also: XLSX.writetable!.\n\n\n\n\n\nwritetable(filename::Union{AbstractString, IO}; overwrite::Bool=false, kw...)\nwritetable(filename::Union{AbstractString, IO}, tables::Vector{Tuple{String, Vector{Any}, Vector{String}}}; overwrite::Bool=false)\n\nWrite multiple tables.\n\nkw is a variable keyword argument list. Each element should be in this format: sheetname=( data, column_names ), where data is a vector of columns and column_names is a vector of column labels.\n\nExample:\n\njulia> import DataFrames, XLSX\n\njulia> df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[\"Fist\", \"Sec\", \"Third\"])\n\njulia> df2 = DataFrames.DataFrame(AA=[\"aa\", \"bb\"], AB=[10.1, 10.2])\n\njulia> XLSX.writetable(\"report.xlsx\", \"REPORT_A\" => df1, \"REPORT_B\" => df2)\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.writetable!","page":"API Reference","title":"XLSX.writetable!","text":"writetable!(sheet::Worksheet, table; anchor_cell::CellRef=CellRef(\"A1\")))\n\nWrite Tables.jl table to the specified sheet.\n\n\n\n\n\nwritetable!(\n    sheet::Worksheet,\n    data,\n    columnnames;\n    anchor_cell::CellRef=CellRef(\"A1\"),\n    write_columnnames::Bool=true,\n)\n\nWrites tabular data data with labels given by columnnames to sheet, starting at anchor_cell.\n\ndata must be a vector of columns. columnnames must be a vector of column labels.\n\nSee also: XLSX.writetable.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.rename!","page":"API Reference","title":"XLSX.rename!","text":"rename!(ws::Worksheet, name::AbstractString)\n\nRenames a Worksheet.\n\n\n\n\n\n","category":"function"},{"location":"api/#XLSX.addsheet!","page":"API Reference","title":"XLSX.addsheet!","text":"addsheet!(workbook, [name]) :: Worksheet\n\nCreate a new worksheet with named name. If name is not provided, a unique name is created.\n\n\n\n\n\n","category":"function"},{"location":"#XLSX.jl","page":"Home","title":"XLSX.jl","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"XLSX.jl is a Julia package to read and write Excel spreadsheet files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Internally, an Excel XLSX file is just a Zip file with a set of XML files inside. The formats for these XML files are described in the Standard ECMA-376.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package follows the EMCA-376 to parse and generate XLSX files.","category":"page"},{"location":"#Requirements","page":"Home","title":"Requirements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia v1.6\nLinux, macOS or Windows.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"From a Julia session, run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"XLSX\")","category":"page"},{"location":"#Source-Code","page":"Home","title":"Source Code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code for this package is hosted at https://github.com/felipenoris/XLSX.jl.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The source code for the package XLSX.jl is licensed under the MIT License.","category":"page"},{"location":"#Getting-Help","page":"Home","title":"Getting Help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you're having any trouble, have any questions about this package or want to ask for a new feature, just open a new issue.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are always welcome!","category":"page"},{"location":"","page":"Home","title":"Home","text":"To contribute, fork the project on GitHub and send a Pull Request.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ECMA Open XML White Paper\nECMA-376\nExcel file limits","category":"page"},{"location":"#Alternative-Packages","page":"Home","title":"Alternative Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ExcelFiles.jl\nExcelReaders.jl\nXLSXReader.jl\nTaro.jl","category":"page"},{"location":"migration/#Migration-Guides","page":"Migration Guides","title":"Migration Guides","text":"","category":"section"},{"location":"migration/#Migrating-Legacy-Code-to-v0.8","page":"Migration Guides","title":"Migrating Legacy Code to v0.8","text":"","category":"section"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"Version v0.8 introduced a breaking change on methods XLSX.gettable and XLSX.readtable.","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"These methods used to return a tuple data, column_labels. On XLSX v0.8 these methods return a XLSX.DataTable struct that implements Tables.jl interface.","category":"page"},{"location":"migration/#Basic-code-replacement","page":"Migration Guides","title":"Basic code replacement","text":"","category":"section"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"Before","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"data, col_names = XLSX.readtable(joinpath(data_directory, \"general.xlsx\"), \"table4\")","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"After","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"dtable = XLSX.readtable(joinpath(data_directory, \"general.xlsx\"), \"table4\")\ndata, col_names = dtable.data, dtable.column_labels","category":"page"},{"location":"migration/#Reading-DataFrames","page":"Migration Guides","title":"Reading DataFrames","text":"","category":"section"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"Since XLSX.DataTable implements Tables.jl interface, the result of XLSX.gettable or XLSX.readtable can be passed to a DataFrame constructor.","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"Before","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\")...)","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"After","category":"page"},{"location":"migration/","page":"Migration Guides","title":"Migration Guides","text":"df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\"))","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Setup","page":"Tutorial","title":"Setup","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First, make sure you have XLSX.jl package installed.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Pkg\n\njulia> Pkg.add(\"XLSX\")","category":"page"},{"location":"tutorial/#Getting-Started","page":"Tutorial","title":"Getting Started","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The basic usage is to read an Excel file and read values.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import XLSX\n\njulia> xf = XLSX.readxlsx(\"myfile.xlsx\")\nXLSXFile(\"myfile.xlsx\") containing 3 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              mysheet 4x2           A1:B4\n           othersheet 1x1           A1:A1\n                named 1x1           B4:B4\n\njulia> XLSX.sheetnames(xf)\n3-element Array{String,1}:\n \"mysheet\"\n \"othersheet\"\n \"named\"\n\njulia> sh = xf[\"mysheet\"] # get a reference to a Worksheet\n4×2 XLSX.Worksheet: [\"mysheet\"](A1:B4)\n\njulia> sh[2, 2] # access element \"B2\" (2nd row, 2nd column)\n\"first\"\n\njulia> sh[\"B2\"] # you can also use the cell name\n\"first\"\n\njulia> sh[\"A2:B4\"] # or a cell range\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> XLSX.readdata(\"myfile.xlsx\", \"mysheet\", \"A2:B4\") # shorthand for all above\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> sh[:] # all data inside worksheet's dimension\n4×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n 3           \"third\"\n\njulia> xf[\"mysheet!A2:B4\"] # you can also query values using a sheet reference\n3×2 Array{Any,2}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"\n\njulia> xf[\"NAMED_CELL\"] # you can even read named ranges\n\"B4 is a named cell from sheet \\\"named\\\"\"\n\njulia> xf[\"mysheet!A:B\"] # Column ranges are also supported\n4×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n 3           \"third\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To inspect the internal representation of each cell, use the getcell or getcellrange methods.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The example above used xf = XLSX.readxlsx(filename) to open a file, so all file contents are fetched at once from disk.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use XLSX.openxlsx to read file contents as needed (see Reading Large Excel Files and Caching).","category":"page"},{"location":"tutorial/#Data-Types","page":"Tutorial","title":"Data Types","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This package uses the following concrete types when handling XLSX files.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"XLSX.CellValueType","category":"page"},{"location":"tutorial/#XLSX.CellValueType","page":"Tutorial","title":"XLSX.CellValueType","text":"CellValueType\n\nConcrete supported data-types.\n\nUnion{String, Missing, Float64, Int, Bool, Dates.Date, Dates.Time, Dates.DateTime}\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Abstract types of these concrete types are converted to the appropriate concrete type when writing.\nNothing values are converted to Missing when writing.","category":"page"},{"location":"tutorial/#Read-Tabular-Data","page":"Tutorial","title":"Read Tabular Data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The XLSX.gettable method returns tabular data from a spreadsheet as a struct XLSX.DataTable that implements Tables.jl interface. You can use it to create a DataFrame from DataFrames.jl. Check the docstring for gettable method for more advanced options.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There's also a helper method XLSX.readtable to read from file directly, as shown in the following example.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using DataFrames, XLSX\n\njulia> df = DataFrame(XLSX.readtable(\"myfile.xlsx\", \"mysheet\"))\n3×2 DataFrames.DataFrame\n│ Row │ HeaderA │ HeaderB  │\n├─────┼─────────┼──────────┤\n│ 1   │ 1       │ \"first\"  │\n│ 2   │ 2       │ \"second\" │\n│ 3   │ 3       │ \"third\"  │","category":"page"},{"location":"tutorial/#Reading-Cells-as-a-Julia-Matrix","page":"Tutorial","title":"Reading Cells as a Julia Matrix","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use XLSX.readdata or XLSX.getdata to read content as a Julia matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import XLSX\n\njulia> m = XLSX.readdata(\"myfile.xlsx\", \"mysheet!A1:B3\")\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Indexing in a Worksheet will dispatch to XLSX.getdata method.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> xf = XLSX.readxlsx(\"myfile.xlsx\")\nXLSXFile(\"myfile.xlsx\") containing 3 Worksheets\n            sheetname size          range\n-------------------------------------------------\n              mysheet 4x2           A1:B4\n           othersheet 1x1           A1:A1\n                named 1x1           B4:B4\n\njulia> xf[\"mysheet!A1:B3\"]\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"\n\njulia> sheet = xf[\"mysheet\"]\n4×2 XLSX.Worksheet: [\"mysheet\"](A1:B4)\n\njulia> sheet[\"A1:B3\"]\n3×2 Array{Any,2}:\n  \"HeaderA\"  \"HeaderB\"\n 1           \"first\"\n 2           \"second\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"But indexing in a single cell will return a single value instead of a matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> sheet[\"A1\"]\n\"HeaderA\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you don't know the desired range in advance, you can take advantage of the XLSX.readtable and XLSX.gettable methods.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> dtable = XLSX.readtable(\"myfile.xlsx\", \"mysheet\")\nXLSX.DataTable(Any[Any[1, 2, 3], Any[\"first\", \"second\", \"third\"]], [:HeaderA, :HeaderB], Dict(:HeaderB => 2, :HeaderA => 1))\n\njulia> m = hcat(dtable.data...)\n3×2 Matrix{Any}:\n 1  \"first\"\n 2  \"second\"\n 3  \"third\"","category":"page"},{"location":"tutorial/#Reading-Large-Excel-Files-and-Caching","page":"Tutorial","title":"Reading Large Excel Files and Caching","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The method XLSX.openxlsx has a enable_cache option to control worksheet cells caching.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Cache is enabled by default, so if you read a worksheet cell twice it will use the cached value instead of reading from disk in the second time.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If enable_cache=false, worksheet cells will always be read from disk. This is useful when you want to read a spreadsheet that doesn't fit into memory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The following example shows how you would read worksheet cells, one row at a time, where myfile.xlsx is a spreadsheet that doesn't fit into memory.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do f\n           sheet = f[\"mysheet\"]\n           for r in XLSX.eachrow(sheet)\n              # r is a `SheetRow`, values are read using column references\n              rn = XLSX.row_number(r) # `SheetRow` row number\n              v1 = r[1]    # will read value at column 1\n              v2 = r[\"B\"]  # will read value at column 2\n\n              println(\"v1=$v1, v2=$v2\")\n           end\n      end\nv1=HeaderA, v2=HeaderB\nv1=1, v2=first\nv1=2, v2=second\nv1=3, v2=third","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You could also stream tabular data using XLSX.eachtablerow(sheet), which is the underlying iterator in gettable method. Check docstrings for XLSX.eachtablerow for more advanced options.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> XLSX.openxlsx(\"myfile.xlsx\", enable_cache=false) do f\n           sheet = f[\"mysheet\"]\n           for r in XLSX.eachtablerow(sheet)\n               # r is a `TableRow`, values are read using column labels or numbers\n               rn = XLSX.row_number(r) # `TableRow` row number\n               v1 = r[1] # will read value at table column 1\n               v2 = r[:HeaderB] # will read value at column labeled `:HeaderB`\n\n               println(\"v1=$v1, v2=$v2\")\n            end\n       end\nv1=1, v2=first\nv1=2, v2=second\nv1=3, v2=third","category":"page"},{"location":"tutorial/#Writing-Excel-Files","page":"Tutorial","title":"Writing Excel Files","text":"","category":"section"},{"location":"tutorial/#Create-New-Files","page":"Tutorial","title":"Create New Files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Opening a file in write mode with XLSX.openxlsx will open a new (blank) Excel file for editing.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"XLSX.openxlsx(\"my_new_file.xlsx\", mode=\"w\") do xf\n    sheet = xf[1]\n    XLSX.rename!(sheet, \"new_sheet\")\n    sheet[\"A1\"] = \"this\"\n    sheet[\"A2\"] = \"is a\"\n    sheet[\"A3\"] = \"new file\"\n    sheet[\"A4\"] = 100\n\n    # will add a row from \"A5\" to \"E5\"\n    sheet[\"A5\"] = collect(1:5) # equivalent to `sheet[\"A5\", dim=2] = collect(1:4)`\n\n    # will add a column from \"B1\" to \"B4\"\n    sheet[\"B1\", dim=1] = collect(1:4)\n\n    # will add a matrix from \"A7\" to \"C9\"\n    sheet[\"A7:C9\"] = [ 1 2 3 ; 4 5 6 ; 7 8 9 ]\nend","category":"page"},{"location":"tutorial/#Edit-Existing-Files","page":"Tutorial","title":"Edit Existing Files","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Opening a file in read-write mode with XLSX.openxlsx will open an existing Excel file for editing. This will preserve existing data in the original file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"XLSX.openxlsx(\"my_new_file.xlsx\", mode=\"rw\") do xf\n    sheet = xf[1]\n    sheet[\"B1\"] = \"new data\"\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"warning: Warning\nThe read-write mode is known to produce some data loss. See #159.Simple data should work fine. Users are advised to use this feature with caution when working with formulas and charts.","category":"page"},{"location":"tutorial/#Export-Tabular-Data-from-a-Worksheet","page":"Tutorial","title":"Export Tabular Data from a Worksheet","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given a sheet reference, use the XLSX.writetable! method. Anchor cell defaults to cell \"A1\".","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using XLSX, Test\n\nfilename = \"myfile.xlsx\"\n\ncolumns = Vector()\npush!(columns, [1, 2, 3])\npush!(columns, [\"a\", \"b\", \"c\"])\n\nlabels = [ \"column_1\", \"column_2\"]\n\nXLSX.openxlsx(filename, mode=\"w\") do xf\n    sheet = xf[1]\n    XLSX.writetable!(sheet, columns, labels, anchor_cell=XLSX.CellRef(\"B2\"))\nend\n\n# read data back\nXLSX.openxlsx(filename) do xf\n    sheet = xf[1]\n    @test sheet[\"B2\"] == \"column_1\"\n    @test sheet[\"C2\"] == \"column_2\"\n    @test sheet[\"B3\"] == 1\n    @test sheet[\"B4\"] == 2\n    @test sheet[\"B5\"] == 3\n    @test sheet[\"C3\"] == \"a\"\n    @test sheet[\"C4\"] == \"b\"\n    @test sheet[\"C5\"] == \"c\"\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also use XLSX.writetable to write directly to a new file (see next section).","category":"page"},{"location":"tutorial/#Export-Tabular-Data-from-any-Tables.jl-compatible-source","page":"Tutorial","title":"Export Tabular Data from any Tables.jl compatible source","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To export tabular data to Excel, use XLSX.writetable method, which accepts either columns and column names, or any Tables.jl table.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Dates\n\njulia> import DataFrames, XLSX\n\njulia> df = DataFrames.DataFrame(integers=[1, 2, 3, 4], strings=[\"Hey\", \"You\", \"Out\", \"There\"], floats=[10.2, 20.3, 30.4, 40.5], dates=[Date(2018,2,20), Date(2018,2,21), Date(2018,2,22), Date(2018,2,23)], times=[Dates.Time(19,10), Dates.Time(19,20), Dates.Time(19,30), Dates.Time(19,40)], datetimes=[Dates.DateTime(2018,5,20,19,10), Dates.DateTime(2018,5,20,19,20), Dates.DateTime(2018,5,20,19,30), Dates.DateTime(2018,5,20,19,40)])\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats │ dates      │ times    │ datetimes           │\n├─────┼──────────┼─────────┼────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2   │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3   │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4   │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5   │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │\n\njulia> XLSX.writetable(\"df.xlsx\", df)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can also export multiple tables to Excel, each table in a separate worksheet, by either passing a tuple (columns, names) to a keyword argument for each sheet name, or a list \"sheet name\" => table pairs for any Tables.jl compatible source.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> import DataFrames, XLSX\n\njulia> df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[\"Fist\", \"Sec\", \"Third\"])\n3×2 DataFrames.DataFrame\n│ Row │ COL1 │ COL2  │\n├─────┼──────┼───────┤\n│ 1   │ 10   │ Fist  │\n│ 2   │ 20   │ Sec   │\n│ 3   │ 30   │ Third │\n\njulia> df2 = DataFrames.DataFrame(AA=[\"aa\", \"bb\"], AB=[10.1, 10.2])\n2×2 DataFrames.DataFrame\n│ Row │ AA │ AB   │\n├─────┼────┼──────┤\n│ 1   │ aa │ 10.1 │\n│ 2   │ bb │ 10.2 │\n\njulia> XLSX.writetable(\"report.xlsx\", \"REPORT_A\" => df1, \"REPORT_B\" => df2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This last example shows how to do the same thing, but when you don't know how many tables you'll be exporting in advance.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df1 = DataFrame(A=[1,2], B=[3,4])\ndf2 = DataFrame(C=[\"Hey\", \"you\"], D=[\"out\", \"there\"])\n\nsheet_names = [ \"1st\", \"2nd\" ]\ndataframes = [ df1, df2 ]\n\n@assert length(sheet_names) == length(dataframes)\n\nXLSX.openxlsx(\"report.xlsx\", mode=\"w\") do xf\n    for i in eachindex(sheet_names)\n        sheet_name = sheet_names[i]\n        df = dataframes[i]\n        \n        if i == firstindex(sheet_names)\n            sheet = xf[1]\n            XLSX.rename!(sheet, sheet_name)\n            XLSX.writetable!(sheet, df)\n        else\n            sheet = XLSX.addsheet!(xf, sheet_name)\n            XLSX.writetable!(sheet, df)        \n        end\n    end\nend","category":"page"},{"location":"tutorial/#Tables.jl-interface","page":"Tutorial","title":"Tables.jl interface","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Both types XLSX.DataTable and XLSX.TableRowIterator conforms to Tables.jl interface. An instance of XLSX.TableRowIterator is created by the function XLSX.eachtablerow.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Also, XLSX.writetable accepts an argument that conforms to the Tables.jl interface.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As an example, the type DataFrame from DataFrames package supports the Tables.jl interface. The following code writes and reads back a DataFrame to an Excel file.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Dates\n\njulia> import DataFrames, XLSX\n\njulia> df = DataFrames.DataFrame(integers=[1, 2, 3, 4], strings=[\"Hey\", \"You\", \"Out\", \"There\"], floats=[10.2, 20.3, 30.4, 40.5], dates=[Date(2018,2,20), Date(2018,2,21), Date(2018,2,22), Date(2018,2,23)], times=[Dates.Time(19,10), Dates.Time(19,20), Dates.Time(19,30), Dates.Time(19,40)], datetimes=[Dates.DateTime(2018,5,20,19,10), Dates.DateTime(2018,5,20,19,20), Dates.DateTime(2018,5,20,19,30), Dates.DateTime(2018,5,20,19,40)])\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats  │ dates      │ times    │ datetimes           │\n│     │ Int64    │ String  │ Float64 │ Date       │ Time     │ DateTime            │\n├─────┼──────────┼─────────┼─────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2    │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3    │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4    │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5    │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │\n\njulia> XLSX.writetable(\"output_table.xlsx\", df, overwrite=true, sheetname=\"report\", anchor_cell=\"B2\")\n\njulia> f = XLSX.readxlsx(\"output_table.xlsx\")\nXLSXFile(\"output_table.xlsx\") containing 1 Worksheet\n            sheetname size          range\n-------------------------------------------------\n               report 6x7           A1:G6\n\n\njulia> s = f[\"report\"]\n6×7 XLSX.Worksheet: [\"report\"](A1:G6)\n\njulia> df2 = XLSX.eachtablerow(s) |> DataFrames.DataFrame\n4×6 DataFrames.DataFrame\n│ Row │ integers │ strings │ floats  │ dates      │ times    │ datetimes           │\n│     │ Int64    │ String  │ Float64 │ Date       │ Time     │ DateTime            │\n├─────┼──────────┼─────────┼─────────┼────────────┼──────────┼─────────────────────┤\n│ 1   │ 1        │ Hey     │ 10.2    │ 2018-02-20 │ 19:10:00 │ 2018-05-20T19:10:00 │\n│ 2   │ 2        │ You     │ 20.3    │ 2018-02-21 │ 19:20:00 │ 2018-05-20T19:20:00 │\n│ 3   │ 3        │ Out     │ 30.4    │ 2018-02-22 │ 19:30:00 │ 2018-05-20T19:30:00 │\n│ 4   │ 4        │ There   │ 40.5    │ 2018-02-23 │ 19:40:00 │ 2018-05-20T19:40:00 │","category":"page"}]
}
