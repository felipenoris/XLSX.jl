<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · XLSX.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">XLSX.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li><li><a class="tocitem" href="../migration/">Migration Guides</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/felipenoris/XLSX.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="XLSX.XLSXFile" href="#XLSX.XLSXFile"><code>XLSX.XLSXFile</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>XLSXFile</code> represents a reference to an Excel file.</p><p>It is created by using <a href="#XLSX.readxlsx"><code>XLSX.readxlsx</code></a> or <a href="#XLSX.openxlsx"><code>XLSX.openxlsx</code></a>.</p><p>From a <code>XLSXFile</code> you can navigate to a <code>XLSX.Worksheet</code> reference as shown in the example below.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">xf = XLSX.readxlsx(&quot;myfile.xlsx&quot;)
sh = xf[&quot;mysheet&quot;] # get a reference to a Worksheet</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/types.jl#L227-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.readxlsx" href="#XLSX.readxlsx"><code>XLSX.readxlsx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readxlsx(filepath) :: XLSXFile</code></pre><p>Main function for reading an Excel file. This function will read the whole Excel file into memory and return a closed XLSXFile.</p><p>Consider using <a href="#XLSX.openxlsx"><code>XLSX.openxlsx</code></a> for lazy loading of Excel file contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/read.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.openxlsx" href="#XLSX.openxlsx"><code>XLSX.openxlsx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">openxlsx(f::F, filepath::AbstractString; mode::AbstractString=&quot;r&quot;, enable_cache::Bool=true) where {F&lt;:Function}</code></pre><p>Open XLSX file for reading and/or writing. It returns an opened XLSXFile that will be automatically closed after applying <code>f</code> to the file.</p><p><strong><code>Do</code> syntax</strong></p><p>This function should be used with <code>do</code> syntax, like in:</p><pre><code class="language-julia hljs">XLSX.openxlsx(&quot;myfile.xlsx&quot;) do xf
    # read data from `xf`
end</code></pre><p><strong>Filemodes</strong></p><p>The <code>mode</code> argument controls how the file is opened. The following modes are allowed:</p><ul><li><p><code>r</code> : read mode. The existing data in <code>filepath</code> will be accessible for reading. This is the <strong>default</strong> mode.</p></li><li><p><code>w</code> : write mode. Opens an empty file that will be written to <code>filepath</code>.</p></li><li><p><code>rw</code> : edit mode. Opens <code>filepath</code> for editing. The file will be saved to disk when the function ends.</p></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>rw</code> mode is known to produce some data loss. See <a href="https://github.com/felipenoris/XLSX.jl/issues/159">#159</a>.</p><p>Simple data should work fine. Users are advised to use this feature with caution when working with formulas and charts.</p></div></div><p><strong>Arguments</strong></p><ul><li><p><code>filepath</code> is the complete path to the file.</p></li><li><p><code>mode</code> is the file mode, as explained in the last section.</p></li><li><p><code>enable_cache</code>:</p></li></ul><p>If <code>enable_cache=true</code>, all read worksheet cells will be cached. If you read a worksheet cell twice it will use the cached value instead of reading from disk in the second time.</p><p>If <code>enable_cache=false</code>, worksheet cells will always be read from disk. This is useful when you want to read a spreadsheet that doesn&#39;t fit into memory.</p><p>The default value is <code>enable_cache=true</code>.</p><p><strong>Examples</strong></p><p><strong>Read from file</strong></p><p>The following example shows how you would read worksheet cells, one row at a time, where <code>myfile.xlsx</code> is a spreadsheet that doesn&#39;t fit into memory.</p><pre><code class="language-julia hljs">julia&gt; XLSX.openxlsx(&quot;myfile.xlsx&quot;, enable_cache=false) do xf
          for r in XLSX.eachrow(xf[&quot;mysheet&quot;])
              # read something from row `r`
          end
       end</code></pre><p><strong>Write a new file</strong></p><pre><code class="language-julia hljs">XLSX.openxlsx(&quot;new.xlsx&quot;, mode=&quot;w&quot;) do xf
    sheet = xf[1]
    sheet[1, :] = [1, Date(2018, 1, 1), &quot;test&quot;]
end</code></pre><p><strong>Edit an existing file</strong></p><pre><code class="language-julia hljs">XLSX.openxlsx(&quot;edit.xlsx&quot;, mode=&quot;rw&quot;) do xf
    sheet = xf[1]
    sheet[2, :] = [2, Date(2019, 1, 1), &quot;add new line&quot;]
end</code></pre><p>See also <a href="#XLSX.readxlsx"><code>XLSX.readxlsx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/read.jl#L39-L121">source</a></section><section><div><pre><code class="nohighlight hljs">openxlsx(filepath; mode=&quot;r&quot;, enable_cache=true) :: XLSXFile</code></pre><p>Supports opening a XLSX file without using do-syntax. In this case, the user is responsible for closing the <code>XLSXFile</code> using <code>close</code> or writing it to file using <code>XLSX.writexlsx</code>.</p><p>See also <a href="#XLSX.writexlsx"><code>XLSX.writexlsx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/read.jl#L149-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.writexlsx" href="#XLSX.writexlsx"><code>XLSX.writexlsx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writexlsx(output_filepath, xlsx_file; [overwrite=false])</code></pre><p>Writes an Excel file given by <code>xlsx_file::XLSXFile</code> to file at path <code>output_filepath</code>.</p><p>If <code>overwrite=true</code>, <code>output_filepath</code> will be overwritten if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/write.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.sheetnames" href="#XLSX.sheetnames"><code>XLSX.sheetnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sheetnames(xl::XLSXFile)
sheetnames(wb::Workbook)</code></pre><p>Returns a vector with Worksheet names for this Workbook.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/workbook.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.sheetcount" href="#XLSX.sheetcount"><code>XLSX.sheetcount</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sheetcount(xlsfile) :: Int</code></pre><p>Counts the number of sheets in the Workbook.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/workbook.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.Worksheet" href="#XLSX.Worksheet"><code>XLSX.Worksheet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Worksheet</code> represents a reference to an Excel Worksheet.</p><p>From a <code>Worksheet</code> you can query for Cells, cell values and ranges.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">xf = XLSX.readxlsx(&quot;myfile.xlsx&quot;)
sh = xf[&quot;mysheet&quot;] # get a reference to a Worksheet
println( sh[2, 2] ) # access element &quot;B2&quot; (2nd row, 2nd column)
println( sh[&quot;B2&quot;] ) # you can also use the cell name
println( sh[&quot;A2:B4&quot;] ) # or a cell range
println( sh[:] ) # all data inside worksheet&#39;s dimension</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/types.jl#L170-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.readdata" href="#XLSX.readdata"><code>XLSX.readdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readdata(filepath, sheet, ref)
readdata(filepath, sheetref)</code></pre><p>Returns a scalar or matrix with values from a spreadsheet.</p><p>See also <a href="#XLSX.getdata"><code>XLSX.getdata</code></a>.</p><p><strong>Examples</strong></p><p>These function calls are equivalent.</p><pre><code class="language-julia hljs">julia&gt; XLSX.readdata(&quot;myfile.xlsx&quot;, &quot;mysheet&quot;, &quot;A2:B4&quot;)
3×2 Array{Any,2}:
 1  &quot;first&quot;
 2  &quot;second&quot;
 3  &quot;third&quot;

julia&gt; XLSX.readdata(&quot;myfile.xlsx&quot;, 1, &quot;A2:B4&quot;)
3×2 Array{Any,2}:
 1  &quot;first&quot;
 2  &quot;second&quot;
 3  &quot;third&quot;

julia&gt; XLSX.readdata(&quot;myfile.xlsx&quot;, &quot;mysheet!A2:B4&quot;)
3×2 Array{Any,2}:
 1  &quot;first&quot;
 2  &quot;second&quot;
 3  &quot;third&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/read.jl#L484-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.getdata" href="#XLSX.getdata"><code>XLSX.getdata</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getdata(sheet, ref)
getdata(sheet, row, column)</code></pre><p>Returns a scalar or a matrix with values from a spreadsheet. <code>ref</code> can be a cell reference or a range.</p><p>Indexing in a <code>Worksheet</code> will dispatch to <code>getdata</code> method.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; f = XLSX.readxlsx(&quot;myfile.xlsx&quot;)

julia&gt; sheet = f[&quot;mysheet&quot;]

julia&gt; matrix = sheet[&quot;A1:B4&quot;]

julia&gt; single_value = sheet[2, 2] # B2</code></pre><p>See also <a href="#XLSX.readdata"><code>XLSX.readdata</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/worksheet.jl#L55-L77">source</a></section><section><div><pre><code class="nohighlight hljs">getdata(ws::Worksheet, cell::Cell) :: CellValue</code></pre><p>Returns a Julia representation of a given cell value. The result data type is chosen based on the value of the cell as well as its style.</p><p>For example, date is stored as integers inside the spreadsheet, and the style is the information that is taken into account to chose <code>Date</code> as the result type.</p><p>For numbers, if the style implies that the number is visualized with decimals, the method will return a float, even if the underlying number is stored as an integer inside the spreadsheet XML.</p><p>If <code>cell</code> has empty value or empty <code>String</code>, this function will return <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/cell.jl#L108-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.getcell" href="#XLSX.getcell"><code>XLSX.getcell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getcell(xlsxfile, cell_reference_name) :: AbstractCell
getcell(worksheet, cell_reference_name) :: AbstractCell
getcell(sheetrow, column_name) :: AbstractCell
getcell(sheetrow, column_number) :: AbstractCell</code></pre><p>Returns the internal representation of a worksheet cell.</p><p>Returns <code>XLSX.EmptyCell</code> if the cell has no data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/stream.jl#L266-L275">source</a></section><section><div><pre><code class="nohighlight hljs">getcell(sheet, ref)</code></pre><p>Returns an <code>AbstractCell</code> that represents a cell in the spreadsheet.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; xf = XLSX.readxlsx(&quot;myfile.xlsx&quot;)

julia&gt; sheet = xf[&quot;mysheet&quot;]

julia&gt; cell = XLSX.getcell(sheet, &quot;A1&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/worksheet.jl#L191-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.getcellrange" href="#XLSX.getcellrange"><code>XLSX.getcellrange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getcellrange(sheet, rng)</code></pre><p>Returns a matrix with cells as <code>Array{AbstractCell, 2}</code>. <code>rng</code> must be a valid cell range, as in <code>&quot;A1:B2&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/worksheet.jl#L227-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.row_number" href="#XLSX.row_number"><code>XLSX.row_number</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">row_number(c::CellRef) :: Int</code></pre><p>Returns the row number of a given cell reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/cellref.jl#L209-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.column_number" href="#XLSX.column_number"><code>XLSX.column_number</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">column_number(c::CellRef) :: Int</code></pre><p>Returns the column number of a given cell reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/cellref.jl#L216-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.eachrow" href="#XLSX.eachrow"><code>XLSX.eachrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachrow(sheet)</code></pre><p>Creates a row iterator for a worksheet.</p><p>Example: Query all cells from columns 1 to 4.</p><pre><code class="language-julia hljs">left = 1  # 1st column
right = 4 # 4th column
for sheetrow in XLSX.eachrow(sheet)
    for column in left:right
        cell = XLSX.getcell(sheetrow, column)

        # do something with cell
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/stream.jl#L292-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.readtable" href="#XLSX.readtable"><code>XLSX.readtable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readtable(
    filepath,
    sheet,
    [columns];
    [first_row],
    [column_labels],
    [header],
    [infer_eltypes],
    [stop_in_empty_row],
    [stop_in_row_function]
) -&gt; DataTable</code></pre><p>Returns tabular data from a spreadsheet as a struct <code>XLSX.DataTable</code>. Use this function to create a <code>DataFrame</code> from package <code>DataFrames.jl</code>.</p><p>Use <code>columns</code> argument to specify which columns to get. For example, <code>&quot;B:D&quot;</code> will select columns <code>B</code>, <code>C</code> and <code>D</code>. If <code>columns</code> is not given, the algorithm will find the first sequence of consecutive non-empty cells.</p><p>Use <code>first_row</code> to indicate the first row from the table. <code>first_row=5</code> will look for a table starting at sheet row <code>5</code>. If <code>first_row</code> is not given, the algorithm will look for the first non-empty row in the spreadsheet.</p><p><code>header</code> is a <code>Bool</code> indicating if the first row is a header. If <code>header=true</code> and <code>column_labels</code> is not specified, the column labels for the table will be read from the first row of the table. If <code>header=false</code> and <code>column_labels</code> is not specified, the algorithm will generate column labels. The default value is <code>header=true</code>.</p><p>Use <code>column_labels</code> to specify names for the header of the table.</p><p>Use <code>infer_eltypes=true</code> to get <code>data</code> as a <code>Vector{Any}</code> of typed vectors. The default value is <code>infer_eltypes=false</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating wether an empty row marks the end of the table. If <code>stop_in_empty_row=false</code>, the <code>TableRowIterator</code> will continue to fetch rows until there&#39;s no more rows in the Worksheet. The default behavior is <code>stop_in_empty_row=true</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns a <code>Bool</code> indicating if the end of the table was reached.</p><p>Example for <code>stop_in_row_function</code>:</p><pre><code class="nohighlight hljs">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p>Rows where all column values are equal to <code>missing</code> are dropped.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFrames, XLSX

julia&gt; df = DataFrame(XLSX.readtable(&quot;myfile.xlsx&quot;, &quot;mysheet&quot;))</code></pre><p>See also: <a href="#XLSX.gettable"><code>XLSX.gettable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/read.jl#L530-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.gettable" href="#XLSX.gettable"><code>XLSX.gettable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gettable(
    sheet,
    [columns];
    [first_row],
    [column_labels],
    [header],
    [infer_eltypes],
    [stop_in_empty_row],
    [stop_in_row_function]
) -&gt; DataTable</code></pre><p>Returns tabular data from a spreadsheet as a struct <code>XLSX.DataTable</code>. Use this function to create a <code>DataFrame</code> from package <code>DataFrames.jl</code>.</p><p>Use <code>columns</code> argument to specify which columns to get. For example, <code>columns=&quot;B:D&quot;</code> will select columns <code>B</code>, <code>C</code> and <code>D</code>. If <code>columns</code> is not given, the algorithm will find the first sequence of consecutive non-empty cells.</p><p>Use <code>first_row</code> to indicate the first row from the table. <code>first_row=5</code> will look for a table starting at sheet row <code>5</code>. If <code>first_row</code> is not given, the algorithm will look for the first non-empty row in the spreadsheet.</p><p><code>header</code> is a <code>Bool</code> indicating if the first row is a header. If <code>header=true</code> and <code>column_labels</code> is not specified, the column labels for the table will be read from the first row of the table. If <code>header=false</code> and <code>column_labels</code> is not specified, the algorithm will generate column labels. The default value is <code>header=true</code>.</p><p>Use <code>column_labels</code> as a vector of symbols to specify names for the header of the table.</p><p>Use <code>infer_eltypes=true</code> to get <code>data</code> as a <code>Vector{Any}</code> of typed vectors. The default value is <code>infer_eltypes=false</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating wether an empty row marks the end of the table. If <code>stop_in_empty_row=false</code>, the <code>TableRowIterator</code> will continue to fetch rows until there&#39;s no more rows in the Worksheet. The default behavior is <code>stop_in_empty_row=true</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns a <code>Bool</code> indicating if the end of the table was reached.</p><p><strong>Example for <code>stop_in_row_function</code></strong></p><pre><code class="language-julia hljs">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p>Rows where all column values are equal to <code>missing</code> are dropped.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; using DataFrames, XLSX

julia&gt; df = XLSX.openxlsx(&quot;myfile.xlsx&quot;) do xf
        DataFrame(XLSX.gettable(xf[&quot;mysheet&quot;]))
    end</code></pre><p>See also: <a href="#XLSX.readtable"><code>XLSX.readtable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/table.jl#L485-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.eachtablerow" href="#XLSX.eachtablerow"><code>XLSX.eachtablerow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">eachtablerow(sheet, [columns]; [first_row], [column_labels], [header], [stop_in_empty_row], [stop_in_row_function])</code></pre><p>Constructs an iterator of table rows. Each element of the iterator is of type <code>TableRow</code>.</p><p><code>header</code> is a boolean indicating wether the first row of the table is a table header.</p><p>If <code>header == false</code> and no <code>column_labels</code> were supplied, column names will be generated following the column names found in the Excel file.</p><p>The <code>columns</code> argument is a column range, as in <code>&quot;B:E&quot;</code>. If <code>columns</code> is not supplied, the column range will be inferred by the non-empty contiguous cells in the first row of the table.</p><p>The user can replace column names by assigning the optional <code>column_labels</code> input variable with a <code>Vector{Symbol}</code>.</p><p><code>stop_in_empty_row</code> is a boolean indicating wether an empty row marks the end of the table. If <code>stop_in_empty_row=false</code>, the iterator will continue to fetch rows until there&#39;s no more rows in the Worksheet. The default behavior is <code>stop_in_empty_row=true</code>. Empty rows may be returned by the iterator when <code>stop_in_empty_row=false</code>.</p><p><code>stop_in_row_function</code> is a Function that receives a <code>TableRow</code> and returns a <code>Bool</code> indicating if the end of the table was reached.</p><p>Example for <code>stop_in_row_function</code>:</p><pre><code class="nohighlight hljs">function stop_function(r)
    v = r[:col_label]
    return !ismissing(v) &amp;&amp; v == &quot;unwanted value&quot;
end</code></pre><p>Example code:</p><pre><code class="nohighlight hljs">for r in XLSX.eachtablerow(sheet)
    # r is a `TableRow`. Values are read using column labels or numbers.
    rn = XLSX.row_number(r) # `TableRow` row number.
    v1 = r[1] # will read value at table column 1.
    v2 = r[:COL_LABEL2] # will read value at column labeled `:COL_LABEL2`.
end</code></pre><p>See also <a href="#XLSX.gettable"><code>XLSX.gettable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/table.jl#L76-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.writetable" href="#XLSX.writetable"><code>XLSX.writetable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writetable(filename, table; [overwrite], [sheetname])</code></pre><p>Write Tables.jl <code>table</code> to the specified filename.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/tables_interface.jl#L25-L29">source</a></section><section><div><pre><code class="nohighlight hljs">writetable(filename::AbstractString, tables::Vector{Pair{String, T}}; overwrite::Bool=false)
writetable(filename::AbstractString, tables::Pair{String, Any}...; overwrite::Bool=false)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/tables_interface.jl#L32-L35">source</a></section><section><div><pre><code class="nohighlight hljs">writetable(filename, data, columnnames; [overwrite], [sheetname])</code></pre><ul><li><code>data</code> is a vector of columns.</li><li><code>columnames</code> is a vector of column labels.</li><li><code>overwrite</code> is a <code>Bool</code> to control if <code>filename</code> should be overwritten if already exists.</li><li><code>sheetname</code> is the name for the worksheet.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">import XLSX
columns = [ [1, 2, 3, 4], [&quot;Hey&quot;, &quot;You&quot;, &quot;Out&quot;, &quot;There&quot;], [10.2, 20.3, 30.4, 40.5] ]
colnames = [ &quot;integers&quot;, &quot;strings&quot;, &quot;floats&quot; ]
XLSX.writetable(&quot;table.xlsx&quot;, columns, colnames)</code></pre><p>See also: <a href="#XLSX.writetable!"><code>XLSX.writetable!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/write.jl#L579-L597">source</a></section><section><div><pre><code class="nohighlight hljs">writetable(filename::AbstractString; overwrite::Bool=false, kw...)
writetable(filename::AbstractString, tables::Vector{Tuple{String, Vector{Any}, Vector{String}}}; overwrite::Bool=false)</code></pre><p>Write multiple tables.</p><p><code>kw</code> is a variable keyword argument list. Each element should be in this format: <code>sheetname=( data, column_names )</code>, where <code>data</code> is a vector of columns and <code>column_names</code> is a vector of column labels.</p><p>Example:</p><pre><code class="language-julia hljs">julia&gt; import DataFrames, XLSX

julia&gt; df1 = DataFrames.DataFrame(COL1=[10,20,30], COL2=[&quot;Fist&quot;, &quot;Sec&quot;, &quot;Third&quot;])

julia&gt; df2 = DataFrames.DataFrame(AA=[&quot;aa&quot;, &quot;bb&quot;], AB=[10.1, 10.2])

julia&gt; XLSX.writetable(&quot;report.xlsx&quot;, &quot;REPORT_A&quot; =&gt; df1, &quot;REPORT_B&quot; =&gt; df2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/write.jl#L618-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.writetable!" href="#XLSX.writetable!"><code>XLSX.writetable!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writetable!(sheet::Worksheet, table; anchor_cell::CellRef=CellRef(&quot;A1&quot;)))</code></pre><p>Write Tables.jl <code>table</code> to the specified sheet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/tables_interface.jl#L43-L47">source</a></section><section><div><pre><code class="nohighlight hljs">writetable!(sheet::Worksheet, data, columnnames; anchor_cell::CellRef=CellRef(&quot;A1&quot;))</code></pre><p>Writes tabular data <code>data</code> with labels given by <code>columnnames</code> to <code>sheet</code>, starting at <code>anchor_cell</code>.</p><p><code>data</code> must be a vector of columns. <code>columnnames</code> must be a vector of column labels.</p><p>See also: <a href="#XLSX.writetable"><code>XLSX.writetable</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/write.jl#L389-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.rename!" href="#XLSX.rename!"><code>XLSX.rename!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rename!(ws::Worksheet, name::AbstractString)</code></pre><p>Renames a <code>Worksheet</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/write.jl#L429-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="XLSX.addsheet!" href="#XLSX.addsheet!"><code>XLSX.addsheet!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">addsheet!(workbook, [name]) :: Worksheet</code></pre><p>Create a new worksheet with named <code>name</code>. If <code>name</code> is not provided, a unique name is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/felipenoris/XLSX.jl/blob/73f67beba3bd075de036398ad8879618b20815f8/src/write.jl#L471-L476">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../migration/">Migration Guides »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Wednesday 27 July 2022 21:48">Wednesday 27 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
